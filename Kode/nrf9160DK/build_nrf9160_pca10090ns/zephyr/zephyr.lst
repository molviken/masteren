
zephyr.elf:     file format elf32-littlearm


Disassembly of section rom_start:

0000c000 <_vector_table>:
    c000:	20020578 	.word	0x20020578
    c004:	0000cbc9 	.word	0x0000cbc9
    c008:	0000e50b 	.word	0x0000e50b
    c00c:	0000ca3d 	.word	0x0000ca3d
    c010:	0000ca3d 	.word	0x0000ca3d
    c014:	0000ca3d 	.word	0x0000ca3d
    c018:	0000ca3d 	.word	0x0000ca3d
    c01c:	0000ca3d 	.word	0x0000ca3d
    c020:	0000ca3d 	.word	0x0000ca3d
    c024:	0000ca3d 	.word	0x0000ca3d
    c028:	0000ca3d 	.word	0x0000ca3d
    c02c:	0000ca05 	.word	0x0000ca05
    c030:	0000ca3d 	.word	0x0000ca3d
    c034:	0000ca3d 	.word	0x0000ca3d
    c038:	0000c9b1 	.word	0x0000c9b1
    c03c:	0000e4f7 	.word	0x0000e4f7

0000c040 <_irq_vector_table>:
    c040:	0000ca59 0000ca59 0000ca59 0000ca59     Y...Y...Y...Y...
    c050:	0000ca59 0000ca59 0000ca59 0000ca59     Y...Y...Y...Y...
    c060:	0000ca59 0000ca59 0000ca59 0000ca59     Y...Y...Y...Y...
    c070:	0000ca59 0000ca59 0000ca59 0000ca59     Y...Y...Y...Y...
    c080:	0000ca59 0000ca59 0000ca59 0000ca59     Y...Y...Y...Y...
    c090:	0000ca59 0000ca59 0000ca59 0000ca59     Y...Y...Y...Y...
    c0a0:	0000ca59 0000ca59 0000ca59 0000ca59     Y...Y...Y...Y...
    c0b0:	0000ca59 0000ca59 0000ca59 0000ca59     Y...Y...Y...Y...
    c0c0:	0000ca59 0000ca59 0000ca59 0000ca59     Y...Y...Y...Y...
    c0d0:	0000ca59 0000ca59 0000ca59 0000ca59     Y...Y...Y...Y...
    c0e0:	0000ca59 0000ca59 0000ca59 0000ca59     Y...Y...Y...Y...
    c0f0:	0000ca59 0000ca59 0000ca59 0000ca59     Y...Y...Y...Y...
    c100:	0000ca59 0000ca59 0000ca59 0000ca59     Y...Y...Y...Y...
    c110:	0000ca59 0000ca59 0000ca59 0000ca59     Y...Y...Y...Y...
    c120:	0000ca59 0000ca59 0000ca59 0000ca59     Y...Y...Y...Y...
    c130:	0000ca59 0000ca59 0000ca59 0000ca59     Y...Y...Y...Y...
    c140:	0000ca59                                Y...

0000c144 <_vector_end>:
	...

0000c200 <m_firmware_info>:
    c200:	281ee6de 8fcebb4c 00005b02 0000003c     ...(L....[..<...
    c210:	00002df4 00000001 0000c000 0000c000     .-..............
    c220:	9102ffff 00000000 00000000 00000000     ................
	...

Disassembly of section text:

0000c23c <__aeabi_uldivmod>:
    c23c:	b953      	cbnz	r3, c254 <__aeabi_uldivmod+0x18>
    c23e:	b94a      	cbnz	r2, c254 <__aeabi_uldivmod+0x18>
    c240:	2900      	cmp	r1, #0
    c242:	bf08      	it	eq
    c244:	2800      	cmpeq	r0, #0
    c246:	bf1c      	itt	ne
    c248:	f04f 31ff 	movne.w	r1, #4294967295
    c24c:	f04f 30ff 	movne.w	r0, #4294967295
    c250:	f000 b970 	b.w	c534 <__aeabi_idiv0>
    c254:	f1ad 0c08 	sub.w	ip, sp, #8
    c258:	e96d ce04 	strd	ip, lr, [sp, #-16]!
    c25c:	f000 f806 	bl	c26c <__udivmoddi4>
    c260:	f8dd e004 	ldr.w	lr, [sp, #4]
    c264:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
    c268:	b004      	add	sp, #16
    c26a:	4770      	bx	lr

0000c26c <__udivmoddi4>:
    c26c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    c270:	9e09      	ldr	r6, [sp, #36]	; 0x24
    c272:	4604      	mov	r4, r0
    c274:	4689      	mov	r9, r1
    c276:	2b00      	cmp	r3, #0
    c278:	f040 8083 	bne.w	c382 <__udivmoddi4+0x116>
    c27c:	428a      	cmp	r2, r1
    c27e:	4615      	mov	r5, r2
    c280:	d945      	bls.n	c30e <__udivmoddi4+0xa2>
    c282:	fab2 f282 	clz	r2, r2
    c286:	b14a      	cbz	r2, c29c <__udivmoddi4+0x30>
    c288:	f1c2 0720 	rsb	r7, r2, #32
    c28c:	fa01 f302 	lsl.w	r3, r1, r2
    c290:	4095      	lsls	r5, r2
    c292:	4094      	lsls	r4, r2
    c294:	fa20 f707 	lsr.w	r7, r0, r7
    c298:	ea47 0903 	orr.w	r9, r7, r3
    c29c:	ea4f 4e15 	mov.w	lr, r5, lsr #16
    c2a0:	0c23      	lsrs	r3, r4, #16
    c2a2:	fa1f f885 	uxth.w	r8, r5
    c2a6:	fbb9 fcfe 	udiv	ip, r9, lr
    c2aa:	fb0e 991c 	mls	r9, lr, ip, r9
    c2ae:	fb0c f108 	mul.w	r1, ip, r8
    c2b2:	ea43 4309 	orr.w	r3, r3, r9, lsl #16
    c2b6:	4299      	cmp	r1, r3
    c2b8:	d90a      	bls.n	c2d0 <__udivmoddi4+0x64>
    c2ba:	18eb      	adds	r3, r5, r3
    c2bc:	bf2c      	ite	cs
    c2be:	2001      	movcs	r0, #1
    c2c0:	2000      	movcc	r0, #0
    c2c2:	4299      	cmp	r1, r3
    c2c4:	d902      	bls.n	c2cc <__udivmoddi4+0x60>
    c2c6:	2800      	cmp	r0, #0
    c2c8:	f000 811d 	beq.w	c506 <__udivmoddi4+0x29a>
    c2cc:	f10c 3cff 	add.w	ip, ip, #4294967295
    c2d0:	1a59      	subs	r1, r3, r1
    c2d2:	b2a3      	uxth	r3, r4
    c2d4:	fbb1 f0fe 	udiv	r0, r1, lr
    c2d8:	fb0e 1110 	mls	r1, lr, r0, r1
    c2dc:	fb00 f808 	mul.w	r8, r0, r8
    c2e0:	ea43 4401 	orr.w	r4, r3, r1, lsl #16
    c2e4:	45a0      	cmp	r8, r4
    c2e6:	d905      	bls.n	c2f4 <__udivmoddi4+0x88>
    c2e8:	192c      	adds	r4, r5, r4
    c2ea:	d202      	bcs.n	c2f2 <__udivmoddi4+0x86>
    c2ec:	45a0      	cmp	r8, r4
    c2ee:	f200 810e 	bhi.w	c50e <__udivmoddi4+0x2a2>
    c2f2:	3801      	subs	r0, #1
    c2f4:	eba4 0408 	sub.w	r4, r4, r8
    c2f8:	ea40 400c 	orr.w	r0, r0, ip, lsl #16
    c2fc:	2700      	movs	r7, #0
    c2fe:	b11e      	cbz	r6, c308 <__udivmoddi4+0x9c>
    c300:	40d4      	lsrs	r4, r2
    c302:	2300      	movs	r3, #0
    c304:	e9c6 4300 	strd	r4, r3, [r6]
    c308:	4639      	mov	r1, r7
    c30a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    c30e:	2a00      	cmp	r2, #0
    c310:	d051      	beq.n	c3b6 <__udivmoddi4+0x14a>
    c312:	fab2 f282 	clz	r2, r2
    c316:	2a00      	cmp	r2, #0
    c318:	f040 80af 	bne.w	c47a <__udivmoddi4+0x20e>
    c31c:	1b49      	subs	r1, r1, r5
    c31e:	ea4f 4e15 	mov.w	lr, r5, lsr #16
    c322:	fa1f f885 	uxth.w	r8, r5
    c326:	2701      	movs	r7, #1
    c328:	0c23      	lsrs	r3, r4, #16
    c32a:	fbb1 fcfe 	udiv	ip, r1, lr
    c32e:	fb0e 111c 	mls	r1, lr, ip, r1
    c332:	fb08 f00c 	mul.w	r0, r8, ip
    c336:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
    c33a:	4298      	cmp	r0, r3
    c33c:	d90a      	bls.n	c354 <__udivmoddi4+0xe8>
    c33e:	18eb      	adds	r3, r5, r3
    c340:	bf2c      	ite	cs
    c342:	2101      	movcs	r1, #1
    c344:	2100      	movcc	r1, #0
    c346:	4298      	cmp	r0, r3
    c348:	d902      	bls.n	c350 <__udivmoddi4+0xe4>
    c34a:	2900      	cmp	r1, #0
    c34c:	f000 80d7 	beq.w	c4fe <__udivmoddi4+0x292>
    c350:	f10c 3cff 	add.w	ip, ip, #4294967295
    c354:	1a19      	subs	r1, r3, r0
    c356:	b2a3      	uxth	r3, r4
    c358:	fbb1 f0fe 	udiv	r0, r1, lr
    c35c:	fb0e 1110 	mls	r1, lr, r0, r1
    c360:	fb08 f800 	mul.w	r8, r8, r0
    c364:	ea43 4401 	orr.w	r4, r3, r1, lsl #16
    c368:	45a0      	cmp	r8, r4
    c36a:	d905      	bls.n	c378 <__udivmoddi4+0x10c>
    c36c:	192c      	adds	r4, r5, r4
    c36e:	d202      	bcs.n	c376 <__udivmoddi4+0x10a>
    c370:	45a0      	cmp	r8, r4
    c372:	f200 80c1 	bhi.w	c4f8 <__udivmoddi4+0x28c>
    c376:	3801      	subs	r0, #1
    c378:	eba4 0408 	sub.w	r4, r4, r8
    c37c:	ea40 400c 	orr.w	r0, r0, ip, lsl #16
    c380:	e7bd      	b.n	c2fe <__udivmoddi4+0x92>
    c382:	428b      	cmp	r3, r1
    c384:	d908      	bls.n	c398 <__udivmoddi4+0x12c>
    c386:	2e00      	cmp	r6, #0
    c388:	d074      	beq.n	c474 <__udivmoddi4+0x208>
    c38a:	2700      	movs	r7, #0
    c38c:	e9c6 0100 	strd	r0, r1, [r6]
    c390:	4638      	mov	r0, r7
    c392:	4639      	mov	r1, r7
    c394:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    c398:	fab3 f783 	clz	r7, r3
    c39c:	b967      	cbnz	r7, c3b8 <__udivmoddi4+0x14c>
    c39e:	428b      	cmp	r3, r1
    c3a0:	f0c0 80a4 	bcc.w	c4ec <__udivmoddi4+0x280>
    c3a4:	4282      	cmp	r2, r0
    c3a6:	f240 80a1 	bls.w	c4ec <__udivmoddi4+0x280>
    c3aa:	4638      	mov	r0, r7
    c3ac:	2e00      	cmp	r6, #0
    c3ae:	d0ab      	beq.n	c308 <__udivmoddi4+0x9c>
    c3b0:	e9c6 4900 	strd	r4, r9, [r6]
    c3b4:	e7a8      	b.n	c308 <__udivmoddi4+0x9c>
    c3b6:	deff      	udf	#255	; 0xff
    c3b8:	f1c7 0520 	rsb	r5, r7, #32
    c3bc:	40bb      	lsls	r3, r7
    c3be:	fa02 fc07 	lsl.w	ip, r2, r7
    c3c2:	fa01 f407 	lsl.w	r4, r1, r7
    c3c6:	40ea      	lsrs	r2, r5
    c3c8:	fa20 f805 	lsr.w	r8, r0, r5
    c3cc:	40e9      	lsrs	r1, r5
    c3ce:	fa00 fe07 	lsl.w	lr, r0, r7
    c3d2:	431a      	orrs	r2, r3
    c3d4:	ea48 0404 	orr.w	r4, r8, r4
    c3d8:	ea4f 4812 	mov.w	r8, r2, lsr #16
    c3dc:	0c20      	lsrs	r0, r4, #16
    c3de:	fa1f f982 	uxth.w	r9, r2
    c3e2:	fbb1 faf8 	udiv	sl, r1, r8
    c3e6:	fb08 111a 	mls	r1, r8, sl, r1
    c3ea:	fb0a fb09 	mul.w	fp, sl, r9
    c3ee:	ea40 4101 	orr.w	r1, r0, r1, lsl #16
    c3f2:	458b      	cmp	fp, r1
    c3f4:	d90a      	bls.n	c40c <__udivmoddi4+0x1a0>
    c3f6:	1851      	adds	r1, r2, r1
    c3f8:	bf2c      	ite	cs
    c3fa:	2301      	movcs	r3, #1
    c3fc:	2300      	movcc	r3, #0
    c3fe:	458b      	cmp	fp, r1
    c400:	d902      	bls.n	c408 <__udivmoddi4+0x19c>
    c402:	2b00      	cmp	r3, #0
    c404:	f000 8088 	beq.w	c518 <__udivmoddi4+0x2ac>
    c408:	f10a 3aff 	add.w	sl, sl, #4294967295
    c40c:	eba1 010b 	sub.w	r1, r1, fp
    c410:	b2a4      	uxth	r4, r4
    c412:	fbb1 f0f8 	udiv	r0, r1, r8
    c416:	fb08 1110 	mls	r1, r8, r0, r1
    c41a:	fb00 f909 	mul.w	r9, r0, r9
    c41e:	ea44 4101 	orr.w	r1, r4, r1, lsl #16
    c422:	4589      	cmp	r9, r1
    c424:	d904      	bls.n	c430 <__udivmoddi4+0x1c4>
    c426:	1851      	adds	r1, r2, r1
    c428:	d201      	bcs.n	c42e <__udivmoddi4+0x1c2>
    c42a:	4589      	cmp	r9, r1
    c42c:	d87b      	bhi.n	c526 <__udivmoddi4+0x2ba>
    c42e:	3801      	subs	r0, #1
    c430:	ea40 400a 	orr.w	r0, r0, sl, lsl #16
    c434:	eba1 0109 	sub.w	r1, r1, r9
    c438:	fba0 890c 	umull	r8, r9, r0, ip
    c43c:	4549      	cmp	r1, r9
    c43e:	4644      	mov	r4, r8
    c440:	464b      	mov	r3, r9
    c442:	d302      	bcc.n	c44a <__udivmoddi4+0x1de>
    c444:	d106      	bne.n	c454 <__udivmoddi4+0x1e8>
    c446:	45c6      	cmp	lr, r8
    c448:	d204      	bcs.n	c454 <__udivmoddi4+0x1e8>
    c44a:	3801      	subs	r0, #1
    c44c:	ebb8 040c 	subs.w	r4, r8, ip
    c450:	eb69 0302 	sbc.w	r3, r9, r2
    c454:	2e00      	cmp	r6, #0
    c456:	d05d      	beq.n	c514 <__udivmoddi4+0x2a8>
    c458:	ebbe 0204 	subs.w	r2, lr, r4
    c45c:	eb61 0103 	sbc.w	r1, r1, r3
    c460:	fa01 f505 	lsl.w	r5, r1, r5
    c464:	fa22 f307 	lsr.w	r3, r2, r7
    c468:	40f9      	lsrs	r1, r7
    c46a:	2700      	movs	r7, #0
    c46c:	431d      	orrs	r5, r3
    c46e:	e9c6 5100 	strd	r5, r1, [r6]
    c472:	e749      	b.n	c308 <__udivmoddi4+0x9c>
    c474:	4637      	mov	r7, r6
    c476:	4630      	mov	r0, r6
    c478:	e746      	b.n	c308 <__udivmoddi4+0x9c>
    c47a:	f1c2 0020 	rsb	r0, r2, #32
    c47e:	4095      	lsls	r5, r2
    c480:	fa01 f702 	lsl.w	r7, r1, r2
    c484:	fa21 f300 	lsr.w	r3, r1, r0
    c488:	ea4f 4e15 	mov.w	lr, r5, lsr #16
    c48c:	fa24 f100 	lsr.w	r1, r4, r0
    c490:	fa1f f885 	uxth.w	r8, r5
    c494:	4094      	lsls	r4, r2
    c496:	4339      	orrs	r1, r7
    c498:	fbb3 f0fe 	udiv	r0, r3, lr
    c49c:	0c0f      	lsrs	r7, r1, #16
    c49e:	fb0e 3310 	mls	r3, lr, r0, r3
    c4a2:	fb00 fc08 	mul.w	ip, r0, r8
    c4a6:	ea47 4303 	orr.w	r3, r7, r3, lsl #16
    c4aa:	459c      	cmp	ip, r3
    c4ac:	d907      	bls.n	c4be <__udivmoddi4+0x252>
    c4ae:	18eb      	adds	r3, r5, r3
    c4b0:	bf2c      	ite	cs
    c4b2:	2701      	movcs	r7, #1
    c4b4:	2700      	movcc	r7, #0
    c4b6:	459c      	cmp	ip, r3
    c4b8:	d900      	bls.n	c4bc <__udivmoddi4+0x250>
    c4ba:	b38f      	cbz	r7, c520 <__udivmoddi4+0x2b4>
    c4bc:	3801      	subs	r0, #1
    c4be:	eba3 030c 	sub.w	r3, r3, ip
    c4c2:	b289      	uxth	r1, r1
    c4c4:	fbb3 f7fe 	udiv	r7, r3, lr
    c4c8:	fb0e 3317 	mls	r3, lr, r7, r3
    c4cc:	fb07 fc08 	mul.w	ip, r7, r8
    c4d0:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
    c4d4:	458c      	cmp	ip, r1
    c4d6:	d904      	bls.n	c4e2 <__udivmoddi4+0x276>
    c4d8:	1869      	adds	r1, r5, r1
    c4da:	d201      	bcs.n	c4e0 <__udivmoddi4+0x274>
    c4dc:	458c      	cmp	ip, r1
    c4de:	d825      	bhi.n	c52c <__udivmoddi4+0x2c0>
    c4e0:	3f01      	subs	r7, #1
    c4e2:	eba1 010c 	sub.w	r1, r1, ip
    c4e6:	ea47 4700 	orr.w	r7, r7, r0, lsl #16
    c4ea:	e71d      	b.n	c328 <__udivmoddi4+0xbc>
    c4ec:	1a84      	subs	r4, r0, r2
    c4ee:	eb61 0303 	sbc.w	r3, r1, r3
    c4f2:	2001      	movs	r0, #1
    c4f4:	4699      	mov	r9, r3
    c4f6:	e759      	b.n	c3ac <__udivmoddi4+0x140>
    c4f8:	3802      	subs	r0, #2
    c4fa:	442c      	add	r4, r5
    c4fc:	e73c      	b.n	c378 <__udivmoddi4+0x10c>
    c4fe:	f1ac 0c02 	sub.w	ip, ip, #2
    c502:	442b      	add	r3, r5
    c504:	e726      	b.n	c354 <__udivmoddi4+0xe8>
    c506:	f1ac 0c02 	sub.w	ip, ip, #2
    c50a:	442b      	add	r3, r5
    c50c:	e6e0      	b.n	c2d0 <__udivmoddi4+0x64>
    c50e:	3802      	subs	r0, #2
    c510:	442c      	add	r4, r5
    c512:	e6ef      	b.n	c2f4 <__udivmoddi4+0x88>
    c514:	4637      	mov	r7, r6
    c516:	e6f7      	b.n	c308 <__udivmoddi4+0x9c>
    c518:	f1aa 0a02 	sub.w	sl, sl, #2
    c51c:	4411      	add	r1, r2
    c51e:	e775      	b.n	c40c <__udivmoddi4+0x1a0>
    c520:	3802      	subs	r0, #2
    c522:	442b      	add	r3, r5
    c524:	e7cb      	b.n	c4be <__udivmoddi4+0x252>
    c526:	3802      	subs	r0, #2
    c528:	4411      	add	r1, r2
    c52a:	e781      	b.n	c430 <__udivmoddi4+0x1c4>
    c52c:	3f02      	subs	r7, #2
    c52e:	4429      	add	r1, r5
    c530:	e7d7      	b.n	c4e2 <__udivmoddi4+0x276>
    c532:	bf00      	nop

0000c534 <__aeabi_idiv0>:
    c534:	4770      	bx	lr
    c536:	bf00      	nop

0000c538 <main>:
#include <zephyr.h>
#include <sys/printk.h>

void main(void){
	printk("Hello World!\n");
    c538:	4801      	ldr	r0, [pc, #4]	; (c540 <main+0x8>)
    c53a:	f001 bf4f 	b.w	e3dc <printk>
    c53e:	bf00      	nop
    c540:	0000ecd4 	.word	0x0000ecd4

0000c544 <char_out>:

static int char_out(int c, void *ctx_p)
{
	struct out_context *ctx = ctx_p;

	ctx->count++;
    c544:	680b      	ldr	r3, [r1, #0]
    c546:	3301      	adds	r3, #1
    c548:	600b      	str	r3, [r1, #0]
	return _char_out(c);
    c54a:	4b01      	ldr	r3, [pc, #4]	; (c550 <char_out+0xc>)
    c54c:	681b      	ldr	r3, [r3, #0]
    c54e:	4718      	bx	r3
    c550:	20020eb8 	.word	0x20020eb8

0000c554 <_printk_dec_ulong>:
 * @return N/A
 */
static void _printk_dec_ulong(out_func_t out, void *ctx,
			      const unsigned long num, enum pad_type padding,
			      int min_width)
{
    c554:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    c558:	b085      	sub	sp, #20
    c55a:	9c0e      	ldr	r4, [sp, #56]	; 0x38
    c55c:	469b      	mov	fp, r3
    c55e:	2c01      	cmp	r4, #1
    c560:	bfb8      	it	lt
    c562:	2401      	movlt	r4, #1
    c564:	2b01      	cmp	r3, #1
    c566:	bf0c      	ite	eq
    c568:	2330      	moveq	r3, #48	; 0x30
    c56a:	2320      	movne	r3, #32
    c56c:	4616      	mov	r6, r2
    c56e:	4682      	mov	sl, r0
    c570:	4688      	mov	r8, r1
    c572:	2501      	movs	r5, #1
    c574:	270a      	movs	r7, #10
    c576:	2200      	movs	r2, #0
    c578:	f8df 906c 	ldr.w	r9, [pc, #108]	; c5e8 <_printk_dec_ulong+0x94>
    c57c:	9302      	str	r3, [sp, #8]
	if (min_width <= 0) {
		min_width = 1;
	}

	while (pos >= 10) {
		if (found_largest_digit != 0 || remainder >= pos) {
    c57e:	fbb6 f3f9 	udiv	r3, r6, r9
    c582:	9301      	str	r3, [sp, #4]
    c584:	b90a      	cbnz	r2, c58a <_printk_dec_ulong+0x36>
    c586:	45b1      	cmp	r9, r6
    c588:	d81c      	bhi.n	c5c4 <_printk_dec_ulong+0x70>
			found_largest_digit = 1;
			out((int)(remainder / pos + 48), ctx);
    c58a:	9b01      	ldr	r3, [sp, #4]
    c58c:	4641      	mov	r1, r8
    c58e:	f103 0030 	add.w	r0, r3, #48	; 0x30
    c592:	47d0      	blx	sl
			found_largest_digit = 1;
    c594:	2201      	movs	r2, #1
			digits++;
    c596:	3501      	adds	r5, #1
				&& padding < PAD_SPACE_AFTER) {
			out((int)(padding == PAD_ZERO_BEFORE ? '0' : ' '), ctx);
			digits++;
		}
		remaining--;
		remainder %= pos;
    c598:	9b01      	ldr	r3, [sp, #4]
		remaining--;
    c59a:	3f01      	subs	r7, #1
		remainder %= pos;
    c59c:	fb09 6613 	mls	r6, r9, r3, r6
		pos /= 10;
    c5a0:	230a      	movs	r3, #10
	while (pos >= 10) {
    c5a2:	2f01      	cmp	r7, #1
		pos /= 10;
    c5a4:	fbb9 f9f3 	udiv	r9, r9, r3
	while (pos >= 10) {
    c5a8:	d1e9      	bne.n	c57e <_printk_dec_ulong+0x2a>
	}
	out((int)(remainder + 48), ctx);
    c5aa:	4641      	mov	r1, r8
    c5ac:	f106 0030 	add.w	r0, r6, #48	; 0x30
    c5b0:	47d0      	blx	sl

	if (padding == PAD_SPACE_AFTER) {
    c5b2:	f1bb 0f03 	cmp.w	fp, #3
    c5b6:	d102      	bne.n	c5be <_printk_dec_ulong+0x6a>
		remaining = min_width - digits;
    c5b8:	1b64      	subs	r4, r4, r5
		while (remaining-- > 0) {
    c5ba:	2c00      	cmp	r4, #0
    c5bc:	dc0e      	bgt.n	c5dc <_printk_dec_ulong+0x88>
			out(' ', ctx);
		}
	}
}
    c5be:	b005      	add	sp, #20
    c5c0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		} else if (remaining <= min_width
    c5c4:	42bc      	cmp	r4, r7
    c5c6:	dbe7      	blt.n	c598 <_printk_dec_ulong+0x44>
				&& padding < PAD_SPACE_AFTER) {
    c5c8:	f1bb 0f02 	cmp.w	fp, #2
    c5cc:	d8e4      	bhi.n	c598 <_printk_dec_ulong+0x44>
			out((int)(padding == PAD_ZERO_BEFORE ? '0' : ' '), ctx);
    c5ce:	4641      	mov	r1, r8
    c5d0:	9802      	ldr	r0, [sp, #8]
    c5d2:	9203      	str	r2, [sp, #12]
			digits++;
    c5d4:	3501      	adds	r5, #1
			out((int)(padding == PAD_ZERO_BEFORE ? '0' : ' '), ctx);
    c5d6:	47d0      	blx	sl
			digits++;
    c5d8:	9a03      	ldr	r2, [sp, #12]
    c5da:	e7dd      	b.n	c598 <_printk_dec_ulong+0x44>
			out(' ', ctx);
    c5dc:	4641      	mov	r1, r8
    c5de:	2020      	movs	r0, #32
    c5e0:	47d0      	blx	sl
    c5e2:	3c01      	subs	r4, #1
    c5e4:	e7e9      	b.n	c5ba <_printk_dec_ulong+0x66>
    c5e6:	bf00      	nop
    c5e8:	3b9aca00 	.word	0x3b9aca00

0000c5ec <__printk_hook_install>:
	_char_out = fn;
    c5ec:	4b01      	ldr	r3, [pc, #4]	; (c5f4 <__printk_hook_install+0x8>)
    c5ee:	6018      	str	r0, [r3, #0]
}
    c5f0:	4770      	bx	lr
    c5f2:	bf00      	nop
    c5f4:	20020eb8 	.word	0x20020eb8

0000c5f8 <vprintk>:
	struct out_context ctx = { 0 };
    c5f8:	2300      	movs	r3, #0
{
    c5fa:	b507      	push	{r0, r1, r2, lr}
	z_vprintk(char_out, &ctx, fmt, ap);
    c5fc:	4602      	mov	r2, r0
	struct out_context ctx = { 0 };
    c5fe:	9301      	str	r3, [sp, #4]
	z_vprintk(char_out, &ctx, fmt, ap);
    c600:	4803      	ldr	r0, [pc, #12]	; (c610 <vprintk+0x18>)
    c602:	460b      	mov	r3, r1
    c604:	a901      	add	r1, sp, #4
    c606:	f001 fd79 	bl	e0fc <z_vprintk>
}
    c60a:	b003      	add	sp, #12
    c60c:	f85d fb04 	ldr.w	pc, [sp], #4
    c610:	0000c545 	.word	0x0000c545

0000c614 <nordicsemi_nrf91_init>:
		:
		: "memory");
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	unsigned int tmp;

	__asm__ volatile(
    c614:	f04f 0220 	mov.w	r2, #32
    c618:	f3ef 8311 	mrs	r3, BASEPRI
    c61c:	f382 8811 	msr	BASEPRI, r2
    c620:	f3bf 8f6f 	isb	sy

	key = irq_lock();

#ifdef CONFIG_NRF_ENABLE_ICACHE
	/* Enable the instruction cache */
	NRF_NVMC->ICACHECNF = NVMC_ICACHECNF_CACHEEN_Msk;
    c624:	2101      	movs	r1, #1
    c626:	4a04      	ldr	r2, [pc, #16]	; (c638 <nordicsemi_nrf91_init+0x24>)
    c628:	f8c2 1540 	str.w	r1, [r2, #1344]	; 0x540
	__asm__ volatile(
		"cpsie i;"
		"isb"
		: : : "memory");
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	__asm__ volatile(
    c62c:	f383 8811 	msr	BASEPRI, r3
    c630:	f3bf 8f6f 	isb	sy
	NMI_INIT();

	irq_unlock(key);

	return 0;
}
    c634:	2000      	movs	r0, #0
    c636:	4770      	bx	lr
    c638:	40039000 	.word	0x40039000

0000c63c <console_out>:
		return c;
	}

#endif  /* CONFIG_UART_CONSOLE_DEBUG_SERVER_HOOKS */

	if ('\n' == c) {
    c63c:	280a      	cmp	r0, #10
{
    c63e:	b538      	push	{r3, r4, r5, lr}
    c640:	4604      	mov	r4, r0
    c642:	4d07      	ldr	r5, [pc, #28]	; (c660 <console_out+0x24>)
	if ('\n' == c) {
    c644:	d104      	bne.n	c650 <console_out+0x14>
    c646:	6828      	ldr	r0, [r5, #0]
						unsigned char out_char)
{
	const struct uart_driver_api *api =
		(const struct uart_driver_api *)dev->driver_api;

	api->poll_out(dev, out_char);
    c648:	6843      	ldr	r3, [r0, #4]
    c64a:	210d      	movs	r1, #13
    c64c:	685b      	ldr	r3, [r3, #4]
    c64e:	4798      	blx	r3
		uart_poll_out(uart_console_dev, '\r');
	}
	uart_poll_out(uart_console_dev, c);
    c650:	6828      	ldr	r0, [r5, #0]
    c652:	6843      	ldr	r3, [r0, #4]
    c654:	b2e1      	uxtb	r1, r4
    c656:	685b      	ldr	r3, [r3, #4]
    c658:	4798      	blx	r3

	return c;
}
    c65a:	4620      	mov	r0, r4
    c65c:	bd38      	pop	{r3, r4, r5, pc}
    c65e:	bf00      	nop
    c660:	20020008 	.word	0x20020008

0000c664 <uart_console_hook_install>:
 *
 * @return N/A
 */

void uart_console_hook_install(void)
{
    c664:	b510      	push	{r4, lr}
	__stdout_hook_install(console_out);
    c666:	4c04      	ldr	r4, [pc, #16]	; (c678 <uart_console_hook_install+0x14>)
    c668:	4620      	mov	r0, r4
    c66a:	f000 fd6b 	bl	d144 <__stdout_hook_install>
	__printk_hook_install(console_out);
    c66e:	4620      	mov	r0, r4
}
    c670:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	__printk_hook_install(console_out);
    c674:	f7ff bfba 	b.w	c5ec <__printk_hook_install>
    c678:	0000c63d 	.word	0x0000c63d

0000c67c <uart_console_init>:
 * @brief Initialize one UART as the console/debug port
 *
 * @return 0 if successful, otherwise failed.
 */
static int uart_console_init(struct device *arg)
{
    c67c:	b508      	push	{r3, lr}
	if (z_syscall_trap()) {
		return (struct device *) arch_syscall_invoke1(*(uintptr_t *)&name, K_SYSCALL_DEVICE_GET_BINDING);
	}
#endif
	compiler_barrier();
	return z_impl_device_get_binding(name);
    c67e:	4804      	ldr	r0, [pc, #16]	; (c690 <uart_console_init+0x14>)
    c680:	f001 f8b4 	bl	d7ec <z_impl_device_get_binding>

	ARG_UNUSED(arg);

	uart_console_dev = device_get_binding(CONFIG_UART_CONSOLE_ON_DEV_NAME);
    c684:	4b03      	ldr	r3, [pc, #12]	; (c694 <uart_console_init+0x18>)
    c686:	6018      	str	r0, [r3, #0]
		}
	}
	k_busy_wait(1000000);
#endif

	uart_console_hook_install();
    c688:	f7ff ffec 	bl	c664 <uart_console_hook_install>

	return 0;
}
    c68c:	2000      	movs	r0, #0
    c68e:	bd08      	pop	{r3, pc}
    c690:	0000ece2 	.word	0x0000ece2
    c694:	20020008 	.word	0x20020008

0000c698 <clock_async_start>:

static const struct nrf_clock_control_sub_config *get_sub_config(
					struct device *dev,
					enum clock_control_nrf_type type)
{
	const struct nrf_clock_control_config *config =
    c698:	6803      	ldr	r3, [r0, #0]
}

static int clock_async_start(struct device *dev,
			     clock_control_subsys_t subsys,
			     struct clock_control_async_data *data)
{
    c69a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	int key;
	u8_t ref;

	__ASSERT_NO_MSG(type < CLOCK_CONTROL_NRF_TYPE_COUNT);
	config = get_sub_config(dev, type);
	clk_data = get_sub_data(dev, type);
    c69e:	f8d0 c008 	ldr.w	ip, [r0, #8]
{
    c6a2:	4605      	mov	r5, r0
	const struct nrf_clock_control_config *config =
    c6a4:	689f      	ldr	r7, [r3, #8]
	return &config->subsys[type];
    c6a6:	b2ce      	uxtb	r6, r1
			((data != NULL) && (data->cb != NULL)));

	/* if node is in the list it means that it is scheduled for
	 * the second time.
	 */
	if ((data != NULL)
    c6a8:	b14a      	cbz	r2, c6be <clock_async_start+0x26>
	sys_snode_t *item = sys_slist_peek_head(list);
    c6aa:	230c      	movs	r3, #12
    c6ac:	4373      	muls	r3, r6
    c6ae:	f85c 3003 	ldr.w	r3, [ip, r3]
		if (item == node) {
    c6b2:	429a      	cmp	r2, r3
    c6b4:	d05c      	beq.n	c770 <clock_async_start+0xd8>
 *
 * @return a pointer on the next node (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_next(sys_snode_t *node);

Z_GENLIST_PEEK_NEXT(slist, snode)
    c6b6:	b113      	cbz	r3, c6be <clock_async_start+0x26>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
    c6b8:	681b      	ldr	r3, [r3, #0]
	} while (item);
    c6ba:	2b00      	cmp	r3, #0
    c6bc:	d1f9      	bne.n	c6b2 <clock_async_start+0x1a>
	__asm__ volatile(
    c6be:	f04f 0320 	mov.w	r3, #32
    c6c2:	f3ef 8011 	mrs	r0, BASEPRI
    c6c6:	f383 8811 	msr	BASEPRI, r3
    c6ca:	f3bf 8f6f 	isb	sy
	    && is_in_list(&clk_data->list, &data->node)) {
		return -EBUSY;
	}

	key = irq_lock();
	ref = ++clk_data->ref;
    c6ce:	210c      	movs	r1, #12
    c6d0:	4371      	muls	r1, r6
    c6d2:	eb0c 0301 	add.w	r3, ip, r1
    c6d6:	7a1c      	ldrb	r4, [r3, #8]
    c6d8:	3401      	adds	r4, #1
    c6da:	b2e4      	uxtb	r4, r4
    c6dc:	721c      	strb	r4, [r3, #8]
	__asm__ volatile(
    c6de:	f380 8811 	msr	BASEPRI, r0
    c6e2:	f3bf 8f6f 	isb	sy
	__ASSERT_NO_MSG(clk_data->ref > 0);
	irq_unlock(key);

	if (data) {
    c6e6:	b322      	cbz	r2, c732 <clock_async_start+0x9a>
    p_reg->INTENSET = mask;
}

NRF_STATIC_INLINE void nrf_clock_int_disable(NRF_CLOCK_Type * p_reg, uint32_t mask)
{
    p_reg->INTENCLR = mask;
    c6e8:	f04f 0e03 	mov.w	lr, #3
    c6ec:	4822      	ldr	r0, [pc, #136]	; (c778 <clock_async_start+0xe0>)
    c6ee:	f8c0 e308 	str.w	lr, [r0, #776]	; 0x308
		bool already_started;

		clock_irqs_disable();
		already_started = clk_data->started;
    c6f2:	7a58      	ldrb	r0, [r3, #9]
		if (!already_started) {
    c6f4:	b9a0      	cbnz	r0, c720 <clock_async_start+0x88>
	__asm__ volatile(
    c6f6:	f04f 0e20 	mov.w	lr, #32
    c6fa:	f3ef 8811 	mrs	r8, BASEPRI
    c6fe:	f38e 8811 	msr	BASEPRI, lr
    c702:	f3bf 8f6f 	isb	sy
	parent->next = child;
    c706:	6010      	str	r0, [r2, #0]
 * @param node A pointer on the node to append
 */
static inline void sys_slist_append(sys_slist_t *list,
				    sys_snode_t *node);

Z_GENLIST_APPEND(slist, snode)
    c708:	f8d3 e004 	ldr.w	lr, [r3, #4]
    c70c:	f1be 0f00 	cmp.w	lr, #0
    c710:	d121      	bne.n	c756 <clock_async_start+0xbe>
	list->tail = node;
    c712:	605a      	str	r2, [r3, #4]
	list->head = node;
    c714:	f84c 2001 	str.w	r2, [ip, r1]
	__asm__ volatile(
    c718:	f388 8811 	msr	BASEPRI, r8
    c71c:	f3bf 8f6f 	isb	sy
    p_reg->INTENSET = mask;
    c720:	2103      	movs	r1, #3
    c722:	4b15      	ldr	r3, [pc, #84]	; (c778 <clock_async_start+0xe0>)
    c724:	f8c3 1304 	str.w	r1, [r3, #772]	; 0x304
			list_append(&clk_data->list, &data->node);
		}
		clock_irqs_enable();

		if (already_started) {
    c728:	b118      	cbz	r0, c732 <clock_async_start+0x9a>
			data->cb(dev, data->user_data);
    c72a:	e9d2 3101 	ldrd	r3, r1, [r2, #4]
    c72e:	4628      	mov	r0, r5
    c730:	4798      	blx	r3
		}
	}

	if (ref == 1) {
    c732:	2c01      	cmp	r4, #1
    c734:	d10d      	bne.n	c752 <clock_async_start+0xba>
		bool do_start;

		do_start =  (config->start_handler) ?
    c736:	230c      	movs	r3, #12
    c738:	4373      	muls	r3, r6
    c73a:	58fb      	ldr	r3, [r7, r3]
				config->start_handler(dev) : true;
    c73c:	b97b      	cbnz	r3, c75e <clock_async_start+0xc6>
			if (IS_ENABLED(CONFIG_NRF52_ANOMALY_132_WORKAROUND) &&
			    (subsys == CLOCK_CONTROL_NRF_SUBSYS_LF)) {
				anomaly_132_workaround();
			}

			nrf_clock_task_trigger(NRF_CLOCK,
    c73e:	230c      	movs	r3, #12
    return (uint32_t)((uint8_t *)p_reg + (uint32_t)task);
}

NRF_STATIC_INLINE void nrf_clock_task_trigger(NRF_CLOCK_Type * p_reg, nrf_clock_task_t task)
{
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    c740:	2201      	movs	r2, #1
    c742:	fb03 7606 	mla	r6, r3, r6, r7
    c746:	7ab3      	ldrb	r3, [r6, #10]
    c748:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
    c74c:	f503 43a0 	add.w	r3, r3, #20480	; 0x5000
    c750:	601a      	str	r2, [r3, #0]
			 */
			clkstarted_handle(dev, type);
		}
	}

	return 0;
    c752:	2000      	movs	r0, #0
    c754:	e00e      	b.n	c774 <clock_async_start+0xdc>
	parent->next = child;
    c756:	f8ce 2000 	str.w	r2, [lr]
	list->tail = node;
    c75a:	605a      	str	r2, [r3, #4]
    c75c:	e7dc      	b.n	c718 <clock_async_start+0x80>
				config->start_handler(dev) : true;
    c75e:	4628      	mov	r0, r5
    c760:	4798      	blx	r3
    c762:	2800      	cmp	r0, #0
    c764:	d1eb      	bne.n	c73e <clock_async_start+0xa6>
			clkstarted_handle(dev, type);
    c766:	4631      	mov	r1, r6
    c768:	4628      	mov	r0, r5
    c76a:	f001 fe9e 	bl	e4aa <clkstarted_handle>
    c76e:	e7f0      	b.n	c752 <clock_async_start+0xba>
		return -EBUSY;
    c770:	f06f 000f 	mvn.w	r0, #15
}
    c774:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    c778:	40005000 	.word	0x40005000

0000c77c <clk_init>:
 * symbol.
 */
void nrf_power_clock_isr(void *arg);

static int clk_init(struct device *dev)
{
    c77c:	b510      	push	{r4, lr}
	IRQ_CONNECT(DT_INST_0_NORDIC_NRF_CLOCK_IRQ_0,
    c77e:	2200      	movs	r2, #0
{
    c780:	4604      	mov	r4, r0
	IRQ_CONNECT(DT_INST_0_NORDIC_NRF_CLOCK_IRQ_0,
    c782:	2101      	movs	r1, #1
    c784:	2005      	movs	r0, #5
    c786:	f000 f9b1 	bl	caec <z_arm_irq_priority_set>
		    DT_INST_0_NORDIC_NRF_CLOCK_IRQ_0_PRIORITY,
		    nrf_power_clock_isr, 0, 0);

	irq_enable(DT_INST_0_NORDIC_NRF_CLOCK_IRQ_0);
    c78a:	2005      	movs	r0, #5
    c78c:	f000 f99e 	bl	cacc <arch_irq_enable>
    return false;
}

NRF_STATIC_INLINE void nrf_clock_lf_src_set(NRF_CLOCK_Type * p_reg, nrf_clock_lfclk_t source)
{
    p_reg->LFCLKSRC = (uint32_t)(source);
    c790:	2202      	movs	r2, #2
    c792:	4b07      	ldr	r3, [pc, #28]	; (c7b0 <clk_init+0x34>)
	list->head = NULL;
    c794:	2000      	movs	r0, #0
    c796:	f8c3 2518 	str.w	r2, [r3, #1304]	; 0x518
    p_reg->INTENSET = mask;
    c79a:	2203      	movs	r2, #3
    c79c:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304

	clock_irqs_enable();

	for (enum clock_control_nrf_type i = 0;
		i < CLOCK_CONTROL_NRF_TYPE_COUNT; i++) {
		sys_slist_init(&(get_sub_data(dev, i)->list));
    c7a0:	68a3      	ldr	r3, [r4, #8]
	list->tail = NULL;
    c7a2:	e9c3 0000 	strd	r0, r0, [r3]
    c7a6:	68a3      	ldr	r3, [r4, #8]
    c7a8:	e9c3 0003 	strd	r0, r0, [r3, #12]
	}

	return 0;
}
    c7ac:	bd10      	pop	{r4, pc}
    c7ae:	bf00      	nop
    c7b0:	40005000 	.word	0x40005000

0000c7b4 <nrf_power_clock_isr>:
	}
#endif
}

void nrf_power_clock_isr(void *arg)
{
    c7b4:	b508      	push	{r3, lr}
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
    c7b6:	4b10      	ldr	r3, [pc, #64]	; (c7f8 <nrf_power_clock_isr+0x44>)
    c7b8:	681a      	ldr	r2, [r3, #0]
	bool ret = nrf_clock_event_check(NRF_CLOCK, evt) &&
    c7ba:	b162      	cbz	r2, c7d6 <nrf_power_clock_isr+0x22>
    return p_reg->INTENSET & mask;
    c7bc:	4a0f      	ldr	r2, [pc, #60]	; (c7fc <nrf_power_clock_isr+0x48>)
    c7be:	f8d2 2304 	ldr.w	r2, [r2, #772]	; 0x304
	if (ret) {
    c7c2:	07d1      	lsls	r1, r2, #31
    c7c4:	d507      	bpl.n	c7d6 <nrf_power_clock_isr+0x22>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    c7c6:	2200      	movs	r2, #0
	struct device *dev = DEVICE_GET(clock_nrf);

	if (clock_event_check_and_clean(NRF_CLOCK_EVENT_HFCLKSTARTED,
					NRF_CLOCK_INT_HF_STARTED_MASK)) {
		struct nrf_clock_control_sub_data *data =
				get_sub_data(dev, CLOCK_CONTROL_NRF_TYPE_HFCLK);
    c7c8:	480d      	ldr	r0, [pc, #52]	; (c800 <nrf_power_clock_isr+0x4c>)
    c7ca:	601a      	str	r2, [r3, #0]

		/* Check needed due to anomaly 201:
		 * HFCLKSTARTED may be generated twice.
		 */
		if (!data->started) {
    c7cc:	6883      	ldr	r3, [r0, #8]
    c7ce:	7a59      	ldrb	r1, [r3, #9]
    c7d0:	b909      	cbnz	r1, c7d6 <nrf_power_clock_isr+0x22>
			clkstarted_handle(dev, CLOCK_CONTROL_NRF_TYPE_HFCLK);
    c7d2:	f001 fe6a 	bl	e4aa <clkstarted_handle>
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
    c7d6:	4b0b      	ldr	r3, [pc, #44]	; (c804 <nrf_power_clock_isr+0x50>)
    c7d8:	681a      	ldr	r2, [r3, #0]
	bool ret = nrf_clock_event_check(NRF_CLOCK, evt) &&
    c7da:	b162      	cbz	r2, c7f6 <nrf_power_clock_isr+0x42>
    return p_reg->INTENSET & mask;
    c7dc:	4a07      	ldr	r2, [pc, #28]	; (c7fc <nrf_power_clock_isr+0x48>)
    c7de:	f8d2 2304 	ldr.w	r2, [r2, #772]	; 0x304
	if (ret) {
    c7e2:	0792      	lsls	r2, r2, #30
    c7e4:	d507      	bpl.n	c7f6 <nrf_power_clock_isr+0x42>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    c7e6:	2200      	movs	r2, #0
					NRF_CLOCK_INT_LF_STARTED_MASK)) {
		if (IS_ENABLED(
			CONFIG_CLOCK_CONTROL_NRF_K32SRC_RC_CALIBRATION)) {
			z_nrf_clock_calibration_lfclk_started(dev);
		}
		clkstarted_handle(dev, CLOCK_CONTROL_NRF_TYPE_LFCLK);
    c7e8:	2101      	movs	r1, #1
    c7ea:	601a      	str	r2, [r3, #0]
    c7ec:	4804      	ldr	r0, [pc, #16]	; (c800 <nrf_power_clock_isr+0x4c>)
	usb_power_isr();

	if (IS_ENABLED(CONFIG_CLOCK_CONTROL_NRF_K32SRC_RC_CALIBRATION)) {
		z_nrf_clock_calibration_isr();
	}
}
    c7ee:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		clkstarted_handle(dev, CLOCK_CONTROL_NRF_TYPE_LFCLK);
    c7f2:	f001 be5a 	b.w	e4aa <clkstarted_handle>
}
    c7f6:	bd08      	pop	{r3, pc}
    c7f8:	40005100 	.word	0x40005100
    c7fc:	40005000 	.word	0x40005000
    c800:	20020efc 	.word	0x20020efc
    c804:	40005104 	.word	0x40005104

0000c808 <rtc1_nrf_isr>:
 * symbol.
 */
void rtc1_nrf_isr(void *arg)
{
	ARG_UNUSED(arg);
	RTC->EVENTS_COMPARE[0] = 0;
    c808:	2200      	movs	r2, #0
    c80a:	4b0d      	ldr	r3, [pc, #52]	; (c840 <rtc1_nrf_isr+0x38>)
    c80c:	f8c3 2140 	str.w	r2, [r3, #320]	; 0x140
	__asm__ volatile(
    c810:	f04f 0220 	mov.w	r2, #32
    c814:	f3ef 8111 	mrs	r1, BASEPRI
    c818:	f382 8811 	msr	BASEPRI, r2
    c81c:	f3bf 8f6f 	isb	sy

	k_spinlock_key_t key = k_spin_lock(&lock);
	u32_t t = counter();
	u32_t dticks = counter_sub(t, last_count) / CYC_PER_TICK;
    c820:	4a08      	ldr	r2, [pc, #32]	; (c844 <rtc1_nrf_isr+0x3c>)
#endif
}

NRF_STATIC_INLINE uint32_t nrf_rtc_counter_get(NRF_RTC_Type const * p_reg)
{
     return p_reg->COUNTER;
    c822:	f8d3 0504 	ldr.w	r0, [r3, #1284]	; 0x504
    c826:	6813      	ldr	r3, [r2, #0]
	return (a - b) & COUNTER_MAX;
    c828:	1ac0      	subs	r0, r0, r3
    c82a:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000

	last_count += dticks * CYC_PER_TICK;
    c82e:	4403      	add	r3, r0
    c830:	6013      	str	r3, [r2, #0]
	__asm__ volatile(
    c832:	f381 8811 	msr	BASEPRI, r1
    c836:	f3bf 8f6f 	isb	sy
		}
		set_comparator(next);
	}

	k_spin_unlock(&lock, key);
	z_clock_announce(IS_ENABLED(CONFIG_TICKLESS_KERNEL) ? dticks : 1);
    c83a:	f001 bb9f 	b.w	df7c <z_clock_announce>
    c83e:	bf00      	nop
    c840:	40015000 	.word	0x40015000
    c844:	20020024 	.word	0x20020024

0000c848 <z_clock_driver_init>:
}

int z_clock_driver_init(struct device *device)
{
    c848:	b570      	push	{r4, r5, r6, lr}
    c84a:	4815      	ldr	r0, [pc, #84]	; (c8a0 <z_clock_driver_init+0x58>)
    c84c:	f000 ffce 	bl	d7ec <z_impl_device_get_binding>
	struct device *clock;

	ARG_UNUSED(device);

	clock = device_get_binding(DT_INST_0_NORDIC_NRF_CLOCK_LABEL);
	if (!clock) {
    c850:	b310      	cbz	r0, c898 <z_clock_driver_init+0x50>
				   clock_control_subsys_t sys)
{
	const struct clock_control_driver_api *api =
		(const struct clock_control_driver_api *)dev->driver_api;

	return api->on(dev, sys);
    c852:	6843      	ldr	r3, [r0, #4]
    c854:	2101      	movs	r1, #1
    c856:	681b      	ldr	r3, [r3, #0]
    c858:	4798      	blx	r3
}

NRF_STATIC_INLINE void nrf_rtc_prescaler_set(NRF_RTC_Type * p_reg, uint32_t val)
{
    NRFX_ASSERT(val <= (RTC_PRESCALER_PRESCALER_Msk >> RTC_PRESCALER_PRESCALER_Pos));
    p_reg->PRESCALER = val;
    c85a:	2400      	movs	r4, #0
    p_reg->CC[ch] = cc_val;
    c85c:	2601      	movs	r6, #1
    p_reg->INTENSET = mask;
    c85e:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 */
__STATIC_INLINE void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    c862:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
    p_reg->PRESCALER = val;
    c866:	4d0f      	ldr	r5, [pc, #60]	; (c8a4 <z_clock_driver_init+0x5c>)

	/* Clear the event flag and possible pending interrupt */
	nrf_rtc_event_clear(RTC, NRF_RTC_EVENT_COMPARE_0);
	NVIC_ClearPendingIRQ(RTC1_IRQn);

	IRQ_CONNECT(RTC1_IRQn, 1, rtc1_nrf_isr, 0, 0);
    c868:	4631      	mov	r1, r6
    c86a:	f8c5 4508 	str.w	r4, [r5, #1288]	; 0x508
    p_reg->CC[ch] = cc_val;
    c86e:	f8c5 6540 	str.w	r6, [r5, #1344]	; 0x540
    p_reg->INTENSET = mask;
    c872:	f8c5 3304 	str.w	r3, [r5, #772]	; 0x304
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
    c876:	4b0c      	ldr	r3, [pc, #48]	; (c8a8 <z_clock_driver_init+0x60>)
    c878:	2015      	movs	r0, #21
    c87a:	601c      	str	r4, [r3, #0]
    c87c:	4b0b      	ldr	r3, [pc, #44]	; (c8ac <z_clock_driver_init+0x64>)
    c87e:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
    c882:	4622      	mov	r2, r4
    c884:	f000 f932 	bl	caec <z_arm_irq_priority_set>
	irq_enable(RTC1_IRQn);
    c888:	2015      	movs	r0, #21
    c88a:	f000 f91f 	bl	cacc <arch_irq_enable>

	if (!IS_ENABLED(CONFIG_TICKLESS_KERNEL)) {
		set_comparator(counter() + CYC_PER_TICK);
	}

	return 0;
    c88e:	4620      	mov	r0, r4
    return (uint32_t)p_reg + task;
}

NRF_STATIC_INLINE void nrf_rtc_task_trigger(NRF_RTC_Type * p_reg, nrf_rtc_task_t task)
{
    *(__IO uint32_t *)((uint32_t)p_reg + task) = 1;
    c890:	4b07      	ldr	r3, [pc, #28]	; (c8b0 <z_clock_driver_init+0x68>)
    c892:	601e      	str	r6, [r3, #0]
    c894:	602e      	str	r6, [r5, #0]
}
    c896:	bd70      	pop	{r4, r5, r6, pc}
		return -1;
    c898:	f04f 30ff 	mov.w	r0, #4294967295
    c89c:	e7fb      	b.n	c896 <z_clock_driver_init+0x4e>
    c89e:	bf00      	nop
    c8a0:	0000ece9 	.word	0x0000ece9
    c8a4:	40015000 	.word	0x40015000
    c8a8:	40015140 	.word	0x40015140
    c8ac:	e000e100 	.word	0xe000e100
    c8b0:	40015008 	.word	0x40015008

0000c8b4 <z_clock_set_timeout>:

void z_clock_set_timeout(s32_t ticks, bool idle)
{
    c8b4:	b570      	push	{r4, r5, r6, lr}
	ARG_UNUSED(idle);

#ifdef CONFIG_TICKLESS_KERNEL
	ticks = (ticks == K_FOREVER) ? MAX_TICKS : ticks;
    c8b6:	4c25      	ldr	r4, [pc, #148]	; (c94c <z_clock_set_timeout+0x98>)
    c8b8:	f1b0 3fff 	cmp.w	r0, #4294967295
    c8bc:	bf08      	it	eq
    c8be:	4620      	moveq	r0, r4
	__asm__ volatile(
    c8c0:	f04f 0320 	mov.w	r3, #32
    c8c4:	f3ef 8511 	mrs	r5, BASEPRI
    c8c8:	f383 8811 	msr	BASEPRI, r3
    c8cc:	f3bf 8f6f 	isb	sy
     return p_reg->COUNTER;
    c8d0:	4b1f      	ldr	r3, [pc, #124]	; (c950 <z_clock_set_timeout+0x9c>)
    c8d2:	f8d3 1504 	ldr.w	r1, [r3, #1284]	; 0x504
	ticks = MAX(MIN(ticks - 1, (s32_t)MAX_TICKS), 0);

	k_spinlock_key_t key = k_spin_lock(&lock);
	u32_t cyc, dt, t = counter();
	u32_t unannounced = counter_sub(t, last_count);
    c8d6:	4b1f      	ldr	r3, [pc, #124]	; (c954 <z_clock_set_timeout+0xa0>)
    c8d8:	681b      	ldr	r3, [r3, #0]
	return (a - b) & COUNTER_MAX;
    c8da:	1aca      	subs	r2, r1, r3
    c8dc:	f022 467f 	bic.w	r6, r2, #4278190080	; 0xff000000
	/* If we haven't announced for more than half the 24-bit wrap
	 * duration, then force an announce to avoid loss of a wrap
	 * event.  This can happen if new timeouts keep being set
	 * before the existing one triggers the interrupt.
	 */
	if (unannounced >= COUNTER_HALF_SPAN) {
    c8e0:	0212      	lsls	r2, r2, #8
    c8e2:	d41a      	bmi.n	c91a <z_clock_set_timeout+0x66>
	ticks = MAX(MIN(ticks - 1, (s32_t)MAX_TICKS), 0);
    c8e4:	1e42      	subs	r2, r0, #1
    c8e6:	ea22 72e2 	bic.w	r2, r2, r2, asr #31
    c8ea:	42a2      	cmp	r2, r4
    c8ec:	bfa8      	it	ge
    c8ee:	4622      	movge	r2, r4
	}

	/* Get the cycles from last_count to the tick boundary after
	 * the requested ticks have passed starting now.
	 */
	cyc = ticks * CYC_PER_TICK + 1 + unannounced;
    c8f0:	1c70      	adds	r0, r6, #1
    c8f2:	4410      	add	r0, r2
	 */
	if (cyc > MAX_CYCLES) {
		cyc = MAX_CYCLES;
	}

	cyc += last_count;
    c8f4:	42a0      	cmp	r0, r4
    c8f6:	bf94      	ite	ls
    c8f8:	1818      	addls	r0, r3, r0
    c8fa:	1918      	addhi	r0, r3, r4
	return (a - b) & COUNTER_MAX;
    c8fc:	1a41      	subs	r1, r0, r1
    c8fe:	f021 417f 	bic.w	r1, r1, #4278190080	; 0xff000000
    c902:	4a13      	ldr	r2, [pc, #76]	; (c950 <z_clock_set_timeout+0x9c>)
    c904:	f020 437f 	bic.w	r3, r0, #4278190080	; 0xff000000
	 * least on nRF52.  Some experimentation on nrf52840 shows
	 * that you need to be early by about 400 processor cycles
	 * (about 1/5th of a RTC cycle) in order to reliably get the
	 * interrupt.  The docs say two cycles, they mean two cycles.
	 */
	if (counter_sub(cyc, t) > 2) {
    c908:	2902      	cmp	r1, #2
    p_reg->CC[ch] = cc_val;
    c90a:	f8c2 3540 	str.w	r3, [r2, #1344]	; 0x540
    c90e:	d906      	bls.n	c91e <z_clock_set_timeout+0x6a>
	__asm__ volatile(
    c910:	f385 8811 	msr	BASEPRI, r5
    c914:	f3bf 8f6f 	isb	sy
	}
#endif

	k_spin_unlock(&lock, key);
#endif /* CONFIG_TICKLESS_KERNEL */
}
    c918:	bd70      	pop	{r4, r5, r6, pc}
		ticks = 0;
    c91a:	2200      	movs	r2, #0
    c91c:	e7e8      	b.n	c8f0 <z_clock_set_timeout+0x3c>
     return p_reg->COUNTER;
    c91e:	f8d2 3504 	ldr.w	r3, [r2, #1284]	; 0x504
		if (dt == 0 || dt > 0x7fffff) {
    c922:	490d      	ldr	r1, [pc, #52]	; (c958 <z_clock_set_timeout+0xa4>)
	return (a - b) & COUNTER_MAX;
    c924:	1ac3      	subs	r3, r0, r3
    c926:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
		if (dt == 0 || dt > 0x7fffff) {
    c92a:	1e5c      	subs	r4, r3, #1
    c92c:	428c      	cmp	r4, r1
    c92e:	d905      	bls.n	c93c <z_clock_set_timeout+0x88>
    NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    c930:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
    c934:	4b09      	ldr	r3, [pc, #36]	; (c95c <z_clock_set_timeout+0xa8>)
    c936:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
    c93a:	e7e9      	b.n	c910 <z_clock_set_timeout+0x5c>
		} else if (dt == 1) {
    c93c:	2b01      	cmp	r3, #1
			set_comparator(cyc + 2);
    c93e:	bf02      	ittt	eq
    c940:	3002      	addeq	r0, #2
	nrf_rtc_cc_set(RTC, 0, cyc & COUNTER_MAX);
    c942:	f020 407f 	biceq.w	r0, r0, #4278190080	; 0xff000000
    p_reg->CC[ch] = cc_val;
    c946:	f8c2 0540 	streq.w	r0, [r2, #1344]	; 0x540
    c94a:	e7e1      	b.n	c910 <z_clock_set_timeout+0x5c>
    c94c:	00fffffe 	.word	0x00fffffe
    c950:	40015000 	.word	0x40015000
    c954:	20020024 	.word	0x20020024
    c958:	007ffffe 	.word	0x007ffffe
    c95c:	e000e100 	.word	0xe000e100

0000c960 <z_clock_elapsed>:
	__asm__ volatile(
    c960:	f04f 0220 	mov.w	r2, #32
    c964:	f3ef 8311 	mrs	r3, BASEPRI
    c968:	f382 8811 	msr	BASEPRI, r2
    c96c:	f3bf 8f6f 	isb	sy
     return p_reg->COUNTER;
    c970:	4a06      	ldr	r2, [pc, #24]	; (c98c <z_clock_elapsed+0x2c>)
    c972:	f8d2 0504 	ldr.w	r0, [r2, #1284]	; 0x504
	if (!IS_ENABLED(CONFIG_TICKLESS_KERNEL)) {
		return 0;
	}

	k_spinlock_key_t key = k_spin_lock(&lock);
	u32_t ret = counter_sub(counter(), last_count) / CYC_PER_TICK;
    c976:	4a06      	ldr	r2, [pc, #24]	; (c990 <z_clock_elapsed+0x30>)
	return (a - b) & COUNTER_MAX;
    c978:	6812      	ldr	r2, [r2, #0]
    c97a:	1a80      	subs	r0, r0, r2
    c97c:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
	__asm__ volatile(
    c980:	f383 8811 	msr	BASEPRI, r3
    c984:	f3bf 8f6f 	isb	sy

	k_spin_unlock(&lock, key);
	return ret;
}
    c988:	4770      	bx	lr
    c98a:	bf00      	nop
    c98c:	40015000 	.word	0x40015000
    c990:	20020024 	.word	0x20020024

0000c994 <z_arm_exc_exit>:
    /* r0 contains the caller mode */
    push {r0, lr}
#endif

#ifdef CONFIG_PREEMPT_ENABLED
    ldr r0, =_kernel
    c994:	4804      	ldr	r0, [pc, #16]	; (c9a8 <_EXIT_EXC+0x2>)

    ldr r1, [r0, #_kernel_offset_to_current]
    c996:	6881      	ldr	r1, [r0, #8]

    ldr r0, [r0, #_kernel_offset_to_ready_q_cache]
    c998:	6a40      	ldr	r0, [r0, #36]	; 0x24
    cmp r0, r1
    c99a:	4288      	cmp	r0, r1
    beq _EXIT_EXC
    c99c:	d003      	beq.n	c9a6 <_EXIT_EXC>

#if defined(CONFIG_CPU_CORTEX_M)
    /* context switch required, pend the PendSV exception */
    ldr r1, =_SCS_ICSR
    c99e:	4903      	ldr	r1, [pc, #12]	; (c9ac <_EXIT_EXC+0x6>)
    ldr r2, =_SCS_ICSR_PENDSV
    c9a0:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    str r2, [r1]
    c9a4:	600a      	str	r2, [r1, #0]

0000c9a6 <_EXIT_EXC>:
    bl z_check_stack_sentinel
#endif /* CONFIG_CPU_CORTEX_M */
#endif /* CONFIG_STACK_SENTINEL */

#if defined(CONFIG_CPU_CORTEX_M)
    bx lr
    c9a6:	4770      	bx	lr
    ldr r0, =_kernel
    c9a8:	20020134 	.word	0x20020134
    ldr r1, =_SCS_ICSR
    c9ac:	e000ed04 	.word	0xe000ed04

0000c9b0 <z_arm_pendsv>:
    pop {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
#endif /* CONFIG_TRACING */

    /* load _kernel into r1 and current k_thread into r2 */
    ldr r1, =_kernel
    c9b0:	4912      	ldr	r1, [pc, #72]	; (c9fc <z_arm_pendsv+0x4c>)
    ldr r2, [r1, #_kernel_offset_to_current]
    c9b2:	688a      	ldr	r2, [r1, #8]

    /* addr of callee-saved regs in thread in r0 */
    ldr r0, =_thread_offset_to_callee_saved
    c9b4:	f04f 0028 	mov.w	r0, #40	; 0x28
    add r0, r2
    c9b8:	4410      	add	r0, r2

    /* save callee-saved + psp in thread */
#if defined(CONFIG_CPU_CORTEX_M)
    mrs ip, PSP
    c9ba:	f3ef 8c09 	mrs	ip, PSP
    mov r6, r11
    mov r7, ip
    /* store r8-12 */
    stmea r0!, {r3-r7}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    stmia r0, {v1-v8, ip}
    c9be:	e880 1ff0 	stmia.w	r0, {r4, r5, r6, r7, r8, r9, sl, fp, ip}

    /* Protect the kernel state while we play with the thread lists */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    cpsid i
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    movs.n r0, #_EXC_IRQ_DEFAULT_PRIO
    c9c2:	2020      	movs	r0, #32
    msr BASEPRI, r0
    c9c4:	f380 8811 	msr	BASEPRI, r0
    isb /* Make the effect of disabling interrupts be realized immediately */
    c9c8:	f3bf 8f6f 	isb	sy
     * the new thread is context-switched in since all decisions
     * to pend PendSV have been taken with the current kernel
     * state and this is what we're handling currently.
     */
#if defined(CONFIG_CPU_CORTEX_M)
    ldr v4, =_SCS_ICSR
    c9cc:	4f0c      	ldr	r7, [pc, #48]	; (ca00 <z_arm_pendsv+0x50>)
    ldr v3, =_SCS_ICSR_UNPENDSV
    c9ce:	f04f 6600 	mov.w	r6, #134217728	; 0x8000000
#endif

    /* _kernel is still in r1 */

    /* fetch the thread to run from the ready queue cache */
    ldr r2, [r1, #_kernel_offset_to_ready_q_cache]
    c9d2:	6a4a      	ldr	r2, [r1, #36]	; 0x24

    str r2, [r1, #_kernel_offset_to_current]
    c9d4:	608a      	str	r2, [r1, #8]
     * has been handled.
     */

    /* _SCS_ICSR is still in v4 and _SCS_ICSR_UNPENDSV in v3 */
#if defined(CONFIG_CPU_CORTEX_M)
    str v3, [v4, #0]
    c9d6:	603e      	str	r6, [r7, #0]

    ldr r0, [r4]
    movs.n r3, #0
    str r3, [r4]
#else
    ldr r0, [r2, #_thread_offset_to_basepri]
    c9d8:	6e50      	ldr	r0, [r2, #100]	; 0x64
    movs r3, #0
    c9da:	2300      	movs	r3, #0
    str r3, [r2, #_thread_offset_to_basepri]
    c9dc:	6653      	str	r3, [r2, #100]	; 0x64
    /* restore r4-r7, go back 9*4 bytes to the start of the stored block */
    subs r0, #36
    ldmia r0!, {r4-r7}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    /* restore BASEPRI for the incoming thread */
    msr BASEPRI, r0
    c9de:	f380 8811 	msr	BASEPRI, r0
    isb
#endif

#if defined (CONFIG_ARM_MPU)
    /* Re-program dynamic memory map */
    push {r2,lr}
    c9e2:	b504      	push	{r2, lr}
    mov r0, r2 /* _current thread */
    c9e4:	4610      	mov	r0, r2
    bl z_arm_configure_dynamic_mpu_regions
    c9e6:	f001 fd97 	bl	e518 <z_arm_configure_dynamic_mpu_regions>
    pop {r2,lr}
    c9ea:	e8bd 4004 	ldmia.w	sp!, {r2, lr}
    isb

#endif

    /* load callee-saved + psp from thread */
    add r0, r2, #_thread_offset_to_callee_saved
    c9ee:	f102 0028 	add.w	r0, r2, #40	; 0x28
    ldmia r0, {v1-v8, ip}
    c9f2:	e890 1ff0 	ldmia.w	r0, {r4, r5, r6, r7, r8, r9, sl, fp, ip}
    mov r0, #0
    msr PSPLIM, r0
#endif /* CONFIG_BUILTIN_STACK_GUARD */

#if defined(CONFIG_CPU_CORTEX_M)
    msr PSP, ip
    c9f6:	f38c 8809 	msr	PSP, ip

    /*
     * Cortex-M: return from PendSV exception
     * Cortex-R: return to the caller (_IntExit or z_arm_svc)
     */
    bx lr
    c9fa:	4770      	bx	lr
    ldr r1, =_kernel
    c9fc:	20020134 	.word	0x20020134
    ldr v4, =_SCS_ICSR
    ca00:	e000ed04 	.word	0xe000ed04

0000ca04 <z_arm_svc>:
  bne _stack_frame_endif
_stack_frame_msp:
  mrs r0, MSP
_stack_frame_endif:
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    tst lr, #0x4    /* did we come from thread mode ? */
    ca04:	f01e 0f04 	tst.w	lr, #4
    ite eq  /* if zero (equal), came from handler mode */
    ca08:	bf0c      	ite	eq
        mrseq r0, MSP   /* handler mode, stack frame is on MSP */
    ca0a:	f3ef 8008 	mrseq	r0, MSP
        mrsne r0, PSP   /* thread mode, stack frame is on PSP */
    ca0e:	f3ef 8009 	mrsne	r0, PSP
#endif


    /* Figure out what SVC call number was invoked */

    ldr r1, [r0, #24]   /* grab address of PC from stack frame */
    ca12:	6981      	ldr	r1, [r0, #24]
     */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    subs r1, r1, #2
    ldrb r1, [r1]
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    ldrb r1, [r1, #-2]
    ca14:	f811 1c02 	ldrb.w	r1, [r1, #-2]
#endif
    bne _oops

#endif /* CONFIG_USERSPACE */

    cmp r1, #2
    ca18:	2902      	cmp	r1, #2
    beq _oops
    ca1a:	d0ff      	beq.n	ca1c <_oops>

0000ca1c <_oops>:
    /* exception return is done in z_arm_int_exit() */
    b z_arm_int_exit
#endif

_oops:
    push {r0, lr}
    ca1c:	b501      	push	{r0, lr}
    bl z_do_kernel_oops
    ca1e:	f001 fd70 	bl	e502 <z_do_kernel_oops>
    /* return from SVC exception is done here */
    pop {r0, pc}
    ca22:	bd01      	pop	{r0, pc}

0000ca24 <z_arm_cpu_idle_init>:
 * void z_arm_cpu_idle_init(void);
 */

SECTION_FUNC(TEXT, z_arm_cpu_idle_init)
#if defined(CONFIG_CPU_CORTEX_M)
	ldr r1, =_SCB_SCR
    ca24:	4901      	ldr	r1, [pc, #4]	; (ca2c <z_arm_cpu_idle_init+0x8>)
	movs.n r2, #_SCR_INIT_BITS
    ca26:	2210      	movs	r2, #16
	str r2, [r1]
    ca28:	600a      	str	r2, [r1, #0]
#endif
	bx lr
    ca2a:	4770      	bx	lr
	ldr r1, =_SCB_SCR
    ca2c:	e000ed10 	.word	0xe000ed10

0000ca30 <arch_cpu_idle>:
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE) \
	|| defined(CONFIG_ARMV7_R)
	cpsie i
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* clear BASEPRI so wfi is awakened by incoming interrupts */
	eors.n r0, r0
    ca30:	4040      	eors	r0, r0
	msr BASEPRI, r0
    ca32:	f380 8811 	msr	BASEPRI, r0
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

	wfi
    ca36:	bf30      	wfi

	bx lr
    ca38:	4770      	bx	lr
    ca3a:	bf00      	nop

0000ca3c <z_arm_bus_fault>:
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
SECTION_SUBSEC_FUNC(TEXT,__fault,z_arm_reserved)

#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE) || \
	defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	mrs r0, MSP
    ca3c:	f3ef 8008 	mrs	r0, MSP
	mrs r1, PSP
    ca40:	f3ef 8109 	mrs	r1, PSP
	mov r2, lr /* EXC_RETURN */
    ca44:	4672      	mov	r2, lr

	push {r0, lr}
    ca46:	b501      	push	{r0, lr}
	mov r0, #0
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE || CONFIG_ARMv7_M_ARMV8_M_MAINLINE */

	bl z_arm_fault
    ca48:	f000 f922 	bl	cc90 <z_arm_fault>

#if defined(CONFIG_CPU_CORTEX_M)
	pop {r0, pc}
    ca4c:	bd01      	pop	{r0, pc}
    ca4e:	bf00      	nop

0000ca50 <z_SysNmiOnReset>:
_ASM_FILE_PROLOGUE

GTEXT(z_SysNmiOnReset)

SECTION_FUNC(TEXT, z_SysNmiOnReset)
    wfi
    ca50:	bf30      	wfi
    b z_SysNmiOnReset
    ca52:	f7ff bffd 	b.w	ca50 <z_SysNmiOnReset>
    ca56:	bf00      	nop

0000ca58 <_isr_wrapper>:
 * @return N/A
 */
SECTION_FUNC(TEXT, _isr_wrapper)

#if defined(CONFIG_CPU_CORTEX_M)
	push {r0,lr}		/* r0, lr are now the first items on the stack */
    ca58:	b501      	push	{r0, lr}
      * FIXME: Remove the Cortex-M conditional compilation checks for `cpsid i`
      *        and `cpsie i` after the Cortex-R port is updated to support
      *        interrupt nesting.  For more details, refer to the issue #21758.
      */
#if defined(CONFIG_CPU_CORTEX_M)
	cpsid i  /* PRIMASK = 1 */
    ca5a:	b672      	cpsid	i
#endif

	/* is this a wakeup from idle ? */
	ldr r2, =_kernel
    ca5c:	4a0b      	ldr	r2, [pc, #44]	; (ca8c <_isr_wrapper+0x34>)
	/* requested idle duration, in ticks */
	ldr r0, [r2, #_kernel_offset_to_idle]
    ca5e:	6a10      	ldr	r0, [r2, #32]
	cmp r0, #0
    ca60:	2800      	cmp	r0, #0
	str r1, [r2, #_kernel_offset_to_idle]
	bl z_sys_power_save_idle_exit
_idle_state_cleared:

#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	ittt ne
    ca62:	bf1e      	ittt	ne
	movne	r1, #0
    ca64:	2100      	movne	r1, #0
		/* clear kernel idle state */
		strne	r1, [r2, #_kernel_offset_to_idle]
    ca66:	6211      	strne	r1, [r2, #32]
		blne	z_sys_power_save_idle_exit
    ca68:	f001 fee0 	blne	e82c <z_sys_power_save_idle_exit>
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

#if defined(CONFIG_CPU_CORTEX_M)
	cpsie i		/* re-enable interrupts (PRIMASK = 0) */
    ca6c:	b662      	cpsie	i
#endif

#endif /* CONFIG_SYS_POWER_MANAGEMENT */

#if defined(CONFIG_CPU_CORTEX_M)
	mrs r0, IPSR	/* get exception number */
    ca6e:	f3ef 8005 	mrs	r0, IPSR
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	ldr r1, =16
	subs r0, r1	/* get IRQ number */
	lsls r0, #3	/* table is 8-byte wide */
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	sub r0, r0, #16	/* get IRQ number */
    ca72:	f1a0 0010 	sub.w	r0, r0, #16
	lsl r0, r0, #3	/* table is 8-byte wide */
    ca76:	ea4f 00c0 	mov.w	r0, r0, lsl #3
	 */
	mov r0, #0
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
	ldr r1, =_sw_isr_table
    ca7a:	4905      	ldr	r1, [pc, #20]	; (ca90 <_isr_wrapper+0x38>)
	add r1, r1, r0	/* table entry: ISRs must have their MSB set to stay
    ca7c:	4401      	add	r1, r0
			 * in thumb mode */

	ldm r1!,{r0,r3}	/* arg in r0, ISR in r3 */
    ca7e:	c909      	ldmia	r1!, {r0, r3}
#else
	pop {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
	ldm sp!,{r0-r3} /* Restore r0 to r3 regs */
#endif /* CONFIG_EXECUTION_BENCHMARKING */
	blx r3		/* call ISR */
    ca80:	4798      	blx	r3

#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	pop {r0, r3}
	mov lr, r3
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	pop {r0, lr}
    ca82:	e8bd 4001 	ldmia.w	sp!, {r0, lr}
#endif

	/* Use 'bx' instead of 'b' because 'bx' can jump further, and use
	 * 'bx' instead of 'blx' because exception return is done in
	 * z_arm_int_exit() */
	ldr r1, =z_arm_int_exit
    ca86:	4903      	ldr	r1, [pc, #12]	; (ca94 <_isr_wrapper+0x3c>)
	bx r1
    ca88:	4708      	bx	r1
    ca8a:	0000      	.short	0x0000
	ldr r2, =_kernel
    ca8c:	20020134 	.word	0x20020134
	ldr r1, =_sw_isr_table
    ca90:	0000e99c 	.word	0x0000e99c
	ldr r1, =z_arm_int_exit
    ca94:	0000c995 	.word	0x0000c995

0000ca98 <arch_swap>:
#ifdef CONFIG_EXECUTION_BENCHMARKING
	read_timer_start_of_swap();
#endif

	/* store off key and return value */
	_current->arch.basepri = key;
    ca98:	4a09      	ldr	r2, [pc, #36]	; (cac0 <arch_swap+0x28>)
	_current->arch.swap_return_value = _k_neg_eagain;
    ca9a:	490a      	ldr	r1, [pc, #40]	; (cac4 <arch_swap+0x2c>)
	_current->arch.basepri = key;
    ca9c:	6893      	ldr	r3, [r2, #8]
	_current->arch.swap_return_value = _k_neg_eagain;
    ca9e:	6809      	ldr	r1, [r1, #0]
	_current->arch.basepri = key;
    caa0:	6658      	str	r0, [r3, #100]	; 0x64
	_current->arch.swap_return_value = _k_neg_eagain;
    caa2:	6699      	str	r1, [r3, #104]	; 0x68

#if defined(CONFIG_CPU_CORTEX_M)
	/* set pending bit to make sure we will take a PendSV exception */
	SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
    caa4:	4908      	ldr	r1, [pc, #32]	; (cac8 <arch_swap+0x30>)
    caa6:	684b      	ldr	r3, [r1, #4]
    caa8:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
    caac:	604b      	str	r3, [r1, #4]
    caae:	2300      	movs	r3, #0
    cab0:	f383 8811 	msr	BASEPRI, r3
    cab4:	f3bf 8f6f 	isb	sy
#endif

	/* Context switch is performed here. Returning implies the
	 * thread has been context-switched-in again.
	 */
	return _current->arch.swap_return_value;
    cab8:	6893      	ldr	r3, [r2, #8]
}
    caba:	6e98      	ldr	r0, [r3, #104]	; 0x68
    cabc:	4770      	bx	lr
    cabe:	bf00      	nop
    cac0:	20020134 	.word	0x20020134
    cac4:	0000ecd0 	.word	0x0000ecd0
    cac8:	e000ed00 	.word	0xe000ed00

0000cacc <arch_irq_enable>:
#define REG_FROM_IRQ(irq) (irq / NUM_IRQS_PER_REG)
#define BIT_FROM_IRQ(irq) (irq % NUM_IRQS_PER_REG)

void arch_irq_enable(unsigned int irq)
{
	NVIC_EnableIRQ((IRQn_Type)irq);
    cacc:	b243      	sxtb	r3, r0
  if ((int32_t)(IRQn) >= 0)
    cace:	2b00      	cmp	r3, #0
    cad0:	db08      	blt.n	cae4 <arch_irq_enable+0x18>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    cad2:	2201      	movs	r2, #1
    cad4:	f000 001f 	and.w	r0, r0, #31
    cad8:	fa02 f000 	lsl.w	r0, r2, r0
    cadc:	4a02      	ldr	r2, [pc, #8]	; (cae8 <arch_irq_enable+0x1c>)
    cade:	095b      	lsrs	r3, r3, #5
    cae0:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
}
    cae4:	4770      	bx	lr
    cae6:	bf00      	nop
    cae8:	e000e100 	.word	0xe000e100

0000caec <z_arm_irq_priority_set>:
	 */
	__ASSERT(prio <= (BIT(DT_NUM_IRQ_PRIO_BITS) - 1),
		 "invalid priority %d! values must be less than %lu\n",
		 prio - _IRQ_PRIO_OFFSET,
		 BIT(DT_NUM_IRQ_PRIO_BITS) - (_IRQ_PRIO_OFFSET));
	NVIC_SetPriority((IRQn_Type)irq, prio);
    caec:	b243      	sxtb	r3, r0
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
    caee:	2b00      	cmp	r3, #0
	prio += _IRQ_PRIO_OFFSET;
    caf0:	f101 0101 	add.w	r1, r1, #1
  {
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    caf4:	bfa8      	it	ge
    caf6:	f103 4360 	addge.w	r3, r3, #3758096384	; 0xe0000000
    cafa:	ea4f 1141 	mov.w	r1, r1, lsl #5
  }
  else
  {
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    cafe:	bfb8      	it	lt
    cb00:	4b05      	ldrlt	r3, [pc, #20]	; (cb18 <z_arm_irq_priority_set+0x2c>)
    cb02:	b2c9      	uxtb	r1, r1
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    cb04:	bfab      	itete	ge
    cb06:	f503 4361 	addge.w	r3, r3, #57600	; 0xe100
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    cb0a:	f000 000f 	andlt.w	r0, r0, #15
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    cb0e:	f883 1300 	strbge.w	r1, [r3, #768]	; 0x300
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    cb12:	5419      	strblt	r1, [r3, r0]
}
    cb14:	4770      	bx	lr
    cb16:	bf00      	nop
    cb18:	e000ed14 	.word	0xe000ed14

0000cb1c <arch_new_thread>:
 */
void arch_new_thread(struct k_thread *thread, k_thread_stack_t *stack,
		     size_t stackSize, k_thread_entry_t pEntry,
		     void *parameter1, void *parameter2, void *parameter3,
		     int priority, unsigned int options)
{
    cb1c:	b573      	push	{r0, r1, r4, r5, r6, lr}
    cb1e:	461e      	mov	r6, r3
#endif
	stackEnd = pStackMem + stackSize;

	struct __esf *pInitCtx;

	z_new_thread_init(thread, pStackMem, stackSize, priority,
    cb20:	9b0a      	ldr	r3, [sp, #40]	; 0x28
{
    cb22:	4605      	mov	r5, r0
	z_new_thread_init(thread, pStackMem, stackSize, priority,
    cb24:	9300      	str	r3, [sp, #0]
    cb26:	9b09      	ldr	r3, [sp, #36]	; 0x24
	stackEnd = pStackMem + stackSize;
    cb28:	188c      	adds	r4, r1, r2
	z_new_thread_init(thread, pStackMem, stackSize, priority,
    cb2a:	f001 fee2 	bl	e8f2 <z_new_thread_init>
	pInitCtx->basic.pc = (u32_t)z_thread_entry;
#endif

#if defined(CONFIG_CPU_CORTEX_M)
	/* force ARM mode by clearing LSB of address */
	pInitCtx->basic.pc &= 0xfffffffe;
    cb2e:	4a0b      	ldr	r2, [pc, #44]	; (cb5c <arch_new_thread+0x40>)
	pInitCtx = (struct __esf *)(STACK_ROUND_DOWN(stackEnd -
    cb30:	f1a4 0320 	sub.w	r3, r4, #32
    cb34:	f023 0307 	bic.w	r3, r3, #7
	pInitCtx->basic.pc &= 0xfffffffe;
    cb38:	f022 0201 	bic.w	r2, r2, #1
    cb3c:	619a      	str	r2, [r3, #24]
#endif

	pInitCtx->basic.a1 = (u32_t)pEntry;
	pInitCtx->basic.a2 = (u32_t)parameter1;
    cb3e:	9a06      	ldr	r2, [sp, #24]
	pInitCtx->basic.a1 = (u32_t)pEntry;
    cb40:	601e      	str	r6, [r3, #0]
	pInitCtx->basic.a2 = (u32_t)parameter1;
    cb42:	605a      	str	r2, [r3, #4]
	pInitCtx->basic.a3 = (u32_t)parameter2;
    cb44:	9a07      	ldr	r2, [sp, #28]
    cb46:	609a      	str	r2, [r3, #8]
	pInitCtx->basic.a4 = (u32_t)parameter3;
    cb48:	9a08      	ldr	r2, [sp, #32]
    cb4a:	60da      	str	r2, [r3, #12]
	pInitCtx->basic.xpsr =
    cb4c:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
    cb50:	61da      	str	r2, [r3, #28]
		0x01000000UL; /* clear all, thumb bit is 1, even if RO */

	thread->callee_saved.psp = (u32_t)pInitCtx;
    cb52:	64ab      	str	r3, [r5, #72]	; 0x48
#if defined(CONFIG_CPU_CORTEX_R)
	pInitCtx->basic.lr = (u32_t)pInitCtx->basic.pc;
	thread->callee_saved.spsr = A_BIT | T_BIT | MODE_SYS;
	thread->callee_saved.lr = (u32_t)pInitCtx->basic.pc;
#endif
	thread->arch.basepri = 0;
    cb54:	2300      	movs	r3, #0
    cb56:	666b      	str	r3, [r5, #100]	; 0x64

	/*
	 * initial values in all other registers/thread entries are
	 * irrelevant.
	 */
}
    cb58:	b002      	add	sp, #8
    cb5a:	bd70      	pop	{r4, r5, r6, pc}
    cb5c:	0000e3f7 	.word	0x0000e3f7

0000cb60 <arch_switch_to_main_thread>:

void arch_switch_to_main_thread(struct k_thread *main_thread,
				k_thread_stack_t *main_stack,
				size_t main_stack_size,
				k_thread_entry_t _main)
{
    cb60:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    cb62:	4605      	mov	r5, r0
    cb64:	460c      	mov	r4, r1
    cb66:	4617      	mov	r7, r2
    cb68:	461e      	mov	r6, r3
	 * to set up access permissions for fixed memory sections, such
	 * as Application Memory or No-Cacheable SRAM area.
	 *
	 * This function is invoked once, upon system initialization.
	 */
	z_arm_configure_static_mpu_regions();
    cb6a:	f000 f959 	bl	ce20 <z_arm_configure_static_mpu_regions>
	start_of_main_stack =
		Z_THREAD_STACK_BUFFER(main_stack) + main_stack_size;

	start_of_main_stack = (char *)STACK_ROUND_DOWN(start_of_main_stack);

	_current = main_thread;
    cb6e:	4b0a      	ldr	r3, [pc, #40]	; (cb98 <arch_switch_to_main_thread+0x38>)
	start_of_main_stack =
    cb70:	443c      	add	r4, r7
#ifdef CONFIG_ARM_MPU
	/*
	 * If stack protection is enabled, make sure to set it
	 * before jumping to thread entry function
	 */
	z_arm_configure_dynamic_mpu_regions(main_thread);
    cb72:	4628      	mov	r0, r5
	_current = main_thread;
    cb74:	609d      	str	r5, [r3, #8]
	start_of_main_stack = (char *)STACK_ROUND_DOWN(start_of_main_stack);
    cb76:	f024 0407 	bic.w	r4, r4, #7
	z_arm_configure_dynamic_mpu_regions(main_thread);
    cb7a:	f001 fccd 	bl	e518 <z_arm_configure_dynamic_mpu_regions>

	/*
	 * Set PSP to the highest address of the main stack
	 * before enabling interrupts and jumping to main.
	 */
	__asm__ volatile (
    cb7e:	4630      	mov	r0, r6
    cb80:	f384 8809 	msr	PSP, r4
    cb84:	2100      	movs	r1, #0
    cb86:	b663      	cpsie	if
    cb88:	f381 8811 	msr	BASEPRI, r1
    cb8c:	f3bf 8f6f 	isb	sy
    cb90:	2200      	movs	r2, #0
    cb92:	2300      	movs	r3, #0
    cb94:	f001 fc2f 	bl	e3f6 <z_thread_entry>
	:
	: "r" (_main), "r" (start_of_main_stack)
	: "r0" /* not to be overwritten by msr PSP, %1 */
	);

	CODE_UNREACHABLE;
    cb98:	20020134 	.word	0x20020134

0000cb9c <z_arm_prep_c>:
 * This routine prepares for the execution of and runs C code.
 *
 * @return N/A
 */
void z_arm_prep_c(void)
{
    cb9c:	b508      	push	{r3, lr}
	SCB->VTOR = VECTOR_ADDRESS & SCB_VTOR_TBLOFF_Msk;
    cb9e:	4b08      	ldr	r3, [pc, #32]	; (cbc0 <z_arm_prep_c+0x24>)
    cba0:	4a08      	ldr	r2, [pc, #32]	; (cbc4 <z_arm_prep_c+0x28>)
    cba2:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
    cba6:	6093      	str	r3, [r2, #8]
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
    cba8:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    cbac:	f3bf 8f6f 	isb	sy
	relocate_vector_table();
	enable_floating_point();
	z_bss_zero();
    cbb0:	f000 fe5c 	bl	d86c <z_bss_zero>
	z_data_copy();
    cbb4:	f000 fe64 	bl	d880 <z_data_copy>
#if defined(CONFIG_ARMV7_R) && defined(CONFIG_INIT_STACKS)
	z_arm_init_stacks();
#endif
	z_arm_int_lib_init();
    cbb8:	f000 f900 	bl	cdbc <z_arm_int_lib_init>
	z_cstart();
    cbbc:	f000 fe9e 	bl	d8fc <z_cstart>
    cbc0:	0000c000 	.word	0x0000c000
    cbc4:	e000ed00 	.word	0xe000ed00

0000cbc8 <__start>:
 * search for a __start symbol instead, so create that alias here.
 */
SECTION_SUBSEC_FUNC(TEXT,_reset_section,__start)

#if defined(CONFIG_PLATFORM_SPECIFIC_INIT)
    bl z_platform_init
    cbc8:	f001 fc20 	bl	e40c <z_platform_init>

    /* lock interrupts: will get unlocked when switch to main task */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    cpsid i
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    movs.n r0, #_EXC_IRQ_DEFAULT_PRIO
    cbcc:	2020      	movs	r0, #32
    msr BASEPRI, r0
    cbce:	f380 8811 	msr	BASEPRI, r0

    /*
     * Set PSP and use it to boot without using MSP, so that it
     * gets set to _interrupt_stack during initialization.
     */
    ldr r0, =_interrupt_stack
    cbd2:	4808      	ldr	r0, [pc, #32]	; (cbf4 <__start+0x2c>)
    ldr r1, =CONFIG_ISR_STACK_SIZE
    cbd4:	f44f 6100 	mov.w	r1, #2048	; 0x800
    adds r0, r0, r1
    cbd8:	1840      	adds	r0, r0, r1
    msr PSP, r0
    cbda:	f380 8809 	msr	PSP, r0
    mrs r0, CONTROL
    cbde:	f3ef 8014 	mrs	r0, CONTROL
    movs r1, #2
    cbe2:	2102      	movs	r1, #2
    orrs r0, r1 /* CONTROL_SPSEL_Msk */
    cbe4:	4308      	orrs	r0, r1
    msr CONTROL, r0
    cbe6:	f380 8814 	msr	CONTROL, r0
    /*
     * When changing the stack pointer, software must use an ISB instruction
     * immediately after the MSR instruction. This ensures that instructions
     * after the ISB instruction execute using the new stack pointer.
     */
    isb
    cbea:	f3bf 8f6f 	isb	sy
    /*
     * 'bl' jumps the furthest of the branch instructions that are
     * supported on all platforms. So it is used when jumping to z_arm_prep_c
     * (even though we do not intend to return).
     */
    bl z_arm_prep_c
    cbee:	f7ff ffd5 	bl	cb9c <z_arm_prep_c>
    cbf2:	0000      	.short	0x0000
    ldr r0, =_interrupt_stack
    cbf4:	200206b8 	.word	0x200206b8

0000cbf8 <mem_manage_fault.isra.2>:
	u32_t reason = K_ERR_CPU_EXCEPTION;
	u32_t mmfar = -EINVAL;

	PR_FAULT_INFO("***** MPU FAULT *****");

	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) != 0) {
    cbf8:	4b0c      	ldr	r3, [pc, #48]	; (cc2c <mem_manage_fault.isra.2+0x34>)
    cbfa:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		PR_FAULT_INFO("  Stacking error (context area might be"
			" not valid)");
	}
	if ((SCB->CFSR & SCB_CFSR_MUNSTKERR_Msk) != 0) {
    cbfc:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		PR_FAULT_INFO("  Unstacking error");
	}
	if ((SCB->CFSR & SCB_CFSR_DACCVIOL_Msk) != 0) {
    cbfe:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    cc00:	0792      	lsls	r2, r2, #30
    cc02:	d508      	bpl.n	cc16 <mem_manage_fault.isra.2+0x1e>
		 * The MMFAR address is valid only if this bit is 1.
		 *
		 * Software must follow this sequence because another higher
		 * priority exception might change the MMFAR value.
		 */
		mmfar = SCB->MMFAR;
    cc04:	6b5a      	ldr	r2, [r3, #52]	; 0x34

		if ((SCB->CFSR & SCB_CFSR_MMARVALID_Msk) != 0) {
    cc06:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    cc08:	0612      	lsls	r2, r2, #24
    cc0a:	d504      	bpl.n	cc16 <mem_manage_fault.isra.2+0x1e>
			PR_EXC("  MMFAR Address: 0x%x", mmfar);
			if (from_hard_fault) {
    cc0c:	b118      	cbz	r0, cc16 <mem_manage_fault.isra.2+0x1e>
				/* clear SCB_MMAR[VALID] to reset */
				SCB->CFSR &= ~SCB_CFSR_MMARVALID_Msk;
    cc0e:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    cc10:	f022 0280 	bic.w	r2, r2, #128	; 0x80
    cc14:	629a      	str	r2, [r3, #40]	; 0x28

	/* clear MMFSR sticky bits */
	SCB->CFSR |= SCB_CFSR_MEMFAULTSR_Msk;

	/* Assess whether system shall ignore/recover from this MPU fault. */
	*recoverable = memory_fault_recoverable(esf);
    cc16:	2000      	movs	r0, #0
	if ((SCB->CFSR & SCB_CFSR_IACCVIOL_Msk) != 0) {
    cc18:	4b04      	ldr	r3, [pc, #16]	; (cc2c <mem_manage_fault.isra.2+0x34>)
    cc1a:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_MLSPERR_Msk) != 0) {
    cc1c:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	if (SCB->CFSR & SCB_CFSR_MSTKERR_Msk) {
    cc1e:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	SCB->CFSR |= SCB_CFSR_MEMFAULTSR_Msk;
    cc20:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    cc22:	f042 02ff 	orr.w	r2, r2, #255	; 0xff
    cc26:	629a      	str	r2, [r3, #40]	; 0x28
	*recoverable = memory_fault_recoverable(esf);
    cc28:	7008      	strb	r0, [r1, #0]

	return reason;
}
    cc2a:	4770      	bx	lr
    cc2c:	e000ed00 	.word	0xe000ed00

0000cc30 <bus_fault.isra.3>:
{
	u32_t reason = K_ERR_CPU_EXCEPTION;

	PR_FAULT_INFO("***** BUS FAULT *****");

	if (SCB->CFSR & SCB_CFSR_STKERR_Msk) {
    cc30:	4b0d      	ldr	r3, [pc, #52]	; (cc68 <bus_fault.isra.3+0x38>)
    cc32:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		PR_FAULT_INFO("  Stacking error");
	}
	if (SCB->CFSR & SCB_CFSR_UNSTKERR_Msk) {
    cc34:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		PR_FAULT_INFO("  Unstacking error");
	}
	if (SCB->CFSR & SCB_CFSR_PRECISERR_Msk) {
    cc36:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    cc38:	0592      	lsls	r2, r2, #22
    cc3a:	d508      	bpl.n	cc4e <bus_fault.isra.3+0x1e>
		 * The BFAR address is valid only if this bit is 1.
		 *
		 * Software must follow this sequence because another
		 * higher priority exception might change the BFAR value.
		 */
		STORE_xFAR(bfar, SCB->BFAR);
    cc3c:	6b9a      	ldr	r2, [r3, #56]	; 0x38

		if ((SCB->CFSR & SCB_CFSR_BFARVALID_Msk) != 0) {
    cc3e:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    cc40:	0412      	lsls	r2, r2, #16
    cc42:	d504      	bpl.n	cc4e <bus_fault.isra.3+0x1e>
			PR_EXC("  BFAR Address: 0x%x", bfar);
			if (from_hard_fault) {
    cc44:	b118      	cbz	r0, cc4e <bus_fault.isra.3+0x1e>
				/* clear SCB_CFSR_BFAR[VALID] to reset */
				SCB->CFSR &= ~SCB_CFSR_BFARVALID_Msk;
    cc46:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    cc48:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
    cc4c:	629a      	str	r2, [r3, #40]	; 0x28
#endif /* defined(CONFIG_ARM_MPU) && defined(CONFIG_CPU_HAS_NXP_MPU) */

	/* clear BFSR sticky bits */
	SCB->CFSR |= SCB_CFSR_BUSFAULTSR_Msk;

	*recoverable = memory_fault_recoverable(esf);
    cc4e:	2000      	movs	r0, #0
	if (SCB->CFSR & SCB_CFSR_IMPRECISERR_Msk) {
    cc50:	4b05      	ldr	r3, [pc, #20]	; (cc68 <bus_fault.isra.3+0x38>)
    cc52:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_IBUSERR_Msk) != 0) {
    cc54:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    cc56:	05d2      	lsls	r2, r2, #23
	} else if (SCB->CFSR & SCB_CFSR_LSPERR_Msk) {
    cc58:	bf58      	it	pl
    cc5a:	6a9a      	ldrpl	r2, [r3, #40]	; 0x28
	SCB->CFSR |= SCB_CFSR_BUSFAULTSR_Msk;
    cc5c:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    cc5e:	f442 427f 	orr.w	r2, r2, #65280	; 0xff00
    cc62:	629a      	str	r2, [r3, #40]	; 0x28
	*recoverable = memory_fault_recoverable(esf);
    cc64:	7008      	strb	r0, [r1, #0]

	return reason;
}
    cc66:	4770      	bx	lr
    cc68:	e000ed00 	.word	0xe000ed00

0000cc6c <usage_fault.isra.4>:
	u32_t reason = K_ERR_CPU_EXCEPTION;

	PR_FAULT_INFO("***** USAGE FAULT *****");

	/* bits are sticky: they stack and must be reset */
	if ((SCB->CFSR & SCB_CFSR_DIVBYZERO_Msk) != 0) {
    cc6c:	4b07      	ldr	r3, [pc, #28]	; (cc8c <usage_fault.isra.4+0x20>)

	/* clear UFSR sticky bits */
	SCB->CFSR |= SCB_CFSR_USGFAULTSR_Msk;

	return reason;
}
    cc6e:	2000      	movs	r0, #0
	if ((SCB->CFSR & SCB_CFSR_DIVBYZERO_Msk) != 0) {
    cc70:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_UNALIGNED_Msk) != 0) {
    cc72:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_STKOF_Msk) != 0) {
    cc74:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_NOCP_Msk) != 0) {
    cc76:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_INVPC_Msk) != 0) {
    cc78:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_INVSTATE_Msk) != 0) {
    cc7a:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_UNDEFINSTR_Msk) != 0) {
    cc7c:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	SCB->CFSR |= SCB_CFSR_USGFAULTSR_Msk;
    cc7e:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    cc80:	ea6f 4202 	mvn.w	r2, r2, lsl #16
    cc84:	ea6f 4212 	mvn.w	r2, r2, lsr #16
    cc88:	629a      	str	r2, [r3, #40]	; 0x28
}
    cc8a:	4770      	bx	lr
    cc8c:	e000ed00 	.word	0xe000ed00

0000cc90 <z_arm_fault>:
 * @param psp PSP value immediately after the exception occurred
 * @param exc_return EXC_RETURN value present in LR after exception entry.
 *
 */
void z_arm_fault(u32_t msp, u32_t psp, u32_t exc_return)
{
    cc90:	b570      	push	{r4, r5, r6, lr}
	u32_t reason = K_ERR_CPU_EXCEPTION;
	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
    cc92:	4b3a      	ldr	r3, [pc, #232]	; (cd7c <z_arm_fault+0xec>)
{
    cc94:	b08a      	sub	sp, #40	; 0x28
	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
    cc96:	685b      	ldr	r3, [r3, #4]
    cc98:	2500      	movs	r5, #0
    cc9a:	f3c3 0308 	ubfx	r3, r3, #0, #9
    cc9e:	f385 8811 	msr	BASEPRI, r5
    cca2:	f3bf 8f6f 	isb	sy
	if ((exc_return & EXC_RETURN_INDICATOR_PREFIX) !=
    cca6:	f002 447f 	and.w	r4, r2, #4278190080	; 0xff000000
    ccaa:	f1b4 4f7f 	cmp.w	r4, #4278190080	; 0xff000000
    ccae:	d119      	bne.n	cce4 <z_arm_fault+0x54>
	if (exc_return & EXC_RETURN_EXCEPTION_SECURE_Secure) {
    ccb0:	07d6      	lsls	r6, r2, #31
    ccb2:	d417      	bmi.n	cce4 <z_arm_fault+0x54>
	if (exc_return & EXC_RETURN_RETURN_STACK_Secure) {
    ccb4:	0655      	lsls	r5, r2, #25
    ccb6:	d404      	bmi.n	ccc2 <z_arm_fault+0x32>
		if (exc_return & EXC_RETURN_MODE_THREAD) {
    ccb8:	0714      	lsls	r4, r2, #28
    ccba:	d405      	bmi.n	ccc8 <z_arm_fault+0x38>
			ptr_esf = (z_arch_esf_t *)msp;
    ccbc:	4606      	mov	r6, r0
			*nested_exc = true;
    ccbe:	2501      	movs	r5, #1
    ccc0:	e004      	b.n	cccc <z_arm_fault+0x3c>
		if (exc_return & EXC_RETURN_SPSEL_PROCESS) {
    ccc2:	f012 0504 	ands.w	r5, r2, #4
    ccc6:	d00b      	beq.n	cce0 <z_arm_fault+0x50>
			ptr_esf = (z_arch_esf_t *)psp;
    ccc8:	460e      	mov	r6, r1
	*nested_exc = false;
    ccca:	2500      	movs	r5, #0
	*recoverable = false;
    cccc:	2200      	movs	r2, #0
	switch (fault) {
    ccce:	3b03      	subs	r3, #3
	*recoverable = false;
    ccd0:	f88d 2007 	strb.w	r2, [sp, #7]
	switch (fault) {
    ccd4:	2b03      	cmp	r3, #3
    ccd6:	d849      	bhi.n	cd6c <z_arm_fault+0xdc>
    ccd8:	e8df f003 	tbb	[pc, r3]
    ccdc:	3d444006 	.word	0x3d444006
			ptr_esf = (z_arch_esf_t *)msp;
    cce0:	4606      	mov	r6, r0
	if (!alternative_state_exc) {
    cce2:	e7f3      	b.n	cccc <z_arm_fault+0x3c>
		return NULL;
    cce4:	462e      	mov	r6, r5
    cce6:	e7f1      	b.n	cccc <z_arm_fault+0x3c>
	if ((SCB->HFSR & SCB_HFSR_VECTTBL_Msk) != 0) {
    cce8:	4b24      	ldr	r3, [pc, #144]	; (cd7c <z_arm_fault+0xec>)
    ccea:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    ccec:	0792      	lsls	r2, r2, #30
    ccee:	d43d      	bmi.n	cd6c <z_arm_fault+0xdc>
	} else if ((SCB->HFSR & SCB_HFSR_FORCED_Msk) != 0) {
    ccf0:	6adc      	ldr	r4, [r3, #44]	; 0x2c
    ccf2:	f014 4480 	ands.w	r4, r4, #1073741824	; 0x40000000
    ccf6:	d008      	beq.n	cd0a <z_arm_fault+0x7a>
		if (SCB_MMFSR != 0) {
    ccf8:	3328      	adds	r3, #40	; 0x28
    ccfa:	781b      	ldrb	r3, [r3, #0]
    ccfc:	b1eb      	cbz	r3, cd3a <z_arm_fault+0xaa>
			reason = mem_manage_fault(esf, 1, recoverable);
    ccfe:	2001      	movs	r0, #1
    cd00:	f10d 0107 	add.w	r1, sp, #7
		reason = mem_manage_fault(esf, 0, recoverable);
    cd04:	f7ff ff78 	bl	cbf8 <mem_manage_fault.isra.2>
		reason = usage_fault(esf);
    cd08:	4604      	mov	r4, r0
	 esf = get_esf(msp, psp, exc_return, &nested_exc);
	__ASSERT(esf != NULL,
		"ESF could not be retrieved successfully. Shall never occur.");

	reason = fault_handle(esf, fault, &recoverable);
	if (recoverable) {
    cd0a:	f89d 3007 	ldrb.w	r3, [sp, #7]
    cd0e:	b993      	cbnz	r3, cd36 <z_arm_fault+0xa6>
		return;
	}

	/* Copy ESF */
	memcpy(&esf_copy, esf, sizeof(z_arch_esf_t));
    cd10:	2220      	movs	r2, #32
    cd12:	4631      	mov	r1, r6
    cd14:	a802      	add	r0, sp, #8
    cd16:	f001 fc4e 	bl	e5b6 <memcpy>
	/* Overwrite stacked IPSR to mark a nested exception,
	 * or a return to Thread mode. Note that this may be
	 * required, if the retrieved ESF contents are invalid
	 * due to, for instance, a stacking error.
	 */
	if (nested_exc) {
    cd1a:	9b09      	ldr	r3, [sp, #36]	; 0x24
    cd1c:	b345      	cbz	r5, cd70 <z_arm_fault+0xe0>
		if ((esf_copy.basic.xpsr & IPSR_ISR_Msk) == 0) {
    cd1e:	f3c3 0208 	ubfx	r2, r3, #0, #9
    cd22:	b922      	cbnz	r2, cd2e <z_arm_fault+0x9e>
			esf_copy.basic.xpsr |= IPSR_ISR_Msk;
    cd24:	ea6f 2353 	mvn.w	r3, r3, lsr #9
    cd28:	ea6f 2343 	mvn.w	r3, r3, lsl #9
		}
	} else {
		esf_copy.basic.xpsr &= ~(IPSR_ISR_Msk);
    cd2c:	9309      	str	r3, [sp, #36]	; 0x24
	}

	z_arm_fatal_error(reason, &esf_copy);
    cd2e:	a902      	add	r1, sp, #8
    cd30:	4620      	mov	r0, r4
    cd32:	f001 fbe4 	bl	e4fe <z_arm_fatal_error>
}
    cd36:	b00a      	add	sp, #40	; 0x28
    cd38:	bd70      	pop	{r4, r5, r6, pc}
		} else if (SCB_BFSR != 0) {
    cd3a:	4b11      	ldr	r3, [pc, #68]	; (cd80 <z_arm_fault+0xf0>)
    cd3c:	781b      	ldrb	r3, [r3, #0]
    cd3e:	b12b      	cbz	r3, cd4c <z_arm_fault+0xbc>
			reason = bus_fault(esf, 1, recoverable);
    cd40:	2001      	movs	r0, #1
    cd42:	f10d 0107 	add.w	r1, sp, #7
		reason = bus_fault(esf, 0, recoverable);
    cd46:	f7ff ff73 	bl	cc30 <bus_fault.isra.3>
    cd4a:	e7dd      	b.n	cd08 <z_arm_fault+0x78>
		} else if (SCB_UFSR != 0) {
    cd4c:	4b0d      	ldr	r3, [pc, #52]	; (cd84 <z_arm_fault+0xf4>)
    cd4e:	881c      	ldrh	r4, [r3, #0]
    cd50:	b2a4      	uxth	r4, r4
    cd52:	2c00      	cmp	r4, #0
    cd54:	d0d9      	beq.n	cd0a <z_arm_fault+0x7a>
		reason = usage_fault(esf);
    cd56:	f7ff ff89 	bl	cc6c <usage_fault.isra.4>
    cd5a:	e7d5      	b.n	cd08 <z_arm_fault+0x78>
		reason = mem_manage_fault(esf, 0, recoverable);
    cd5c:	f10d 0107 	add.w	r1, sp, #7
    cd60:	2000      	movs	r0, #0
    cd62:	e7cf      	b.n	cd04 <z_arm_fault+0x74>
		reason = bus_fault(esf, 0, recoverable);
    cd64:	f10d 0107 	add.w	r1, sp, #7
    cd68:	2000      	movs	r0, #0
    cd6a:	e7ec      	b.n	cd46 <z_arm_fault+0xb6>
	u32_t reason = K_ERR_CPU_EXCEPTION;
    cd6c:	2400      	movs	r4, #0
    cd6e:	e7cc      	b.n	cd0a <z_arm_fault+0x7a>
		esf_copy.basic.xpsr &= ~(IPSR_ISR_Msk);
    cd70:	f423 73ff 	bic.w	r3, r3, #510	; 0x1fe
    cd74:	f023 0301 	bic.w	r3, r3, #1
    cd78:	e7d8      	b.n	cd2c <z_arm_fault+0x9c>
    cd7a:	bf00      	nop
    cd7c:	e000ed00 	.word	0xe000ed00
    cd80:	e000ed29 	.word	0xe000ed29
    cd84:	e000ed2a 	.word	0xe000ed2a

0000cd88 <z_arm_fault_init>:
 */
void z_arm_fault_init(void)
{
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	SCB->CCR |= SCB_CCR_DIV_0_TRP_Msk;
    cd88:	4a02      	ldr	r2, [pc, #8]	; (cd94 <z_arm_fault_init+0xc>)
    cd8a:	6953      	ldr	r3, [r2, #20]
    cd8c:	f043 0310 	orr.w	r3, r3, #16
    cd90:	6153      	str	r3, [r2, #20]
	 * Stack to attempt to descend into secure region, in which case a
	 * Secure Hard Fault will occur and we can track the fault from there.
	 */
	SCB->CCR |= SCB_CCR_STKOFHFNMIGN_Msk;
#endif /* CONFIG_BUILTIN_STACK_GUARD */
}
    cd92:	4770      	bx	lr
    cd94:	e000ed00 	.word	0xe000ed00

0000cd98 <sys_arch_reboot>:
  __ASM volatile ("dsb 0xF":::"memory");
    cd98:	f3bf 8f4f 	dsb	sy
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
    cd9c:	4905      	ldr	r1, [pc, #20]	; (cdb4 <sys_arch_reboot+0x1c>)
    cd9e:	4b06      	ldr	r3, [pc, #24]	; (cdb8 <sys_arch_reboot+0x20>)
    cda0:	68ca      	ldr	r2, [r1, #12]
    cda2:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
    cda6:	4313      	orrs	r3, r2
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
    cda8:	60cb      	str	r3, [r1, #12]
    cdaa:	f3bf 8f4f 	dsb	sy
                            SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
  __DSB();                                                          /* Ensure completion of memory access */

  for(;;)                                                           /* wait until reset */
  {
    __NOP();
    cdae:	bf00      	nop
    cdb0:	e7fd      	b.n	cdae <sys_arch_reboot+0x16>
    cdb2:	bf00      	nop
    cdb4:	e000ed00 	.word	0xe000ed00
    cdb8:	05fa0004 	.word	0x05fa0004

0000cdbc <z_arm_int_lib_init>:
 * @return N/A
 */

void z_arm_int_lib_init(void)
{
	int irq = 0;
    cdbc:	2300      	movs	r3, #0
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    cdbe:	2120      	movs	r1, #32
    cdc0:	4803      	ldr	r0, [pc, #12]	; (cdd0 <z_arm_int_lib_init+0x14>)
    cdc2:	18c2      	adds	r2, r0, r3

	for (; irq < CONFIG_NUM_IRQS; irq++) {
    cdc4:	3301      	adds	r3, #1
    cdc6:	2b41      	cmp	r3, #65	; 0x41
    cdc8:	f882 1300 	strb.w	r1, [r2, #768]	; 0x300
    cdcc:	d1f9      	bne.n	cdc2 <z_arm_int_lib_init+0x6>
		NVIC_SetPriority((IRQn_Type)irq, _IRQ_PRIO_OFFSET);
	}
}
    cdce:	4770      	bx	lr
    cdd0:	e000e100 	.word	0xe000e100

0000cdd4 <z_impl_k_thread_abort>:
#include <sys/__assert.h>

extern void z_thread_single_abort(struct k_thread *thread);

void z_impl_k_thread_abort(k_tid_t thread)
{
    cdd4:	b538      	push	{r3, r4, r5, lr}
    cdd6:	4605      	mov	r5, r0
	__asm__ volatile(
    cdd8:	f04f 0320 	mov.w	r3, #32
    cddc:	f3ef 8411 	mrs	r4, BASEPRI
    cde0:	f383 8811 	msr	BASEPRI, r3
    cde4:	f3bf 8f6f 	isb	sy
	key = irq_lock();

	__ASSERT(!(thread->base.user_options & K_ESSENTIAL),
		 "essential thread aborted");

	z_thread_single_abort(thread);
    cde8:	f000 ff60 	bl	dcac <z_thread_single_abort>
	z_thread_monitor_exit(thread);

	if (_current == thread) {
    cdec:	4b0a      	ldr	r3, [pc, #40]	; (ce18 <z_impl_k_thread_abort+0x44>)
    cdee:	689b      	ldr	r3, [r3, #8]
    cdf0:	42ab      	cmp	r3, r5
    cdf2:	d10b      	bne.n	ce0c <z_impl_k_thread_abort+0x38>
		if ((SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk) == 0) {
    cdf4:	4b09      	ldr	r3, [pc, #36]	; (ce1c <z_impl_k_thread_abort+0x48>)
    cdf6:	685a      	ldr	r2, [r3, #4]
    cdf8:	f3c2 0208 	ubfx	r2, r2, #0, #9
    cdfc:	b912      	cbnz	r2, ce04 <z_impl_k_thread_abort+0x30>
	int ret;
	z_check_stack_sentinel();
#ifndef CONFIG_ARM
	sys_trace_thread_switched_out();
#endif
	ret = arch_swap(key);
    cdfe:	4620      	mov	r0, r4
    ce00:	f7ff fe4a 	bl	ca98 <arch_swap>
			(void)z_swap_irqlock(key);
			CODE_UNREACHABLE;
		} else {
			SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
    ce04:	685a      	ldr	r2, [r3, #4]
    ce06:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
    ce0a:	605a      	str	r2, [r3, #4]
		}
	}

	/* The abort handler might have altered the ready queue. */
	z_reschedule_irqlock(key);
    ce0c:	4620      	mov	r0, r4
}
    ce0e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	z_reschedule_irqlock(key);
    ce12:	f001 bd21 	b.w	e858 <z_reschedule_irqlock>
    ce16:	bf00      	nop
    ce18:	20020134 	.word	0x20020134
    ce1c:	e000ed00 	.word	0xe000ed00

0000ce20 <z_arm_configure_static_mpu_regions>:
 *
 * For some MPU architectures, such as the unmodified ARMv8-M MPU,
 * the function must execute with MPU enabled.
 */
void z_arm_configure_static_mpu_regions(void)
{
    ce20:	b510      	push	{r4, lr}
		.size = (u32_t)&_nocache_ram_size,
		.attr = K_MEM_PARTITION_P_RW_U_NA_NOCACHE,
		};
#endif /* CONFIG_NOCACHE_MEMORY */
#if defined(CONFIG_ARCH_HAS_RAMFUNC_SUPPORT)
		const struct k_mem_partition ramfunc_region =
    ce22:	4b0e      	ldr	r3, [pc, #56]	; (ce5c <z_arm_configure_static_mpu_regions+0x3c>)
{
    ce24:	b088      	sub	sp, #32
		const struct k_mem_partition ramfunc_region =
    ce26:	9302      	str	r3, [sp, #8]
    ce28:	4b0d      	ldr	r3, [pc, #52]	; (ce60 <z_arm_configure_static_mpu_regions+0x40>)
	/* Configure the static MPU regions within firmware SRAM boundaries.
	 * Start address of the image is given by _image_ram_start. The end
	 * of the firmware SRAM area is marked by __kernel_ram_end, taking
	 * into account the unused SRAM area, as well.
	 */
	arm_core_mpu_configure_static_mpu_regions(static_regions,
    ce2a:	4c0e      	ldr	r4, [pc, #56]	; (ce64 <z_arm_configure_static_mpu_regions+0x44>)
		const struct k_mem_partition ramfunc_region =
    ce2c:	9303      	str	r3, [sp, #12]
    ce2e:	4b0e      	ldr	r3, [pc, #56]	; (ce68 <z_arm_configure_static_mpu_regions+0x48>)
	arm_core_mpu_configure_static_mpu_regions(static_regions,
    ce30:	4a0e      	ldr	r2, [pc, #56]	; (ce6c <z_arm_configure_static_mpu_regions+0x4c>)
		const struct k_mem_partition ramfunc_region =
    ce32:	9304      	str	r3, [sp, #16]
	const struct k_mem_partition *static_regions[] = {
    ce34:	ab02      	add	r3, sp, #8
    ce36:	9301      	str	r3, [sp, #4]
	arm_core_mpu_configure_static_mpu_regions(static_regions,
    ce38:	a801      	add	r0, sp, #4
    ce3a:	4623      	mov	r3, r4
    ce3c:	2101      	movs	r1, #1
    ce3e:	f000 f903 	bl	d048 <arm_core_mpu_configure_static_mpu_regions>
	/* Define a constant array of k_mem_partition objects that holds the
	 * boundaries of the areas, inside which dynamic region programming
	 * is allowed. The information is passed to the underlying driver at
	 * initialization.
	 */
	const struct k_mem_partition dyn_region_areas[] = {
    ce42:	2300      	movs	r3, #0
    ce44:	9307      	str	r3, [sp, #28]
		{
		.start = _MPU_DYNAMIC_REGIONS_AREA_START,
    ce46:	4b0a      	ldr	r3, [pc, #40]	; (ce70 <z_arm_configure_static_mpu_regions+0x50>)
		.size =  _MPU_DYNAMIC_REGIONS_AREA_SIZE,
		}
	};

	arm_core_mpu_mark_areas_for_dynamic_regions(dyn_region_areas,
    ce48:	2101      	movs	r1, #1
		.size =  _MPU_DYNAMIC_REGIONS_AREA_SIZE,
    ce4a:	1ae4      	subs	r4, r4, r3
	arm_core_mpu_mark_areas_for_dynamic_regions(dyn_region_areas,
    ce4c:	a805      	add	r0, sp, #20
	const struct k_mem_partition dyn_region_areas[] = {
    ce4e:	9305      	str	r3, [sp, #20]
    ce50:	9406      	str	r4, [sp, #24]
	arm_core_mpu_mark_areas_for_dynamic_regions(dyn_region_areas,
    ce52:	f000 f903 	bl	d05c <arm_core_mpu_mark_areas_for_dynamic_regions>
		ARRAY_SIZE(dyn_region_areas));
#endif /* CONFIG_MPU_REQUIRES_NON_OVERLAPPING_REGIONS */
}
    ce56:	b008      	add	sp, #32
    ce58:	bd10      	pop	{r4, pc}
    ce5a:	bf00      	nop
    ce5c:	20020000 	.word	0x20020000
    ce60:	00000000 	.word	0x00000000
    ce64:	20040000 	.word	0x20040000
    ce68:	00010006 	.word	0x00010006
    ce6c:	20020000 	.word	0x20020000
    ce70:	20020000 	.word	0x20020000

0000ce74 <region_init>:
 * Note:
 *   The caller must provide a valid region index.
 */
static void region_init(const u32_t index,
	const struct arm_mpu_region *region_conf)
{
    ce74:	b510      	push	{r4, lr}
	ARM_MPU_SetRegion(
		/* RNR */
		index,
		/* RBAR */
		(region_conf->base & MPU_RBAR_BASE_Msk)
    ce76:	680b      	ldr	r3, [r1, #0]
		| (region_conf->attr.rbar &
    ce78:	7a0c      	ldrb	r4, [r1, #8]
		(region_conf->base & MPU_RBAR_BASE_Msk)
    ce7a:	f023 021f 	bic.w	r2, r3, #31
		| (region_conf->attr.rbar &
    ce7e:	f004 031f 	and.w	r3, r4, #31
    ce82:	431a      	orrs	r2, r3
			(MPU_RBAR_XN_Msk | MPU_RBAR_AP_Msk | MPU_RBAR_SH_Msk)),
		/* RLAR */
		(region_conf->attr.r_limit & MPU_RLAR_LIMIT_Msk)
    ce84:	68cb      	ldr	r3, [r1, #12]
		| ((region_conf->attr.mair_idx << MPU_RLAR_AttrIndx_Pos)
    ce86:	0964      	lsrs	r4, r4, #5
		(region_conf->attr.r_limit & MPU_RLAR_LIMIT_Msk)
    ce88:	f023 031f 	bic.w	r3, r3, #31
* \param rbar Value for RBAR register.
* \param rlar Value for RLAR register.
*/   
__STATIC_INLINE void ARM_MPU_SetRegionEx(MPU_Type* mpu, uint32_t rnr, uint32_t rbar, uint32_t rlar)
{
  mpu->RNR = rnr;
    ce8c:	4904      	ldr	r1, [pc, #16]	; (cea0 <region_init+0x2c>)
		| ((region_conf->attr.mair_idx << MPU_RLAR_AttrIndx_Pos)
    ce8e:	ea43 0344 	orr.w	r3, r3, r4, lsl #1
			& MPU_RLAR_AttrIndx_Msk)
		| MPU_RLAR_EN_Msk
    ce92:	f043 0301 	orr.w	r3, r3, #1
    ce96:	6088      	str	r0, [r1, #8]
  mpu->RBAR = rbar;
    ce98:	60ca      	str	r2, [r1, #12]
  mpu->RLAR = rlar;
    ce9a:	610b      	str	r3, [r1, #16]
	);

	LOG_DBG("[%d] 0x%08x 0x%08x 0x%08x 0x%08x",
			index, region_conf->base, region_conf->attr.rbar,
			region_conf->attr.mair_idx, region_conf->attr.r_limit);
}
    ce9c:	bd10      	pop	{r4, pc}
    ce9e:	bf00      	nop
    cea0:	e000ed90 	.word	0xe000ed90

0000cea4 <mpu_configure_regions_and_partition.constprop.1>:
 * sanity check of the memory regions to be programmed.
 *
 * The function performs a full partition of the background memory
 * area, effectively, leaving no space in this area uncovered by MPU.
 */
static int mpu_configure_regions_and_partition(const struct k_mem_partition
    cea4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    cea8:	4680      	mov	r8, r0
    ceaa:	4689      	mov	r9, r1
    ceac:	4614      	mov	r4, r2
	bool do_sanity_check)
{
	int i;
	int reg_index = start_reg_index;

	for (i = 0; i < regions_num; i++) {
    ceae:	2700      	movs	r7, #0
	MPU->RNR = index;
    ceb0:	4d48      	ldr	r5, [pc, #288]	; (cfd4 <mpu_configure_regions_and_partition.constprop.1+0x130>)
static int mpu_configure_regions_and_partition(const struct k_mem_partition
    ceb2:	b085      	sub	sp, #20
	for (i = 0; i < regions_num; i++) {
    ceb4:	454f      	cmp	r7, r9
    ceb6:	da07      	bge.n	cec8 <mpu_configure_regions_and_partition.constprop.1+0x24>
		if (regions[i]->size == 0U) {
    ceb8:	f858 3027 	ldr.w	r3, [r8, r7, lsl #2]
    cebc:	685e      	ldr	r6, [r3, #4]
    cebe:	b3c6      	cbz	r6, cf32 <mpu_configure_regions_and_partition.constprop.1+0x8e>
		&&
    cec0:	2e1f      	cmp	r6, #31
    cec2:	d805      	bhi.n	ced0 <mpu_configure_regions_and_partition.constprop.1+0x2c>

			reg_index =
				mpu_configure_region(reg_index, regions[i]);

			if (reg_index == -EINVAL) {
				return reg_index;
    cec4:	f06f 0415 	mvn.w	r4, #21
			reg_index++;
		}
	}

	return reg_index;
}
    cec8:	4620      	mov	r0, r4
    ceca:	b005      	add	sp, #20
    cecc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		&&
    ced0:	06f2      	lsls	r2, r6, #27
    ced2:	d1f7      	bne.n	cec4 <mpu_configure_regions_and_partition.constprop.1+0x20>
		((part->start &
    ced4:	f8d3 a000 	ldr.w	sl, [r3]
		&&
    ced8:	f01a 0f1f 	tst.w	sl, #31
    cedc:	d1f2      	bne.n	cec4 <mpu_configure_regions_and_partition.constprop.1+0x20>
	u32_t region_start_addr = arm_cmse_mpu_region_get(start);
    cede:	4650      	mov	r0, sl
    cee0:	f001 fb44 	bl	e56c <arm_cmse_mpu_region_get>
    cee4:	4683      	mov	fp, r0
	u32_t region_end_addr = arm_cmse_mpu_region_get(start + size - 1);
    cee6:	eb06 000a 	add.w	r0, r6, sl
    ceea:	3801      	subs	r0, #1
    ceec:	f001 fb3e 	bl	e56c <arm_cmse_mpu_region_get>
	if (region_start_addr == region_end_addr) {
    cef0:	4583      	cmp	fp, r0
    cef2:	d1e7      	bne.n	cec4 <mpu_configure_regions_and_partition.constprop.1+0x20>
		if ((u_reg_index == -EINVAL) ||
    cef4:	f11b 0f16 	cmn.w	fp, #22
    cef8:	d0e4      	beq.n	cec4 <mpu_configure_regions_and_partition.constprop.1+0x20>
			(u_reg_index > (reg_index - 1))) {
    cefa:	1e63      	subs	r3, r4, #1
		if ((u_reg_index == -EINVAL) ||
    cefc:	455b      	cmp	r3, fp
    cefe:	dbe1      	blt.n	cec4 <mpu_configure_regions_and_partition.constprop.1+0x20>
	MPU->RNR = index;
    cf00:	f8c5 b008 	str.w	fp, [r5, #8]
	return MPU->RBAR & MPU_RBAR_BASE_Msk;
    cf04:	68e8      	ldr	r0, [r5, #12]
		u32_t reg_last = regions[i]->start + regions[i]->size - 1;
    cf06:	f858 1027 	ldr.w	r1, [r8, r7, lsl #2]
	MPU->RNR = index;
    cf0a:	f8c5 b008 	str.w	fp, [r5, #8]
	return (MPU->RLAR & MPU_RLAR_LIMIT_Msk) | (~MPU_RLAR_LIMIT_Msk);
    cf0e:	692e      	ldr	r6, [r5, #16]
	return MPU->RBAR & MPU_RBAR_BASE_Msk;
    cf10:	f020 001f 	bic.w	r0, r0, #31
		u32_t reg_last = regions[i]->start + regions[i]->size - 1;
    cf14:	e9d1 3200 	ldrd	r3, r2, [r1]
    cf18:	441a      	add	r2, r3
		if ((regions[i]->start == u_reg_base) &&
    cf1a:	4298      	cmp	r0, r3
	return (MPU->RLAR & MPU_RLAR_LIMIT_Msk) | (~MPU_RLAR_LIMIT_Msk);
    cf1c:	f046 061f 	orr.w	r6, r6, #31
		u32_t reg_last = regions[i]->start + regions[i]->size - 1;
    cf20:	f102 3aff 	add.w	sl, r2, #4294967295
		if ((regions[i]->start == u_reg_base) &&
    cf24:	d118      	bne.n	cf58 <mpu_configure_regions_and_partition.constprop.1+0xb4>
    cf26:	4556      	cmp	r6, sl
    cf28:	d105      	bne.n	cf36 <mpu_configure_regions_and_partition.constprop.1+0x92>
			mpu_configure_region(u_reg_index, regions[i]);
    cf2a:	fa5f f08b 	uxtb.w	r0, fp
    cf2e:	f001 fafb 	bl	e528 <mpu_configure_region>
	for (i = 0; i < regions_num; i++) {
    cf32:	3701      	adds	r7, #1
    cf34:	e7be      	b.n	ceb4 <mpu_configure_regions_and_partition.constprop.1+0x10>
	MPU->RNR = index;
    cf36:	f8c5 b008 	str.w	fp, [r5, #8]
	MPU->RBAR = (MPU->RBAR & (~MPU_RBAR_BASE_Msk))
    cf3a:	68eb      	ldr	r3, [r5, #12]
		| (base & MPU_RBAR_BASE_Msk);
    cf3c:	f022 021f 	bic.w	r2, r2, #31
	MPU->RBAR = (MPU->RBAR & (~MPU_RBAR_BASE_Msk))
    cf40:	f003 031f 	and.w	r3, r3, #31
		| (base & MPU_RBAR_BASE_Msk);
    cf44:	431a      	orrs	r2, r3
	MPU->RBAR = (MPU->RBAR & (~MPU_RBAR_BASE_Msk))
    cf46:	60ea      	str	r2, [r5, #12]
				mpu_configure_region(reg_index, regions[i]);
    cf48:	b2e0      	uxtb	r0, r4
				mpu_configure_region(reg_index, regions[i]);
    cf4a:	f001 faed 	bl	e528 <mpu_configure_region>
			if (reg_index == -EINVAL) {
    cf4e:	f110 0f16 	cmn.w	r0, #22
    cf52:	d0b7      	beq.n	cec4 <mpu_configure_regions_and_partition.constprop.1+0x20>
			reg_index++;
    cf54:	1c44      	adds	r4, r0, #1
    cf56:	e7ec      	b.n	cf32 <mpu_configure_regions_and_partition.constprop.1+0x8e>
	MPU->RNR = index;
    cf58:	f8c5 b008 	str.w	fp, [r5, #8]
	MPU->RLAR = (MPU->RLAR & (~MPU_RLAR_LIMIT_Msk))
    cf5c:	692a      	ldr	r2, [r5, #16]
    cf5e:	3b01      	subs	r3, #1
    cf60:	f023 031f 	bic.w	r3, r3, #31
    cf64:	f002 021f 	and.w	r2, r2, #31
		| (limit & MPU_RLAR_LIMIT_Msk);
    cf68:	4313      	orrs	r3, r2
		} else if (reg_last == u_reg_last) {
    cf6a:	4556      	cmp	r6, sl
    cf6c:	b2e0      	uxtb	r0, r4
	MPU->RLAR = (MPU->RLAR & (~MPU_RLAR_LIMIT_Msk))
    cf6e:	612b      	str	r3, [r5, #16]
		} else if (reg_last == u_reg_last) {
    cf70:	d0eb      	beq.n	cf4a <mpu_configure_regions_and_partition.constprop.1+0xa6>
				mpu_configure_region(reg_index, regions[i]);
    cf72:	f001 fad9 	bl	e528 <mpu_configure_region>
			if (reg_index == -EINVAL) {
    cf76:	f110 0f16 	cmn.w	r0, #22
    cf7a:	d0a3      	beq.n	cec4 <mpu_configure_regions_and_partition.constprop.1+0x20>
	MPU->RNR = index;
    cf7c:	f8c5 b008 	str.w	fp, [r5, #8]
	attr->rbar = MPU->RBAR &
    cf80:	68ea      	ldr	r2, [r5, #12]
    cf82:	f89d 3008 	ldrb.w	r3, [sp, #8]
			REGION_LIMIT_ADDR((regions[i]->start +
    cf86:	3e01      	subs	r6, #1
	attr->rbar = MPU->RBAR &
    cf88:	f362 0304 	bfi	r3, r2, #0, #5
    cf8c:	f88d 3008 	strb.w	r3, [sp, #8]
	attr->mair_idx = (MPU->RLAR & MPU_RLAR_AttrIndx_Msk) >>
    cf90:	692b      	ldr	r3, [r5, #16]
    cf92:	f89d 2008 	ldrb.w	r2, [sp, #8]
    cf96:	085b      	lsrs	r3, r3, #1
    cf98:	f363 1247 	bfi	r2, r3, #5, #3
    cf9c:	f88d 2008 	strb.w	r2, [sp, #8]
			fill_region.base = regions[i]->start +
    cfa0:	f858 2027 	ldr.w	r2, [r8, r7, lsl #2]
			reg_index++;
    cfa4:	3001      	adds	r0, #1
			fill_region.base = regions[i]->start +
    cfa6:	e9d2 3200 	ldrd	r3, r2, [r2]
    cfaa:	4413      	add	r3, r2
    cfac:	9300      	str	r3, [sp, #0]
			REGION_LIMIT_ADDR((regions[i]->start +
    cfae:	f023 031f 	bic.w	r3, r3, #31
    cfb2:	441e      	add	r6, r3
    cfb4:	eba6 060a 	sub.w	r6, r6, sl
    cfb8:	b2c4      	uxtb	r4, r0
    cfba:	f026 061f 	bic.w	r6, r6, #31

static int region_allocate_and_init(const u8_t index,
	const struct arm_mpu_region *region_conf)
{
	/* Attempt to allocate new region index. */
	if (index > (get_num_regions() - 1)) {
    cfbe:	2c0f      	cmp	r4, #15
			fill_region.attr.r_limit =
    cfc0:	9603      	str	r6, [sp, #12]
    cfc2:	f63f af7f 	bhi.w	cec4 <mpu_configure_regions_and_partition.constprop.1+0x20>
	}

	LOG_DBG("Program MPU region at index 0x%x", index);

	/* Program region */
	region_init(index, region_conf);
    cfc6:	4620      	mov	r0, r4
    cfc8:	4669      	mov	r1, sp
    cfca:	f7ff ff53 	bl	ce74 <region_init>
			reg_index++;
    cfce:	3401      	adds	r4, #1
    cfd0:	e7af      	b.n	cf32 <mpu_configure_regions_and_partition.constprop.1+0x8e>
    cfd2:	bf00      	nop
    cfd4:	e000ed90 	.word	0xe000ed90

0000cfd8 <arm_core_mpu_enable>:
void arm_core_mpu_enable(void)
{
	/* Enable MPU and use the default memory map as a
	 * background region for privileged software access.
	 */
	MPU->CTRL = MPU_CTRL_ENABLE_Msk | MPU_CTRL_PRIVDEFENA_Msk;
    cfd8:	2205      	movs	r2, #5
    cfda:	4b03      	ldr	r3, [pc, #12]	; (cfe8 <arm_core_mpu_enable+0x10>)
    cfdc:	605a      	str	r2, [r3, #4]
    cfde:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    cfe2:	f3bf 8f6f 	isb	sy

	/* Make sure that all the registers are set before proceeding */
	__DSB();
	__ISB();
}
    cfe6:	4770      	bx	lr
    cfe8:	e000ed90 	.word	0xe000ed90

0000cfec <arm_core_mpu_disable>:
  \details Ensures the apparent order of the explicit memory operations before
           and after the instruction, without ensuring their completion.
 */
__STATIC_FORCEINLINE void __DMB(void)
{
  __ASM volatile ("dmb 0xF":::"memory");
    cfec:	f3bf 8f5f 	dmb	sy
{
	/* Force any outstanding transfers to complete before disabling MPU */
	__DMB();

	/* Disable MPU */
	MPU->CTRL = 0;
    cff0:	2200      	movs	r2, #0
    cff2:	4b01      	ldr	r3, [pc, #4]	; (cff8 <arm_core_mpu_disable+0xc>)
    cff4:	605a      	str	r2, [r3, #4]
}
    cff6:	4770      	bx	lr
    cff8:	e000ed90 	.word	0xe000ed90

0000cffc <arm_mpu_init>:
 *
 * This function provides the default configuration mechanism for the Memory
 * Protection Unit (MPU).
 */
static int arm_mpu_init(struct device *arg)
{
    cffc:	b570      	push	{r4, r5, r6, lr}
	u32_t r_index;

	if (mpu_config.num_regions > get_num_regions()) {
    cffe:	4d0e      	ldr	r5, [pc, #56]	; (d038 <arm_mpu_init+0x3c>)
    d000:	682e      	ldr	r6, [r5, #0]
    d002:	2e10      	cmp	r6, #16
    d004:	d815      	bhi.n	d032 <arm_mpu_init+0x36>

	/* Architecture-specific configuration */
	mpu_init();

	/* Program fixed regions configured at SOC definition. */
	for (r_index = 0U; r_index < mpu_config.num_regions; r_index++) {
    d006:	2400      	movs	r4, #0
	arm_core_mpu_disable();
    d008:	f7ff fff0 	bl	cfec <arm_core_mpu_disable>
	MPU->MAIR0 =
    d00c:	4b0b      	ldr	r3, [pc, #44]	; (d03c <arm_mpu_init+0x40>)
    d00e:	4a0c      	ldr	r2, [pc, #48]	; (d040 <arm_mpu_init+0x44>)
    d010:	631a      	str	r2, [r3, #48]	; 0x30
	for (r_index = 0U; r_index < mpu_config.num_regions; r_index++) {
    d012:	42a6      	cmp	r6, r4
    d014:	d105      	bne.n	d022 <arm_mpu_init+0x26>
		region_init(r_index, &mpu_config.mpu_regions[r_index]);
	}

	/* Update the number of programmed MPU regions. */
	static_regions_num = mpu_config.num_regions;
    d016:	4b0b      	ldr	r3, [pc, #44]	; (d044 <arm_mpu_init+0x48>)
    d018:	701e      	strb	r6, [r3, #0]


	arm_core_mpu_enable();
    d01a:	f7ff ffdd 	bl	cfd8 <arm_core_mpu_enable>
	__ASSERT(
		(MPU->TYPE & MPU_TYPE_DREGION_Msk) >> MPU_TYPE_DREGION_Pos ==
		DT_NUM_MPU_REGIONS,
		"Invalid number of MPU regions\n");
#endif /* CORTEX_M0PLUS || CPU_CORTEX_M3 || CPU_CORTEX_M4 */
	return 0;
    d01e:	2000      	movs	r0, #0
}
    d020:	bd70      	pop	{r4, r5, r6, pc}
		region_init(r_index, &mpu_config.mpu_regions[r_index]);
    d022:	6869      	ldr	r1, [r5, #4]
    d024:	4620      	mov	r0, r4
    d026:	eb01 1104 	add.w	r1, r1, r4, lsl #4
    d02a:	f7ff ff23 	bl	ce74 <region_init>
	for (r_index = 0U; r_index < mpu_config.num_regions; r_index++) {
    d02e:	3401      	adds	r4, #1
    d030:	e7ef      	b.n	d012 <arm_mpu_init+0x16>
		return -1;
    d032:	f04f 30ff 	mov.w	r0, #4294967295
    d036:	e7f3      	b.n	d020 <arm_mpu_init+0x24>
    d038:	0000ec54 	.word	0x0000ec54
    d03c:	e000ed90 	.word	0xe000ed90
    d040:	0044ffaa 	.word	0x0044ffaa
    d044:	20020174 	.word	0x20020174

0000d048 <arm_core_mpu_configure_static_mpu_regions>:
{
    d048:	b510      	push	{r4, lr}
static int mpu_configure_static_mpu_regions(const struct k_mem_partition
	*static_regions[], const u8_t regions_num,
	const u32_t background_area_base,
	const u32_t background_area_end)
{
	int mpu_reg_index = static_regions_num;
    d04a:	4c03      	ldr	r4, [pc, #12]	; (d058 <arm_core_mpu_configure_static_mpu_regions+0x10>)
	 * given boundaries.
	 */
	ARG_UNUSED(background_area_base);
	ARG_UNUSED(background_area_end);

	mpu_reg_index = mpu_configure_regions_and_partition(static_regions,
    d04c:	7822      	ldrb	r2, [r4, #0]
    d04e:	f7ff ff29 	bl	cea4 <mpu_configure_regions_and_partition.constprop.1>
		regions_num, mpu_reg_index, true);

	static_regions_num = mpu_reg_index;
    d052:	7020      	strb	r0, [r4, #0]
}
    d054:	bd10      	pop	{r4, pc}
    d056:	bf00      	nop
    d058:	20020174 	.word	0x20020174

0000d05c <arm_core_mpu_mark_areas_for_dynamic_regions>:
{
    d05c:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    d060:	4c25      	ldr	r4, [pc, #148]	; (d0f8 <arm_core_mpu_mark_areas_for_dynamic_regions+0x9c>)
    d062:	468a      	mov	sl, r1
{
	/* In ARMv8-M architecture we need to store the index values
	 * and the default configuration of the MPU regions, inside
	 * which dynamic memory regions may be programmed at run-time.
	 */
	for (int i = 0; i < dyn_region_areas_num; i++) {
    d064:	4680      	mov	r8, r0
    d066:	2700      	movs	r7, #0
    d068:	46a1      	mov	r9, r4
	attr->rbar = MPU->RBAR &
    d06a:	f04f 0b14 	mov.w	fp, #20
	MPU->RNR = index;
    d06e:	4d23      	ldr	r5, [pc, #140]	; (d0fc <arm_core_mpu_mark_areas_for_dynamic_regions+0xa0>)
	for (int i = 0; i < dyn_region_areas_num; i++) {
    d070:	4557      	cmp	r7, sl
    d072:	da1a      	bge.n	d0aa <arm_core_mpu_mark_areas_for_dynamic_regions+0x4e>
		if (dyn_region_areas[i].size == 0U) {
    d074:	f8d8 3004 	ldr.w	r3, [r8, #4]
    d078:	9301      	str	r3, [sp, #4]
    d07a:	2b00      	cmp	r3, #0
    d07c:	d036      	beq.n	d0ec <arm_core_mpu_mark_areas_for_dynamic_regions+0x90>
		}
		/* Non-empty area */

		/* Retrieve HW MPU region index */
		dyn_reg_info[i].index =
			get_region_index(dyn_region_areas[i].start,
    d07e:	f8d8 1000 	ldr.w	r1, [r8]
	u32_t region_start_addr = arm_cmse_mpu_region_get(start);
    d082:	4608      	mov	r0, r1
    d084:	9100      	str	r1, [sp, #0]
    d086:	f001 fa71 	bl	e56c <arm_cmse_mpu_region_get>
	u32_t region_end_addr = arm_cmse_mpu_region_get(start + size - 1);
    d08a:	e9dd 1300 	ldrd	r1, r3, [sp]
	u32_t region_start_addr = arm_cmse_mpu_region_get(start);
    d08e:	4606      	mov	r6, r0
	u32_t region_end_addr = arm_cmse_mpu_region_get(start + size - 1);
    d090:	1858      	adds	r0, r3, r1
    d092:	3801      	subs	r0, #1
    d094:	f001 fa6a 	bl	e56c <arm_cmse_mpu_region_get>
	if (region_start_addr == region_end_addr) {
    d098:	4286      	cmp	r6, r0
    d09a:	4a19      	ldr	r2, [pc, #100]	; (d100 <arm_core_mpu_mark_areas_for_dynamic_regions+0xa4>)
    d09c:	d008      	beq.n	d0b0 <arm_core_mpu_mark_areas_for_dynamic_regions+0x54>
		dyn_reg_info[i].index =
    d09e:	2314      	movs	r3, #20
    d0a0:	435f      	muls	r7, r3
    d0a2:	f06f 0315 	mvn.w	r3, #21
    d0a6:	f849 3007 	str.w	r3, [r9, r7]
}
    d0aa:	b003      	add	sp, #12
    d0ac:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
					dyn_region_areas[i].size);

		if (dyn_reg_info[i].index == -EINVAL) {
    d0b0:	f116 0f16 	cmn.w	r6, #22
		dyn_reg_info[i].index =
    d0b4:	6026      	str	r6, [r4, #0]
		if (dyn_reg_info[i].index == -EINVAL) {
    d0b6:	d0f8      	beq.n	d0aa <arm_core_mpu_mark_areas_for_dynamic_regions+0x4e>

			return -EINVAL;
		}

		if (dyn_reg_info[i].index >= static_regions_num) {
    d0b8:	7813      	ldrb	r3, [r2, #0]
    d0ba:	42b3      	cmp	r3, r6
    d0bc:	ddf5      	ble.n	d0aa <arm_core_mpu_mark_areas_for_dynamic_regions+0x4e>
	attr->rbar = MPU->RBAR &
    d0be:	fb0b 9307 	mla	r3, fp, r7, r9
	MPU->RNR = index;
    d0c2:	60ae      	str	r6, [r5, #8]
	MPU->RNR = index;
    d0c4:	60ae      	str	r6, [r5, #8]
	attr->rbar = MPU->RBAR &
    d0c6:	68e8      	ldr	r0, [r5, #12]
    d0c8:	7b19      	ldrb	r1, [r3, #12]
    d0ca:	f360 0104 	bfi	r1, r0, #0, #5
    d0ce:	7319      	strb	r1, [r3, #12]
	attr->mair_idx = (MPU->RLAR & MPU_RLAR_AttrIndx_Msk) >>
    d0d0:	6929      	ldr	r1, [r5, #16]
    d0d2:	7b18      	ldrb	r0, [r3, #12]
    d0d4:	0849      	lsrs	r1, r1, #1
    d0d6:	f361 1047 	bfi	r0, r1, #5, #3
    d0da:	7318      	strb	r0, [r3, #12]
	region_conf->base = (MPU->RBAR & MPU_RBAR_BASE_Msk);
    d0dc:	68eb      	ldr	r3, [r5, #12]
    d0de:	f023 031f 	bic.w	r3, r3, #31
    d0e2:	6063      	str	r3, [r4, #4]
	region_conf->attr.r_limit = MPU->RLAR & MPU_RLAR_LIMIT_Msk;
    d0e4:	692b      	ldr	r3, [r5, #16]
    d0e6:	f023 031f 	bic.w	r3, r3, #31
    d0ea:	6123      	str	r3, [r4, #16]
	for (int i = 0; i < dyn_region_areas_num; i++) {
    d0ec:	3701      	adds	r7, #1
    d0ee:	3414      	adds	r4, #20
    d0f0:	f108 080c 	add.w	r8, r8, #12
    d0f4:	e7bc      	b.n	d070 <arm_core_mpu_mark_areas_for_dynamic_regions+0x14>
    d0f6:	bf00      	nop
    d0f8:	20020028 	.word	0x20020028
    d0fc:	e000ed90 	.word	0xe000ed90
    d100:	20020174 	.word	0x20020174

0000d104 <arm_core_mpu_configure_dynamic_mpu_regions>:
{
    d104:	b570      	push	{r4, r5, r6, lr}
 * performed, the error signal is propagated to the caller of the function.
 */
static int mpu_configure_dynamic_mpu_regions(const struct k_mem_partition
	*dynamic_regions[], u8_t regions_num)
{
	int mpu_reg_index = static_regions_num;
    d106:	4b0c      	ldr	r3, [pc, #48]	; (d138 <arm_core_mpu_configure_dynamic_mpu_regions+0x34>)
    d108:	460e      	mov	r6, r1
    d10a:	781c      	ldrb	r4, [r3, #0]
    d10c:	4605      	mov	r5, r0
    d10e:	4623      	mov	r3, r4
  mpu->RLAR = 0U;
    d110:	2100      	movs	r1, #0
  mpu->RNR = rnr;
    d112:	4a0a      	ldr	r2, [pc, #40]	; (d13c <arm_core_mpu_configure_dynamic_mpu_regions+0x38>)

	/* Disable all MPU regions except for the static ones. */
	for (int i = mpu_reg_index; i < get_num_regions(); i++) {
    d114:	2b0f      	cmp	r3, #15
    d116:	dd0b      	ble.n	d130 <arm_core_mpu_configure_dynamic_mpu_regions+0x2c>
#if defined(CONFIG_MPU_GAP_FILLING)
	/* Reset MPU regions inside which dynamic memory regions may
	 * be programmed.
	 */
	for (int i = 0; i < MPU_DYNAMIC_REGION_AREAS_NUM; i++) {
		region_init(dyn_reg_info[i].index,
    d118:	4909      	ldr	r1, [pc, #36]	; (d140 <arm_core_mpu_configure_dynamic_mpu_regions+0x3c>)
    d11a:	f851 0b04 	ldr.w	r0, [r1], #4
    d11e:	f7ff fea9 	bl	ce74 <region_init>

	/* In ARMv8-M architecture the dynamic regions are programmed on SRAM,
	 * forming a full partition of the background area, specified by the
	 * given boundaries.
	 */
	mpu_reg_index = mpu_configure_regions_and_partition(dynamic_regions,
    d122:	4622      	mov	r2, r4
    d124:	4631      	mov	r1, r6
    d126:	4628      	mov	r0, r5
}
    d128:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    d12c:	f7ff beba 	b.w	cea4 <mpu_configure_regions_and_partition.constprop.1>
    d130:	6093      	str	r3, [r2, #8]
  mpu->RLAR = 0U;
    d132:	6111      	str	r1, [r2, #16]
	for (int i = mpu_reg_index; i < get_num_regions(); i++) {
    d134:	3301      	adds	r3, #1
    d136:	e7ed      	b.n	d114 <arm_core_mpu_configure_dynamic_mpu_regions+0x10>
    d138:	20020174 	.word	0x20020174
    d13c:	e000ed90 	.word	0xe000ed90
    d140:	20020028 	.word	0x20020028

0000d144 <__stdout_hook_install>:

static int (*_stdout_hook)(int) = _stdout_hook_default;

void __stdout_hook_install(int (*hook)(int))
{
	_stdout_hook = hook;
    d144:	4b01      	ldr	r3, [pc, #4]	; (d14c <__stdout_hook_install+0x8>)
    d146:	6018      	str	r0, [r3, #0]
}
    d148:	4770      	bx	lr
    d14a:	bf00      	nop
    d14c:	20020ebc 	.word	0x20020ebc

0000d150 <gpio_nrfx_init>:
#endif
	}
}

static int gpio_nrfx_init(struct device *port)
{
    d150:	b508      	push	{r3, lr}
	static bool gpio_initialized;

	if (!gpio_initialized) {
    d152:	4b09      	ldr	r3, [pc, #36]	; (d178 <gpio_nrfx_init+0x28>)
    d154:	781a      	ldrb	r2, [r3, #0]
    d156:	b96a      	cbnz	r2, d174 <gpio_nrfx_init+0x24>
		gpio_initialized = true;
    d158:	2101      	movs	r1, #1
		IRQ_CONNECT(DT_NORDIC_NRF_GPIOTE_GPIOTE_0_IRQ_0,
    d15a:	2031      	movs	r0, #49	; 0x31
		gpio_initialized = true;
    d15c:	7019      	strb	r1, [r3, #0]
		IRQ_CONNECT(DT_NORDIC_NRF_GPIOTE_GPIOTE_0_IRQ_0,
    d15e:	2105      	movs	r1, #5
    d160:	f7ff fcc4 	bl	caec <z_arm_irq_priority_set>
			    DT_NORDIC_NRF_GPIOTE_GPIOTE_0_IRQ_0_PRIORITY,
			    gpiote_event_handler, NULL, 0);

		irq_enable(DT_NORDIC_NRF_GPIOTE_GPIOTE_0_IRQ_0);
    d164:	2031      	movs	r0, #49	; 0x31
    d166:	f7ff fcb1 	bl	cacc <arch_irq_enable>
    return ((uint32_t)p_reg + event);
}

NRF_STATIC_INLINE void nrf_gpiote_int_enable(NRF_GPIOTE_Type * p_reg, uint32_t mask)
{
    p_reg->INTENSET = mask;
    d16a:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
    d16e:	4b03      	ldr	r3, [pc, #12]	; (d17c <gpio_nrfx_init+0x2c>)
    d170:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
		nrf_gpiote_int_enable(NRF_GPIOTE, NRF_GPIOTE_INT_PORT_MASK);
	}

	return 0;
}
    d174:	2000      	movs	r0, #0
    d176:	bd08      	pop	{r3, pc}
    d178:	20020175 	.word	0x20020175
    d17c:	40031000 	.word	0x40031000

0000d180 <gpiote_pin_int_cfg>:
{
    d180:	b570      	push	{r4, r5, r6, lr}
	return port->config->config_info;
    d182:	6803      	ldr	r3, [r0, #0]
	struct gpio_nrfx_data *data = get_port_data(port);
    d184:	6882      	ldr	r2, [r0, #8]
	u32_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
    d186:	689b      	ldr	r3, [r3, #8]
    p_reg->INTENCLR = mask;
}

NRF_STATIC_INLINE uint32_t nrf_gpiote_int_enable_check(NRF_GPIOTE_Type const * p_reg, uint32_t mask)
{
    return p_reg->INTENSET & mask;
    d188:	4c51      	ldr	r4, [pc, #324]	; (d2d0 <gpiote_pin_int_cfg+0x150>)
    d18a:	7918      	ldrb	r0, [r3, #4]
    d18c:	f001 031f 	and.w	r3, r1, #31
    d190:	ea43 1340 	orr.w	r3, r3, r0, lsl #5
	for (size_t i = 0; i < GPIOTE_CH_NUM; i++) {
    d194:	2000      	movs	r0, #0
    d196:	f8d4 5304 	ldr.w	r5, [r4, #772]	; 0x304
    d19a:	b2ed      	uxtb	r5, r5
                        ((polarity << GPIOTE_CONFIG_POLARITY_Pos) & GPIOTE_CONFIG_POLARITY_Msk);
}

NRF_STATIC_INLINE uint32_t nrf_gpiote_event_pin_get(NRF_GPIOTE_Type const * p_reg, uint32_t idx)
{
    return ((p_reg->CONFIG[idx] & GPIOTE_CONFIG_PORT_PIN_Msk) >> GPIOTE_CONFIG_PSEL_Pos);
    d19c:	f500 76a2 	add.w	r6, r0, #324	; 0x144
    d1a0:	f854 6026 	ldr.w	r6, [r4, r6, lsl #2]
    d1a4:	f3c6 2604 	ubfx	r6, r6, #8, #5
		if ((nrf_gpiote_event_pin_get(NRF_GPIOTE, i) == abs_pin)
    d1a8:	42b3      	cmp	r3, r6
    d1aa:	d170      	bne.n	d28e <gpiote_pin_int_cfg+0x10e>
		    && (intenset & BIT(i))) {
    d1ac:	fa25 f600 	lsr.w	r6, r5, r0
    d1b0:	07f6      	lsls	r6, r6, #31
    d1b2:	d56c      	bpl.n	d28e <gpiote_pin_int_cfg+0x10e>
   p_reg->CONFIG[idx] &= ~GPIOTE_CONFIG_MODE_Event;
    d1b4:	0085      	lsls	r5, r0, #2
    d1b6:	f105 4580 	add.w	r5, r5, #1073741824	; 0x40000000
    d1ba:	f505 3544 	add.w	r5, r5, #200704	; 0x31000
    d1be:	f8d5 6510 	ldr.w	r6, [r5, #1296]	; 0x510
    d1c2:	f026 0601 	bic.w	r6, r6, #1
    d1c6:	f8c5 6510 	str.w	r6, [r5, #1296]	; 0x510
			nrf_gpiote_int_disable(NRF_GPIOTE, BIT(i));
    d1ca:	2501      	movs	r5, #1
    d1cc:	fa05 f000 	lsl.w	r0, r5, r0
    p_reg->INTENCLR = mask;
    d1d0:	f8c4 0308 	str.w	r0, [r4, #776]	; 0x308
NRF_STATIC_INLINE void nrf_gpio_cfg_sense_set(uint32_t             pin_number,
                                              nrf_gpio_pin_sense_t sense_config)
{
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
    /*lint -e{845} // A zero has been given as right argument to operator '|'" */
    uint32_t cnf = reg->PIN_CNF[pin_number] & ~GPIO_PIN_CNF_SENSE_Msk;
    d1d4:	4d3f      	ldr	r5, [pc, #252]	; (d2d4 <gpiote_pin_int_cfg+0x154>)
    d1d6:	eb05 0583 	add.w	r5, r5, r3, lsl #2
    d1da:	f8d5 0200 	ldr.w	r0, [r5, #512]	; 0x200
    d1de:	f420 3040 	bic.w	r0, r0, #196608	; 0x30000

    reg->PIN_CNF[pin_number] = cnf | (sense_config << GPIO_PIN_CNF_SENSE_Pos);
    d1e2:	f8c5 0200 	str.w	r0, [r5, #512]	; 0x200
	if ((data->pin_int_en & BIT(pin)) && (data->int_en & BIT(pin))) {
    d1e6:	6890      	ldr	r0, [r2, #8]
    d1e8:	40c8      	lsrs	r0, r1
    d1ea:	f010 0001 	ands.w	r0, r0, #1
    d1ee:	d04d      	beq.n	d28c <gpiote_pin_int_cfg+0x10c>
    d1f0:	68d0      	ldr	r0, [r2, #12]
    d1f2:	40c8      	lsrs	r0, r1
    d1f4:	f010 0001 	ands.w	r0, r0, #1
    d1f8:	d048      	beq.n	d28c <gpiote_pin_int_cfg+0x10c>
		if (data->trig_edge & BIT(pin)) {
    d1fa:	6950      	ldr	r0, [r2, #20]
    d1fc:	40c8      	lsrs	r0, r1
    d1fe:	f010 0001 	ands.w	r0, r0, #1
    d202:	d050      	beq.n	d2a6 <gpiote_pin_int_cfg+0x126>
			if (data->double_edge & BIT(pin)) {
    d204:	6990      	ldr	r0, [r2, #24]
    d206:	40c8      	lsrs	r0, r1
    d208:	07c0      	lsls	r0, r0, #31
    d20a:	d444      	bmi.n	d296 <gpiote_pin_int_cfg+0x116>
			} else if (((data->active_level & BIT(pin)) != 0U)
    d20c:	6910      	ldr	r0, [r2, #16]
				   ^ ((BIT(pin) & data->inverted) != 0)) {
    d20e:	69d2      	ldr	r2, [r2, #28]
			} else if (((data->active_level & BIT(pin)) != 0U)
    d210:	40c8      	lsrs	r0, r1
				   ^ ((BIT(pin) & data->inverted) != 0)) {
    d212:	fa22 f101 	lsr.w	r1, r2, r1
			} else if (((data->active_level & BIT(pin)) != 0U)
    d216:	f000 0001 	and.w	r0, r0, #1
    d21a:	f001 0101 	and.w	r1, r1, #1
				pol = NRF_GPIOTE_POLARITY_HITOLO;
    d21e:	4288      	cmp	r0, r1
    d220:	bf14      	ite	ne
    d222:	2101      	movne	r1, #1
    d224:	2102      	moveq	r1, #2
    d226:	2500      	movs	r5, #0
    p_reg->CONFIG[idx] = 0;
}

NRF_STATIC_INLINE bool nrf_gpiote_te_is_enabled(NRF_GPIOTE_Type const * p_reg, uint32_t idx)
{
    return (p_reg->CONFIG[idx] & GPIOTE_CONFIG_MODE_Msk) != GPIOTE_CONFIG_MODE_Disabled;
    d228:	f505 72a2 	add.w	r2, r5, #324	; 0x144
    d22c:	f854 0022 	ldr.w	r0, [r4, r2, lsl #2]
		if (!nrf_gpiote_te_is_enabled(NRF_GPIOTE, channel)) {
    d230:	f010 0003 	ands.w	r0, r0, #3
    d234:	d131      	bne.n	d29a <gpiote_pin_int_cfg+0x11a>
  p_reg->CONFIG[idx] &= ~(GPIOTE_CONFIG_PORT_PIN_Msk | GPIOTE_CONFIG_POLARITY_Msk);
    d236:	00aa      	lsls	r2, r5, #2
    d238:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
    d23c:	f502 3244 	add.w	r2, r2, #200704	; 0x31000
    d240:	f8d2 6510 	ldr.w	r6, [r2, #1296]	; 0x510
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
    d244:	021b      	lsls	r3, r3, #8
    d246:	f403 53f8 	and.w	r3, r3, #7936	; 0x1f00
  p_reg->CONFIG[idx] &= ~(GPIOTE_CONFIG_PORT_PIN_Msk | GPIOTE_CONFIG_POLARITY_Msk);
    d24a:	f426 3647 	bic.w	r6, r6, #203776	; 0x31c00
    d24e:	f426 7640 	bic.w	r6, r6, #768	; 0x300
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
    d252:	ea43 4101 	orr.w	r1, r3, r1, lsl #16
			nrf_gpiote_event_t evt =
    d256:	f105 0340 	add.w	r3, r5, #64	; 0x40
  p_reg->CONFIG[idx] &= ~(GPIOTE_CONFIG_PORT_PIN_Msk | GPIOTE_CONFIG_POLARITY_Msk);
    d25a:	f8c2 6510 	str.w	r6, [r2, #1296]	; 0x510
    d25e:	009b      	lsls	r3, r3, #2
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
    d260:	f8d2 6510 	ldr.w	r6, [r2, #1296]	; 0x510
    return ((uint32_t)p_reg + event);
    d264:	b29b      	uxth	r3, r3
    d266:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
    d26a:	f503 3344 	add.w	r3, r3, #200704	; 0x31000
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
    d26e:	4331      	orrs	r1, r6
    d270:	f8c2 1510 	str.w	r1, [r2, #1296]	; 0x510
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
    d274:	6018      	str	r0, [r3, #0]
   p_reg->CONFIG[idx] |= GPIOTE_CONFIG_MODE_Event;
    d276:	f8d2 3510 	ldr.w	r3, [r2, #1296]	; 0x510
    d27a:	f043 0301 	orr.w	r3, r3, #1
    d27e:	f8c2 3510 	str.w	r3, [r2, #1296]	; 0x510
			nrf_gpiote_int_enable(NRF_GPIOTE, BIT(channel));
    d282:	2301      	movs	r3, #1
    d284:	fa03 f505 	lsl.w	r5, r3, r5
    p_reg->INTENSET = mask;
    d288:	f8c4 5304 	str.w	r5, [r4, #772]	; 0x304
}
    d28c:	bd70      	pop	{r4, r5, r6, pc}
	for (size_t i = 0; i < GPIOTE_CH_NUM; i++) {
    d28e:	3001      	adds	r0, #1
    d290:	2808      	cmp	r0, #8
    d292:	d183      	bne.n	d19c <gpiote_pin_int_cfg+0x1c>
    d294:	e79e      	b.n	d1d4 <gpiote_pin_int_cfg+0x54>
				pol = NRF_GPIOTE_POLARITY_TOGGLE;
    d296:	2103      	movs	r1, #3
    d298:	e7c5      	b.n	d226 <gpiote_pin_int_cfg+0xa6>
    d29a:	3501      	adds	r5, #1
	for (u8_t channel = 0; channel < GPIOTE_CH_NUM; ++channel) {
    d29c:	2d08      	cmp	r5, #8
    d29e:	d1c3      	bne.n	d228 <gpiote_pin_int_cfg+0xa8>
	return -ENODEV;
    d2a0:	f06f 0012 	mvn.w	r0, #18
    d2a4:	e7f2      	b.n	d28c <gpiote_pin_int_cfg+0x10c>
	if ((BIT(pin) & (data->active_level ^ data->inverted)) != 0) {
    d2a6:	6913      	ldr	r3, [r2, #16]
    d2a8:	69d2      	ldr	r2, [r2, #28]
    d2aa:	4053      	eors	r3, r2
    d2ac:	fa23 f101 	lsr.w	r1, r3, r1
		return NRF_GPIO_PIN_SENSE_HIGH;
    d2b0:	f011 0f01 	tst.w	r1, #1
    d2b4:	bf14      	ite	ne
    d2b6:	f44f 3200 	movne.w	r2, #131072	; 0x20000
    d2ba:	f44f 3240 	moveq.w	r2, #196608	; 0x30000
    uint32_t cnf = reg->PIN_CNF[pin_number] & ~GPIO_PIN_CNF_SENSE_Msk;
    d2be:	f8d5 3200 	ldr.w	r3, [r5, #512]	; 0x200
    d2c2:	f423 3340 	bic.w	r3, r3, #196608	; 0x30000
    reg->PIN_CNF[pin_number] = cnf | (sense_config << GPIO_PIN_CNF_SENSE_Pos);
    d2c6:	4313      	orrs	r3, r2
    d2c8:	f8c5 3200 	str.w	r3, [r5, #512]	; 0x200
    d2cc:	e7de      	b.n	d28c <gpiote_pin_int_cfg+0x10c>
    d2ce:	bf00      	nop
    d2d0:	40031000 	.word	0x40031000
    d2d4:	40842500 	.word	0x40842500

0000d2d8 <gpio_nrfx_config>:
{
    d2d8:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    d2dc:	4680      	mov	r8, r0
	struct gpio_nrfx_data *data = get_port_data(port);
    d2de:	6885      	ldr	r5, [r0, #8]
	switch (flags & (GPIO_DS_LOW_MASK | GPIO_DS_HIGH_MASK)) {
    d2e0:	f403 4070 	and.w	r0, r3, #61440	; 0xf000
    d2e4:	f5b0 4f80 	cmp.w	r0, #16384	; 0x4000
{
    d2e8:	461e      	mov	r6, r3
	switch (flags & (GPIO_DS_LOW_MASK | GPIO_DS_HIGH_MASK)) {
    d2ea:	d040      	beq.n	d36e <gpio_nrfx_config+0x96>
    d2ec:	dc09      	bgt.n	d302 <gpio_nrfx_config+0x2a>
    d2ee:	f5b0 5f80 	cmp.w	r0, #4096	; 0x1000
    d2f2:	d03e      	beq.n	d372 <gpio_nrfx_config+0x9a>
    d2f4:	f5b0 5f40 	cmp.w	r0, #12288	; 0x3000
    d2f8:	d03d      	beq.n	d376 <gpio_nrfx_config+0x9e>
    d2fa:	b190      	cbz	r0, d322 <gpio_nrfx_config+0x4a>
		return -EINVAL;
    d2fc:	f06f 0015 	mvn.w	r0, #21
    d300:	e032      	b.n	d368 <gpio_nrfx_config+0x90>
	switch (flags & (GPIO_DS_LOW_MASK | GPIO_DS_HIGH_MASK)) {
    d302:	f5b0 4fe0 	cmp.w	r0, #28672	; 0x7000
    d306:	d038      	beq.n	d37a <gpio_nrfx_config+0xa2>
    d308:	dc04      	bgt.n	d314 <gpio_nrfx_config+0x3c>
    d30a:	f5b0 4fa0 	cmp.w	r0, #20480	; 0x5000
    d30e:	d1f5      	bne.n	d2fc <gpio_nrfx_config+0x24>
		drive = NRF_GPIO_PIN_H0H1;
    d310:	2003      	movs	r0, #3
    d312:	e006      	b.n	d322 <gpio_nrfx_config+0x4a>
	switch (flags & (GPIO_DS_LOW_MASK | GPIO_DS_HIGH_MASK)) {
    d314:	f5b0 4f40 	cmp.w	r0, #49152	; 0xc000
    d318:	d031      	beq.n	d37e <gpio_nrfx_config+0xa6>
    d31a:	f5b0 4f50 	cmp.w	r0, #53248	; 0xd000
    d31e:	d1ed      	bne.n	d2fc <gpio_nrfx_config+0x24>
		drive = NRF_GPIO_PIN_H0D1;
    d320:	2007      	movs	r0, #7
	if ((flags & GPIO_PUD_MASK) == GPIO_PUD_PULL_UP) {
    d322:	f406 7740 	and.w	r7, r6, #768	; 0x300
    d326:	f5b7 7f80 	cmp.w	r7, #256	; 0x100
    d32a:	d02a      	beq.n	d382 <gpio_nrfx_config+0xaa>
		pull = NRF_GPIO_PIN_NOPULL;
    d32c:	f5a7 7400 	sub.w	r4, r7, #512	; 0x200
    d330:	4263      	negs	r3, r4
    d332:	4163      	adcs	r3, r4
	if (access_op == GPIO_ACCESS_BY_PORT) {
    d334:	2901      	cmp	r1, #1
		from_pin = pin;
    d336:	bf19      	ittee	ne
    d338:	b2d4      	uxtbne	r4, r2
		to_pin   = pin;
    d33a:	46a1      	movne	r9, r4
		to_pin   = 31U;
    d33c:	f04f 091f 	moveq.w	r9, #31
		from_pin = 0U;
    d340:	2400      	moveq	r4, #0
    d342:	f04f 0b01 	mov.w	fp, #1
	dir = ((flags & GPIO_DIR_MASK) == GPIO_DIR_OUT)
    d346:	f006 0c01 	and.w	ip, r6, #1
                               | ((uint32_t)input << GPIO_PIN_CNF_INPUT_Pos)
    d34a:	ea4f 074c 	mov.w	r7, ip, lsl #1
                               | ((uint32_t)drive << GPIO_PIN_CNF_DRIVE_Pos)
    d34e:	ea47 070c 	orr.w	r7, r7, ip
    d352:	ea47 2000 	orr.w	r0, r7, r0, lsl #8
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
    d356:	f8df a0a0 	ldr.w	sl, [pc, #160]	; d3f8 <gpio_nrfx_config+0x120>
                               | ((uint32_t)drive << GPIO_PIN_CNF_DRIVE_Pos)
    d35a:	ea40 0783 	orr.w	r7, r0, r3, lsl #2
		WRITE_BIT(data->pin_int_en, curr_pin, flags & GPIO_INT);
    d35e:	f006 0302 	and.w	r3, r6, #2
	for (u8_t curr_pin = from_pin; curr_pin <= to_pin; ++curr_pin) {
    d362:	45a1      	cmp	r9, r4
    d364:	d20f      	bcs.n	d386 <gpio_nrfx_config+0xae>
	return 0;
    d366:	2000      	movs	r0, #0
}
    d368:	b003      	add	sp, #12
    d36a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		drive = NRF_GPIO_PIN_S0H1;
    d36e:	2002      	movs	r0, #2
    d370:	e7d7      	b.n	d322 <gpio_nrfx_config+0x4a>
		drive = NRF_GPIO_PIN_H0S1;
    d372:	2001      	movs	r0, #1
    d374:	e7d5      	b.n	d322 <gpio_nrfx_config+0x4a>
		drive = NRF_GPIO_PIN_D0S1;
    d376:	2004      	movs	r0, #4
    d378:	e7d3      	b.n	d322 <gpio_nrfx_config+0x4a>
		drive = NRF_GPIO_PIN_D0H1;
    d37a:	2005      	movs	r0, #5
    d37c:	e7d1      	b.n	d322 <gpio_nrfx_config+0x4a>
		drive = NRF_GPIO_PIN_S0D1;
    d37e:	2006      	movs	r0, #6
    d380:	e7cf      	b.n	d322 <gpio_nrfx_config+0x4a>
		pull = NRF_GPIO_PIN_PULLUP;
    d382:	2303      	movs	r3, #3
    d384:	e7d6      	b.n	d334 <gpio_nrfx_config+0x5c>
	return port->config->config_info;
    d386:	f8d8 2000 	ldr.w	r2, [r8]
		nrf_gpio_cfg(NRF_GPIO_PIN_MAP(get_port_cfg(port)->port_num,
    d38a:	6892      	ldr	r2, [r2, #8]
    d38c:	7911      	ldrb	r1, [r2, #4]
    d38e:	f004 021f 	and.w	r2, r4, #31
    d392:	ea42 1241 	orr.w	r2, r2, r1, lsl #5
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
    d396:	3280      	adds	r2, #128	; 0x80
    d398:	f84a 7022 	str.w	r7, [sl, r2, lsl #2]
		WRITE_BIT(data->pin_int_en, curr_pin, flags & GPIO_INT);
    d39c:	68a9      	ldr	r1, [r5, #8]
    d39e:	fa0b f204 	lsl.w	r2, fp, r4
    d3a2:	2b00      	cmp	r3, #0
    d3a4:	d025      	beq.n	d3f2 <gpio_nrfx_config+0x11a>
    d3a6:	4311      	orrs	r1, r2
    d3a8:	60a9      	str	r1, [r5, #8]
		WRITE_BIT(data->trig_edge, curr_pin, flags & GPIO_INT_EDGE);
    d3aa:	6969      	ldr	r1, [r5, #20]
    d3ac:	06b0      	lsls	r0, r6, #26
    d3ae:	bf4c      	ite	mi
    d3b0:	4311      	orrmi	r1, r2
    d3b2:	4391      	bicpl	r1, r2
    d3b4:	6169      	str	r1, [r5, #20]
		WRITE_BIT(data->double_edge, curr_pin,
    d3b6:	69a9      	ldr	r1, [r5, #24]
    d3b8:	0670      	lsls	r0, r6, #25
    d3ba:	bf4c      	ite	mi
    d3bc:	4311      	orrmi	r1, r2
    d3be:	4391      	bicpl	r1, r2
    d3c0:	61a9      	str	r1, [r5, #24]
		WRITE_BIT(data->active_level, curr_pin,
    d3c2:	6929      	ldr	r1, [r5, #16]
    d3c4:	0770      	lsls	r0, r6, #29
    d3c6:	bf4c      	ite	mi
    d3c8:	4311      	orrmi	r1, r2
    d3ca:	4391      	bicpl	r1, r2
    d3cc:	6129      	str	r1, [r5, #16]
		WRITE_BIT(data->inverted, curr_pin, flags & GPIO_POL_INV);
    d3ce:	69e9      	ldr	r1, [r5, #28]
    d3d0:	0630      	lsls	r0, r6, #24
    d3d2:	bf4c      	ite	mi
    d3d4:	430a      	orrmi	r2, r1
    d3d6:	ea21 0202 	bicpl.w	r2, r1, r2
    d3da:	61ea      	str	r2, [r5, #28]
		res = gpiote_pin_int_cfg(port, curr_pin);
    d3dc:	4621      	mov	r1, r4
    d3de:	4640      	mov	r0, r8
    d3e0:	9301      	str	r3, [sp, #4]
    d3e2:	f7ff fecd 	bl	d180 <gpiote_pin_int_cfg>
		if (res != 0) {
    d3e6:	2800      	cmp	r0, #0
    d3e8:	d1be      	bne.n	d368 <gpio_nrfx_config+0x90>
	for (u8_t curr_pin = from_pin; curr_pin <= to_pin; ++curr_pin) {
    d3ea:	3401      	adds	r4, #1
    d3ec:	b2e4      	uxtb	r4, r4
    d3ee:	9b01      	ldr	r3, [sp, #4]
    d3f0:	e7b7      	b.n	d362 <gpio_nrfx_config+0x8a>
		WRITE_BIT(data->pin_int_en, curr_pin, flags & GPIO_INT);
    d3f2:	ea21 0102 	bic.w	r1, r1, r2
    d3f6:	e7d7      	b.n	d3a8 <gpio_nrfx_config+0xd0>
    d3f8:	40842500 	.word	0x40842500

0000d3fc <gpiote_event_handler>:
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    d3fc:	494f      	ldr	r1, [pc, #316]	; (d53c <gpiote_event_handler+0x140>)
{
    d3fe:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    d402:	680d      	ldr	r5, [r1, #0]
	if (port_event) {
    d404:	2d00      	cmp	r5, #0
    d406:	d060      	beq.n	d4ca <gpiote_event_handler+0xce>
	struct gpio_nrfx_data *data = get_port_data(port);
    d408:	4b4d      	ldr	r3, [pc, #308]	; (d540 <gpiote_event_handler+0x144>)
	u32_t pin = 0U;
    d40a:	2600      	movs	r6, #0
	struct gpio_nrfx_data *data = get_port_data(port);
    d40c:	689a      	ldr	r2, [r3, #8]
	return port->config->config_info;
    d40e:	681b      	ldr	r3, [r3, #0]
    d410:	f8df e138 	ldr.w	lr, [pc, #312]	; d54c <gpiote_event_handler+0x150>
    d414:	689f      	ldr	r7, [r3, #8]
	u32_t out = data->int_en & data->pin_int_en;
    d416:	e9d2 0302 	ldrd	r0, r3, [r2, #8]
    d41a:	4003      	ands	r3, r0
	out &= ~data->trig_edge & ~data->double_edge;
    d41c:	e9d2 0405 	ldrd	r0, r4, [r2, #20]
    d420:	4320      	orrs	r0, r4
    d422:	ea23 0300 	bic.w	r3, r3, r0
	u32_t port_in = nrf_gpio_port_in_read(cfg->port);
    d426:	6838      	ldr	r0, [r7, #0]
	u32_t pin_states = ~(port_in ^ data->inverted ^ data->active_level);
    d428:	69d4      	ldr	r4, [r2, #28]
    d42a:	6912      	ldr	r2, [r2, #16]
}


NRF_STATIC_INLINE uint32_t nrf_gpio_port_in_read(NRF_GPIO_Type const * p_reg)
{
    return p_reg->IN;
    d42c:	6900      	ldr	r0, [r0, #16]
    d42e:	4054      	eors	r4, r2
    d430:	4044      	eors	r4, r0
	u32_t bit = 1U << pin;
    d432:	2001      	movs	r0, #1
	u32_t out = pin_states & level_pins;
    d434:	ea23 0404 	bic.w	r4, r3, r4
	while (level_pins) {
    d438:	bb93      	cbnz	r3, d4a0 <gpiote_event_handler+0xa4>
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
    d43a:	600b      	str	r3, [r1, #0]
	u32_t fired_triggers[GPIO_COUNT] = {0};
    d43c:	2300      	movs	r3, #0
		if (nrf_gpiote_int_enable_check(NRF_GPIOTE, BIT(i)) &&
    d43e:	2001      	movs	r0, #1
    d440:	461f      	mov	r7, r3
    return p_reg->INTENSET & mask;
    d442:	4940      	ldr	r1, [pc, #256]	; (d544 <gpiote_event_handler+0x148>)
    d444:	4e40      	ldr	r6, [pc, #256]	; (d548 <gpiote_event_handler+0x14c>)
    d446:	f8d1 2304 	ldr.w	r2, [r1, #772]	; 0x304
    d44a:	fa00 fc03 	lsl.w	ip, r0, r3
    d44e:	ea1c 0f02 	tst.w	ip, r2
    d452:	d00d      	beq.n	d470 <gpiote_event_handler+0x74>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    d454:	f856 2023 	ldr.w	r2, [r6, r3, lsl #2]
    d458:	b152      	cbz	r2, d470 <gpiote_event_handler+0x74>
    return ((p_reg->CONFIG[idx] & GPIOTE_CONFIG_PORT_PIN_Msk) >> GPIOTE_CONFIG_PSEL_Pos);
    d45a:	f503 72a2 	add.w	r2, r3, #324	; 0x144
    d45e:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
    d462:	f846 7023 	str.w	r7, [r6, r3, lsl #2]
    return ((p_reg->CONFIG[idx] & GPIOTE_CONFIG_PORT_PIN_Msk) >> GPIOTE_CONFIG_PSEL_Pos);
    d466:	f3c2 2204 	ubfx	r2, r2, #8, #5
			fired_triggers[abs_pin / 32U] |= BIT(abs_pin % 32);
    d46a:	fa00 f202 	lsl.w	r2, r0, r2
    d46e:	4314      	orrs	r4, r2
	for (size_t i = 0; i < GPIOTE_CH_NUM; i++) {
    d470:	3301      	adds	r3, #1
    d472:	2b08      	cmp	r3, #8
    d474:	d1e7      	bne.n	d446 <gpiote_event_handler+0x4a>
	if (fired_triggers[0]) {
    d476:	bb54      	cbnz	r4, d4ce <gpiote_event_handler+0xd2>
	if (port_event) {
    d478:	b185      	cbz	r5, d49c <gpiote_event_handler+0xa0>
	u32_t bit = 1U << pin;
    d47a:	2401      	movs	r4, #1
	u32_t pin = 0U;
    d47c:	2500      	movs	r5, #0
	const struct gpio_nrfx_data *data = get_port_data(port);
    d47e:	4b30      	ldr	r3, [pc, #192]	; (d540 <gpiote_event_handler+0x144>)
    d480:	f8df c0c8 	ldr.w	ip, [pc, #200]	; d54c <gpiote_event_handler+0x150>
    d484:	689a      	ldr	r2, [r3, #8]
	return port->config->config_info;
    d486:	681b      	ldr	r3, [r3, #0]
    d488:	689e      	ldr	r6, [r3, #8]
	u32_t out = data->int_en & data->pin_int_en;
    d48a:	e9d2 1302 	ldrd	r1, r3, [r2, #8]
    d48e:	400b      	ands	r3, r1
	out &= ~data->trig_edge & ~data->double_edge;
    d490:	e9d2 1005 	ldrd	r1, r0, [r2, #20]
    d494:	4301      	orrs	r1, r0
    d496:	ea23 0301 	bic.w	r3, r3, r1
	while (level_pins) {
    d49a:	bb7b      	cbnz	r3, d4fc <gpiote_event_handler+0x100>
}
    d49c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if (level_pins & bit) {
    d4a0:	4203      	tst	r3, r0
    d4a2:	d00f      	beq.n	d4c4 <gpiote_event_handler+0xc8>
			u32_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
    d4a4:	f897 c004 	ldrb.w	ip, [r7, #4]
    d4a8:	f006 021f 	and.w	r2, r6, #31
    d4ac:	ea42 124c 	orr.w	r2, r2, ip, lsl #5
    d4b0:	eb0e 0282 	add.w	r2, lr, r2, lsl #2
    uint32_t cnf = reg->PIN_CNF[pin_number] & ~GPIO_PIN_CNF_SENSE_Msk;
    d4b4:	f8d2 c200 	ldr.w	ip, [r2, #512]	; 0x200
			level_pins &= ~bit;
    d4b8:	ea23 0300 	bic.w	r3, r3, r0
    d4bc:	f42c 3c40 	bic.w	ip, ip, #196608	; 0x30000
    reg->PIN_CNF[pin_number] = cnf | (sense_config << GPIO_PIN_CNF_SENSE_Pos);
    d4c0:	f8c2 c200 	str.w	ip, [r2, #512]	; 0x200
		++pin;
    d4c4:	3601      	adds	r6, #1
		bit <<= 1;
    d4c6:	0040      	lsls	r0, r0, #1
    d4c8:	e7b6      	b.n	d438 <gpiote_event_handler+0x3c>
	u32_t fired_triggers[GPIO_COUNT] = {0};
    d4ca:	462c      	mov	r4, r5
    d4cc:	e7b6      	b.n	d43c <gpiote_event_handler+0x40>
	struct gpio_nrfx_data *data = get_port_data(port);
    d4ce:	4f1c      	ldr	r7, [pc, #112]	; (d540 <gpiote_event_handler+0x144>)
    d4d0:	f8d7 8008 	ldr.w	r8, [r7, #8]
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
    d4d4:	f8d8 1000 	ldr.w	r1, [r8]
    d4d8:	2900      	cmp	r1, #0
    d4da:	d0cd      	beq.n	d478 <gpiote_event_handler+0x7c>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
    d4dc:	680e      	ldr	r6, [r1, #0]
		if ((cb->pin_mask & pins) & data->int_en) {
    d4de:	f8d8 300c 	ldr.w	r3, [r8, #12]
    d4e2:	688a      	ldr	r2, [r1, #8]
    d4e4:	4023      	ands	r3, r4
    d4e6:	4213      	tst	r3, r2
    d4e8:	d003      	beq.n	d4f2 <gpiote_event_handler+0xf6>
			cb->handler(port, cb, pins);
    d4ea:	684b      	ldr	r3, [r1, #4]
    d4ec:	4622      	mov	r2, r4
    d4ee:	4638      	mov	r0, r7
    d4f0:	4798      	blx	r3
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
    d4f2:	2e00      	cmp	r6, #0
    d4f4:	d0c0      	beq.n	d478 <gpiote_event_handler+0x7c>
    d4f6:	4631      	mov	r1, r6
    d4f8:	6836      	ldr	r6, [r6, #0]
    d4fa:	e7f0      	b.n	d4de <gpiote_event_handler+0xe2>
		if (level_pins & bit) {
    d4fc:	421c      	tst	r4, r3
    d4fe:	d01a      	beq.n	d536 <gpiote_event_handler+0x13a>
			u32_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
    d500:	7930      	ldrb	r0, [r6, #4]
    d502:	f005 011f 	and.w	r1, r5, #31
	if ((BIT(pin) & (data->active_level ^ data->inverted)) != 0) {
    d506:	69d7      	ldr	r7, [r2, #28]
			u32_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
    d508:	ea41 1140 	orr.w	r1, r1, r0, lsl #5
	if ((BIT(pin) & (data->active_level ^ data->inverted)) != 0) {
    d50c:	6910      	ldr	r0, [r2, #16]
    d50e:	eb0c 0181 	add.w	r1, ip, r1, lsl #2
    d512:	4078      	eors	r0, r7
    d514:	40e8      	lsrs	r0, r5
		return NRF_GPIO_PIN_SENSE_HIGH;
    d516:	f010 0f01 	tst.w	r0, #1
    d51a:	bf14      	ite	ne
    d51c:	f44f 3700 	movne.w	r7, #131072	; 0x20000
    d520:	f44f 3740 	moveq.w	r7, #196608	; 0x30000
    uint32_t cnf = reg->PIN_CNF[pin_number] & ~GPIO_PIN_CNF_SENSE_Msk;
    d524:	f8d1 0200 	ldr.w	r0, [r1, #512]	; 0x200
			level_pins &= ~bit;
    d528:	ea23 0304 	bic.w	r3, r3, r4
    d52c:	f420 3040 	bic.w	r0, r0, #196608	; 0x30000
    reg->PIN_CNF[pin_number] = cnf | (sense_config << GPIO_PIN_CNF_SENSE_Pos);
    d530:	4338      	orrs	r0, r7
    d532:	f8c1 0200 	str.w	r0, [r1, #512]	; 0x200
		++pin;
    d536:	3501      	adds	r5, #1
		bit <<= 1;
    d538:	0064      	lsls	r4, r4, #1
    d53a:	e7ae      	b.n	d49a <gpiote_event_handler+0x9e>
    d53c:	4003117c 	.word	0x4003117c
    d540:	20020f2c 	.word	0x20020f2c
    d544:	40031000 	.word	0x40031000
    d548:	40031100 	.word	0x40031100
    d54c:	40842500 	.word	0x40842500

0000d550 <uarte_nrfx_configure>:
	return 0;
}

static int uarte_nrfx_configure(struct device *dev,
				const struct uart_config *cfg)
{
    d550:	b5f0      	push	{r4, r5, r6, r7, lr}
	nrf_uarte_config_t uarte_cfg;

#if defined(UARTE_CONFIG_STOP_Msk)
	switch (cfg->stop_bits) {
    d552:	794b      	ldrb	r3, [r1, #5]
    d554:	2b01      	cmp	r3, #1
    d556:	d029      	beq.n	d5ac <uarte_nrfx_configure+0x5c>
    d558:	2b03      	cmp	r3, #3
    d55a:	d124      	bne.n	d5a6 <uarte_nrfx_configure+0x56>
	case UART_CFG_STOP_BITS_1:
		uarte_cfg.stop = NRF_UARTE_STOP_ONE;
		break;
	case UART_CFG_STOP_BITS_2:
		uarte_cfg.stop = NRF_UARTE_STOP_TWO;
    d55c:	2610      	movs	r6, #16
	if (cfg->stop_bits != UART_CFG_STOP_BITS_1) {
		return -ENOTSUP;
	}
#endif

	if (cfg->data_bits != UART_CFG_DATA_BITS_8) {
    d55e:	798b      	ldrb	r3, [r1, #6]
    d560:	2b03      	cmp	r3, #3
    d562:	d120      	bne.n	d5a6 <uarte_nrfx_configure+0x56>
		return -ENOTSUP;
	}

	switch (cfg->flow_ctrl) {
    d564:	79cc      	ldrb	r4, [r1, #7]
    d566:	b12c      	cbz	r4, d574 <uarte_nrfx_configure+0x24>
    d568:	2c01      	cmp	r4, #1
    d56a:	d11c      	bne.n	d5a6 <uarte_nrfx_configure+0x56>
	return dev->config->config_info;
    d56c:	6803      	ldr	r3, [r0, #0]
	case UART_CFG_FLOW_CTRL_NONE:
		uarte_cfg.hwfc = NRF_UARTE_HWFC_DISABLED;
		break;
	case UART_CFG_FLOW_CTRL_RTS_CTS:
		if (get_dev_config(dev)->rts_cts_pins_set) {
    d56e:	689b      	ldr	r3, [r3, #8]
    d570:	791b      	ldrb	r3, [r3, #4]
    d572:	b1c3      	cbz	r3, d5a6 <uarte_nrfx_configure+0x56>
	}

#if defined(UARTE_CONFIG_PARITYTYPE_Msk)
	uarte_cfg.paritytype = NRF_UARTE_PARITYTYPE_EVEN;
#endif
	switch (cfg->parity) {
    d574:	790a      	ldrb	r2, [r1, #4]
    d576:	b112      	cbz	r2, d57e <uarte_nrfx_configure+0x2e>
    d578:	2a02      	cmp	r2, #2
    d57a:	d114      	bne.n	d5a6 <uarte_nrfx_configure+0x56>
	case UART_CFG_PARITY_NONE:
		uarte_cfg.parity = NRF_UARTE_PARITY_EXCLUDED;
		break;
	case UART_CFG_PARITY_EVEN:
		uarte_cfg.parity = NRF_UARTE_PARITY_INCLUDED;
    d57c:	220e      	movs	r2, #14
	switch (baudrate) {
    d57e:	f647 2712 	movw	r7, #31250	; 0x7a12
	return dev->config->config_info;
    d582:	6805      	ldr	r5, [r0, #0]
#endif
	default:
		return -ENOTSUP;
	}

	if (baudrate_set(dev, cfg->baudrate) != 0) {
    d584:	680b      	ldr	r3, [r1, #0]
	return config->uarte_regs;
    d586:	68ad      	ldr	r5, [r5, #8]
	switch (baudrate) {
    d588:	42bb      	cmp	r3, r7
	return config->uarte_regs;
    d58a:	682d      	ldr	r5, [r5, #0]
	switch (baudrate) {
    d58c:	d062      	beq.n	d654 <uarte_nrfx_configure+0x104>
    d58e:	d829      	bhi.n	d5e4 <uarte_nrfx_configure+0x94>
    d590:	f5b3 5f96 	cmp.w	r3, #4800	; 0x12c0
    d594:	d061      	beq.n	d65a <uarte_nrfx_configure+0x10a>
    d596:	d814      	bhi.n	d5c2 <uarte_nrfx_configure+0x72>
    d598:	f5b3 7f16 	cmp.w	r3, #600	; 0x258
    d59c:	d05f      	beq.n	d65e <uarte_nrfx_configure+0x10e>
    d59e:	d807      	bhi.n	d5b0 <uarte_nrfx_configure+0x60>
    d5a0:	f5b3 7f96 	cmp.w	r3, #300	; 0x12c
    d5a4:	d05e      	beq.n	d664 <uarte_nrfx_configure+0x114>
		return -ENOTSUP;
    d5a6:	f06f 0022 	mvn.w	r0, #34	; 0x22
    d5aa:	e052      	b.n	d652 <uarte_nrfx_configure+0x102>
		uarte_cfg.stop = NRF_UARTE_STOP_ONE;
    d5ac:	2600      	movs	r6, #0
    d5ae:	e7d6      	b.n	d55e <uarte_nrfx_configure+0xe>
	switch (baudrate) {
    d5b0:	f5b3 6f96 	cmp.w	r3, #1200	; 0x4b0
    d5b4:	d059      	beq.n	d66a <uarte_nrfx_configure+0x11a>
    d5b6:	f5b3 6f16 	cmp.w	r3, #2400	; 0x960
    d5ba:	d1f4      	bne.n	d5a6 <uarte_nrfx_configure+0x56>
		nrf_baudrate = NRF_UARTE_BAUDRATE_2400;
    d5bc:	f44f 231d 	mov.w	r3, #643072	; 0x9d000
    d5c0:	e03c      	b.n	d63c <uarte_nrfx_configure+0xec>
	switch (baudrate) {
    d5c2:	f5b3 5f61 	cmp.w	r3, #14400	; 0x3840
    d5c6:	d053      	beq.n	d670 <uarte_nrfx_configure+0x120>
    d5c8:	d804      	bhi.n	d5d4 <uarte_nrfx_configure+0x84>
    d5ca:	f5b3 5f16 	cmp.w	r3, #9600	; 0x2580
    d5ce:	d1ea      	bne.n	d5a6 <uarte_nrfx_configure+0x56>
		nrf_baudrate = NRF_UARTE_BAUDRATE_9600;
    d5d0:	4b32      	ldr	r3, [pc, #200]	; (d69c <uarte_nrfx_configure+0x14c>)
    d5d2:	e033      	b.n	d63c <uarte_nrfx_configure+0xec>
	switch (baudrate) {
    d5d4:	f5b3 4f96 	cmp.w	r3, #19200	; 0x4b00
    d5d8:	d04c      	beq.n	d674 <uarte_nrfx_configure+0x124>
    d5da:	f5b3 4fe1 	cmp.w	r3, #28800	; 0x7080
    d5de:	d1e2      	bne.n	d5a6 <uarte_nrfx_configure+0x56>
		nrf_baudrate = NRF_UARTE_BAUDRATE_28800;
    d5e0:	4b2f      	ldr	r3, [pc, #188]	; (d6a0 <uarte_nrfx_configure+0x150>)
    d5e2:	e02b      	b.n	d63c <uarte_nrfx_configure+0xec>
	switch (baudrate) {
    d5e4:	f5b3 3fe1 	cmp.w	r3, #115200	; 0x1c200
    d5e8:	d046      	beq.n	d678 <uarte_nrfx_configure+0x128>
    d5ea:	d812      	bhi.n	d612 <uarte_nrfx_configure+0xc2>
    d5ec:	f64d 27c0 	movw	r7, #56000	; 0xdac0
    d5f0:	42bb      	cmp	r3, r7
    d5f2:	d044      	beq.n	d67e <uarte_nrfx_configure+0x12e>
    d5f4:	d805      	bhi.n	d602 <uarte_nrfx_configure+0xb2>
    d5f6:	f5b3 4f16 	cmp.w	r3, #38400	; 0x9600
    d5fa:	d1d4      	bne.n	d5a6 <uarte_nrfx_configure+0x56>
		nrf_baudrate = NRF_UARTE_BAUDRATE_38400;
    d5fc:	f44f 031d 	mov.w	r3, #10289152	; 0x9d0000
    d600:	e01c      	b.n	d63c <uarte_nrfx_configure+0xec>
	switch (baudrate) {
    d602:	f5b3 4f61 	cmp.w	r3, #57600	; 0xe100
    d606:	d03d      	beq.n	d684 <uarte_nrfx_configure+0x134>
    d608:	f5b3 3f96 	cmp.w	r3, #76800	; 0x12c00
    d60c:	d1cb      	bne.n	d5a6 <uarte_nrfx_configure+0x56>
		nrf_baudrate = NRF_UARTE_BAUDRATE_76800;
    d60e:	4b25      	ldr	r3, [pc, #148]	; (d6a4 <uarte_nrfx_configure+0x154>)
    d610:	e014      	b.n	d63c <uarte_nrfx_configure+0xec>
	switch (baudrate) {
    d612:	f5b3 2fe1 	cmp.w	r3, #460800	; 0x70800
    d616:	d038      	beq.n	d68a <uarte_nrfx_configure+0x13a>
    d618:	d808      	bhi.n	d62c <uarte_nrfx_configure+0xdc>
    d61a:	f5b3 3f61 	cmp.w	r3, #230400	; 0x38400
    d61e:	d037      	beq.n	d690 <uarte_nrfx_configure+0x140>
    d620:	4f21      	ldr	r7, [pc, #132]	; (d6a8 <uarte_nrfx_configure+0x158>)
    d622:	42bb      	cmp	r3, r7
    d624:	d1bf      	bne.n	d5a6 <uarte_nrfx_configure+0x56>
		nrf_baudrate = NRF_UARTE_BAUDRATE_250000;
    d626:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
    d62a:	e007      	b.n	d63c <uarte_nrfx_configure+0xec>
	switch (baudrate) {
    d62c:	f5b3 2f61 	cmp.w	r3, #921600	; 0xe1000
    d630:	d031      	beq.n	d696 <uarte_nrfx_configure+0x146>
    d632:	4f1e      	ldr	r7, [pc, #120]	; (d6ac <uarte_nrfx_configure+0x15c>)
    d634:	42bb      	cmp	r3, r7
    d636:	d1b6      	bne.n	d5a6 <uarte_nrfx_configure+0x56>
		nrf_baudrate = NRF_UARTE_BAUDRATE_1000000;
    d638:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
                    | (uint32_t)p_cfg->hwfc;
}

NRF_STATIC_INLINE void nrf_uarte_baudrate_set(NRF_UARTE_Type * p_reg, nrf_uarte_baudrate_t baudrate)
{
    p_reg->BAUDRATE = baudrate;
    d63c:	f8c5 3524 	str.w	r3, [r5, #1316]	; 0x524
                    | (uint32_t)p_cfg->hwfc;
    d640:	4334      	orrs	r4, r6
		return -ENOTSUP;
	}

	nrf_uarte_configure(get_uarte_instance(dev), &uarte_cfg);

	get_dev_data(dev)->uart_config = *cfg;
    d642:	6883      	ldr	r3, [r0, #8]
    d644:	4322      	orrs	r2, r4
    d646:	c903      	ldmia	r1, {r0, r1}
    p_reg->CONFIG = (uint32_t)p_cfg->parity
    d648:	f8c5 256c 	str.w	r2, [r5, #1388]	; 0x56c
    d64c:	e883 0003 	stmia.w	r3, {r0, r1}

	return 0;
    d650:	2000      	movs	r0, #0
}
    d652:	bdf0      	pop	{r4, r5, r6, r7, pc}
		nrf_baudrate = NRF_UARTE_BAUDRATE_31250;
    d654:	f44f 0300 	mov.w	r3, #8388608	; 0x800000
    d658:	e7f0      	b.n	d63c <uarte_nrfx_configure+0xec>
		nrf_baudrate = NRF_UARTE_BAUDRATE_4800;
    d65a:	4b15      	ldr	r3, [pc, #84]	; (d6b0 <uarte_nrfx_configure+0x160>)
    d65c:	e7ee      	b.n	d63c <uarte_nrfx_configure+0xec>
		nrf_baudrate = 0x00027000;
    d65e:	f44f 331c 	mov.w	r3, #159744	; 0x27000
    d662:	e7eb      	b.n	d63c <uarte_nrfx_configure+0xec>
		nrf_baudrate = 0x00014000;
    d664:	f44f 33a0 	mov.w	r3, #81920	; 0x14000
    d668:	e7e8      	b.n	d63c <uarte_nrfx_configure+0xec>
		nrf_baudrate = NRF_UARTE_BAUDRATE_1200;
    d66a:	f44f 239e 	mov.w	r3, #323584	; 0x4f000
    d66e:	e7e5      	b.n	d63c <uarte_nrfx_configure+0xec>
		nrf_baudrate = NRF_UARTE_BAUDRATE_14400;
    d670:	4b10      	ldr	r3, [pc, #64]	; (d6b4 <uarte_nrfx_configure+0x164>)
    d672:	e7e3      	b.n	d63c <uarte_nrfx_configure+0xec>
		nrf_baudrate = NRF_UARTE_BAUDRATE_19200;
    d674:	4b10      	ldr	r3, [pc, #64]	; (d6b8 <uarte_nrfx_configure+0x168>)
    d676:	e7e1      	b.n	d63c <uarte_nrfx_configure+0xec>
		nrf_baudrate = NRF_UARTE_BAUDRATE_115200;
    d678:	f04f 73eb 	mov.w	r3, #30801920	; 0x1d60000
    d67c:	e7de      	b.n	d63c <uarte_nrfx_configure+0xec>
		nrf_baudrate = NRF_UARTE_BAUDRATE_56000;
    d67e:	f44f 0365 	mov.w	r3, #15007744	; 0xe50000
    d682:	e7db      	b.n	d63c <uarte_nrfx_configure+0xec>
		nrf_baudrate = NRF_UARTE_BAUDRATE_57600;
    d684:	f44f 036b 	mov.w	r3, #15400960	; 0xeb0000
    d688:	e7d8      	b.n	d63c <uarte_nrfx_configure+0xec>
		nrf_baudrate = NRF_UARTE_BAUDRATE_460800;
    d68a:	f04f 63e8 	mov.w	r3, #121634816	; 0x7400000
    d68e:	e7d5      	b.n	d63c <uarte_nrfx_configure+0xec>
		nrf_baudrate = NRF_UARTE_BAUDRATE_230400;
    d690:	f04f 736c 	mov.w	r3, #61865984	; 0x3b00000
    d694:	e7d2      	b.n	d63c <uarte_nrfx_configure+0xec>
		nrf_baudrate = NRF_UARTE_BAUDRATE_921600;
    d696:	f04f 6370 	mov.w	r3, #251658240	; 0xf000000
    d69a:	e7cf      	b.n	d63c <uarte_nrfx_configure+0xec>
    d69c:	00275000 	.word	0x00275000
    d6a0:	0075c000 	.word	0x0075c000
    d6a4:	013a9000 	.word	0x013a9000
    d6a8:	0003d090 	.word	0x0003d090
    d6ac:	000f4240 	.word	0x000f4240
    d6b0:	0013b000 	.word	0x0013b000
    d6b4:	003af000 	.word	0x003af000
    d6b8:	004ea000 	.word	0x004ea000

0000d6bc <uarte_0_init>:
	return dev->config->config_info;
    d6bc:	6802      	ldr	r2, [r0, #0]
	#endif
	#if !defined(DT_NORDIC_NRF_UARTE_UART_0_RX_PIN)
	#define DT_NORDIC_NRF_UARTE_UART_0_RX_PIN NRF_UARTE_PSEL_DISCONNECTED
	#endif

	UART_NRF_UARTE_DEVICE(0);
    d6be:	b570      	push	{r4, r5, r6, lr}
	return config->uarte_regs;
    d6c0:	6892      	ldr	r2, [r2, #8]
}


NRF_STATIC_INLINE void nrf_gpio_port_out_set(NRF_GPIO_Type * p_reg, uint32_t set_mask)
{
    p_reg->OUTSET = set_mask;
    d6c2:	4b18      	ldr	r3, [pc, #96]	; (d724 <uarte_0_init+0x68>)
    d6c4:	6814      	ldr	r4, [r2, #0]
    d6c6:	f04f 5200 	mov.w	r2, #536870912	; 0x20000000
	struct uarte_nrfx_data *data = get_dev_data(dev);
    d6ca:	6885      	ldr	r5, [r0, #8]
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
    d6cc:	2103      	movs	r1, #3
    p_reg->OUTSET = set_mask;
    d6ce:	609a      	str	r2, [r3, #8]
    p_reg->PSEL.TXD = pseltxd;
    d6d0:	261d      	movs	r6, #29
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
    d6d2:	2200      	movs	r2, #0
    d6d4:	f8c3 1274 	str.w	r1, [r3, #628]	; 0x274
    d6d8:	f8c3 2270 	str.w	r2, [r3, #624]	; 0x270
    d6dc:	f8c4 650c 	str.w	r6, [r4, #1292]	; 0x50c
    p_reg->PSEL.RXD = pselrxd;
    d6e0:	261c      	movs	r6, #28
    d6e2:	f8c4 6514 	str.w	r6, [r4, #1300]	; 0x514
    p_reg->OUTSET = set_mask;
    d6e6:	f04f 6600 	mov.w	r6, #134217728	; 0x8000000
    d6ea:	609e      	str	r6, [r3, #8]
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
    d6ec:	f8c3 126c 	str.w	r1, [r3, #620]	; 0x26c
    d6f0:	f8c3 2268 	str.w	r2, [r3, #616]	; 0x268
    p_reg->PSEL.RTS = pselrts;
    d6f4:	231b      	movs	r3, #27
    d6f6:	f8c4 3508 	str.w	r3, [r4, #1288]	; 0x508
    p_reg->PSEL.CTS = pselcts;
    d6fa:	231a      	movs	r3, #26
	err = uarte_nrfx_configure(dev, &get_dev_data(dev)->uart_config);
    d6fc:	4629      	mov	r1, r5
    d6fe:	f8c4 3510 	str.w	r3, [r4, #1296]	; 0x510
    d702:	f7ff ff25 	bl	d550 <uarte_nrfx_configure>
	if (err) {
    d706:	b958      	cbnz	r0, d720 <uarte_0_init+0x64>
    p_reg->ENABLE = UARTE_ENABLE_ENABLE_Enabled;
    d708:	2308      	movs	r3, #8
    d70a:	f8c4 3500 	str.w	r3, [r4, #1280]	; 0x500
		nrf_uarte_rx_buffer_set(uarte, &data->rx_data, 1);
    d70e:	441d      	add	r5, r3
NRF_STATIC_INLINE void nrf_uarte_rx_buffer_set(NRF_UARTE_Type * p_reg,
                                               uint8_t *        p_buffer,
                                               size_t           length)
{
    p_reg->RXD.PTR    = (uint32_t)p_buffer;
    p_reg->RXD.MAXCNT = length;
    d710:	2301      	movs	r3, #1
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    d712:	f8c4 0110 	str.w	r0, [r4, #272]	; 0x110
    p_reg->RXD.PTR    = (uint32_t)p_buffer;
    d716:	f8c4 5534 	str.w	r5, [r4, #1332]	; 0x534
    p_reg->RXD.MAXCNT = length;
    d71a:	f8c4 3538 	str.w	r3, [r4, #1336]	; 0x538
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    d71e:	6023      	str	r3, [r4, #0]
	UART_NRF_UARTE_DEVICE(0);
    d720:	bd70      	pop	{r4, r5, r6, pc}
    d722:	bf00      	nop
    d724:	40842500 	.word	0x40842500

0000d728 <check_ext_api_requests>:
	return true;
}


static int check_ext_api_requests(struct device *dev)
{
    d728:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	(void)dev;

	const struct fw_info_ext_api_request *ext_api_req =
			skip_ext_apis(&m_firmware_info);

	for (u32_t i = 0; i < m_firmware_info.ext_api_request_num; i++) {
    d72c:	2600      	movs	r6, #0
			skip_ext_apis(&m_firmware_info);
    d72e:	4c1e      	ldr	r4, [pc, #120]	; (d7a8 <check_ext_api_requests+0x80>)
{
    d730:	b085      	sub	sp, #20
	for (u32_t i = 0; i < m_firmware_info.ext_api_request_num; i++) {
    d732:	f854 9c04 	ldr.w	r9, [r4, #-4]
 */
static inline const struct fw_info_ext_api *fw_info_ext_api_check(
							u32_t ext_api_addr)
{
	const struct fw_info_ext_api *ext_api;
	const u32_t ext_api_magic[] = {EXT_API_MAGIC};
    d736:	4f1d      	ldr	r7, [pc, #116]	; (d7ac <check_ext_api_requests+0x84>)
    d738:	ad01      	add	r5, sp, #4
    d73a:	45b1      	cmp	r9, r6
    d73c:	d803      	bhi.n	d746 <check_ext_api_requests+0x1e>
		}
		ADVANCE_EXT_API_REQ(ext_api_req);
	}

	return 0;
}
    d73e:	2000      	movs	r0, #0
    d740:	b005      	add	sp, #20
    d742:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		if (fw_info_ext_api_check((u32_t)*(ext_api_req->ext_api))
    d746:	6a63      	ldr	r3, [r4, #36]	; 0x24
    d748:	e897 0007 	ldmia.w	r7, {r0, r1, r2}
    d74c:	f8d3 8000 	ldr.w	r8, [r3]
    d750:	e885 0007 	stmia.w	r5, {r0, r1, r2}

	ext_api = (const struct fw_info_ext_api *)(ext_api_addr);
	if (memcmp(ext_api->magic, ext_api_magic, CONFIG_FW_INFO_MAGIC_LEN)
    d754:	220c      	movs	r2, #12
    d756:	4629      	mov	r1, r5
    d758:	4640      	mov	r0, r8
    d75a:	f000 ff1c 	bl	e596 <memcmp>
    d75e:	b9a0      	cbnz	r0, d78a <check_ext_api_requests+0x62>
    d760:	f1b8 0f00 	cmp.w	r8, #0
    d764:	d011      	beq.n	d78a <check_ext_api_requests+0x62>
			&& ext_api_satisfies_req(*(ext_api_req->ext_api),
    d766:	6a63      	ldr	r3, [r4, #36]	; 0x24
	const u32_t req_id = ext_api_req->request.ext_api_id;
    d768:	6921      	ldr	r1, [r4, #16]
			&& ext_api_satisfies_req(*(ext_api_req->ext_api),
    d76a:	681b      	ldr	r3, [r3, #0]
	return ((ext_api->ext_api_id == req_id)
    d76c:	691a      	ldr	r2, [r3, #16]
		&& ((ext_api->ext_api_flags & req_flags) == req_flags));
    d76e:	4291      	cmp	r1, r2
    d770:	d10b      	bne.n	d78a <check_ext_api_requests+0x62>
		&&  (ext_api->ext_api_version >= req_min_version)
    d772:	699a      	ldr	r2, [r3, #24]
	const u32_t req_min_version = ext_api_req->request.ext_api_version;
    d774:	69a1      	ldr	r1, [r4, #24]
		&&  (ext_api->ext_api_version >= req_min_version)
    d776:	4291      	cmp	r1, r2
    d778:	d807      	bhi.n	d78a <check_ext_api_requests+0x62>
	const u32_t req_max_version = ext_api_req->ext_api_max_version;
    d77a:	69e1      	ldr	r1, [r4, #28]
		&&  (ext_api->ext_api_version <  req_max_version)
    d77c:	4291      	cmp	r1, r2
    d77e:	d904      	bls.n	d78a <check_ext_api_requests+0x62>
	const u32_t req_flags = ext_api_req->request.ext_api_flags;
    d780:	6962      	ldr	r2, [r4, #20]
		&& ((ext_api->ext_api_flags & req_flags) == req_flags));
    d782:	695b      	ldr	r3, [r3, #20]
    d784:	ea32 0303 	bics.w	r3, r2, r3
    d788:	d007      	beq.n	d79a <check_ext_api_requests+0x72>
		} else if (ext_api_req->required) {
    d78a:	6a23      	ldr	r3, [r4, #32]
    d78c:	b14b      	cbz	r3, d7a2 <check_ext_api_requests+0x7a>
			k_panic();
    d78e:	4040      	eors	r0, r0
    d790:	f380 8811 	msr	BASEPRI, r0
    d794:	f04f 0004 	mov.w	r0, #4
    d798:	df02      	svc	2
		ADVANCE_EXT_API_REQ(ext_api_req);
    d79a:	68e3      	ldr	r3, [r4, #12]
	for (u32_t i = 0; i < m_firmware_info.ext_api_request_num; i++) {
    d79c:	3601      	adds	r6, #1
		ADVANCE_EXT_API_REQ(ext_api_req);
    d79e:	441c      	add	r4, r3
    d7a0:	e7cb      	b.n	d73a <check_ext_api_requests+0x12>
			*ext_api_req->ext_api = NULL;
    d7a2:	6a62      	ldr	r2, [r4, #36]	; 0x24
    d7a4:	6013      	str	r3, [r2, #0]
    d7a6:	e7f8      	b.n	d79a <check_ext_api_requests+0x72>
    d7a8:	0000c23c 	.word	0x0000c23c
    d7ac:	0000ec10 	.word	0x0000ec10

0000d7b0 <SystemInit>:
    static bool uicr_HFXOCNT_erased(void);
#endif

void SystemCoreClockUpdate(void)
{
    SystemCoreClock = __SYSTEM_CLOCK;
    d7b0:	4b01      	ldr	r3, [pc, #4]	; (d7b8 <SystemInit+0x8>)
    d7b2:	4a02      	ldr	r2, [pc, #8]	; (d7bc <SystemInit+0xc>)
    d7b4:	601a      	str	r2, [r3, #0]
      __DSB();
      __ISB();
    #endif
    
    SystemCoreClockUpdate();
}
    d7b6:	4770      	bx	lr
    d7b8:	20020ecc 	.word	0x20020ecc
    d7bc:	03d09000 	.word	0x03d09000

0000d7c0 <z_sys_device_do_config_level>:
 * off and the next one begins.
 *
 * @param level init level to run.
 */
void z_sys_device_do_config_level(s32_t level)
{
    d7c0:	b570      	push	{r4, r5, r6, lr}
		retval = device_conf->init(info);
		if (retval != 0) {
			/* Initialization failed. Clear the API struct so that
			 * device_get_binding() will not succeed for it.
			 */
			info->driver_api = NULL;
    d7c2:	2600      	movs	r6, #0
	for (info = config_levels[level]; info < config_levels[level+1];
    d7c4:	4b08      	ldr	r3, [pc, #32]	; (d7e8 <z_sys_device_do_config_level+0x28>)
    d7c6:	f853 4020 	ldr.w	r4, [r3, r0, lsl #2]
    d7ca:	3001      	adds	r0, #1
    d7cc:	f853 5020 	ldr.w	r5, [r3, r0, lsl #2]
    d7d0:	42a5      	cmp	r5, r4
    d7d2:	d800      	bhi.n	d7d6 <z_sys_device_do_config_level+0x16>
		} else {
			z_object_init(info);
		}
	}
}
    d7d4:	bd70      	pop	{r4, r5, r6, pc}
		retval = device_conf->init(info);
    d7d6:	6823      	ldr	r3, [r4, #0]
    d7d8:	4620      	mov	r0, r4
    d7da:	685b      	ldr	r3, [r3, #4]
    d7dc:	4798      	blx	r3
		if (retval != 0) {
    d7de:	b100      	cbz	r0, d7e2 <z_sys_device_do_config_level+0x22>
			info->driver_api = NULL;
    d7e0:	6066      	str	r6, [r4, #4]
								info++) {
    d7e2:	340c      	adds	r4, #12
    d7e4:	e7f4      	b.n	d7d0 <z_sys_device_do_config_level+0x10>
    d7e6:	bf00      	nop
    d7e8:	0000ecbc 	.word	0x0000ecbc

0000d7ec <z_impl_device_get_binding>:
	/* Split the search into two loops: in the common scenario, where
	 * device names are stored in ROM (and are referenced by the user
	 * with CONFIG_* macros), only cheap pointer comparisons will be
	 * performed.  Reserve string comparisons for a fallback.
	 */
	for (info = __device_init_start; info != __device_init_end; info++) {
    d7ec:	4b10      	ldr	r3, [pc, #64]	; (d830 <z_impl_device_get_binding+0x44>)
{
    d7ee:	b570      	push	{r4, r5, r6, lr}
    d7f0:	4605      	mov	r5, r0
    d7f2:	461e      	mov	r6, r3
	for (info = __device_init_start; info != __device_init_end; info++) {
    d7f4:	4c0f      	ldr	r4, [pc, #60]	; (d834 <z_impl_device_get_binding+0x48>)
    d7f6:	429c      	cmp	r4, r3
    d7f8:	d104      	bne.n	d804 <z_impl_device_get_binding+0x18>
		    (info->config->name == name)) {
			return info;
		}
	}

	for (info = __device_init_start; info != __device_init_end; info++) {
    d7fa:	4c0e      	ldr	r4, [pc, #56]	; (d834 <z_impl_device_get_binding+0x48>)
    d7fc:	42b4      	cmp	r4, r6
    d7fe:	d109      	bne.n	d814 <z_impl_device_get_binding+0x28>
		if (strcmp(name, info->config->name) == 0) {
			return info;
		}
	}

	return NULL;
    d800:	2400      	movs	r4, #0
    d802:	e012      	b.n	d82a <z_impl_device_get_binding+0x3e>
		if ((info->driver_api != NULL) &&
    d804:	6862      	ldr	r2, [r4, #4]
    d806:	b11a      	cbz	r2, d810 <z_impl_device_get_binding+0x24>
		    (info->config->name == name)) {
    d808:	6822      	ldr	r2, [r4, #0]
		if ((info->driver_api != NULL) &&
    d80a:	6812      	ldr	r2, [r2, #0]
    d80c:	42aa      	cmp	r2, r5
    d80e:	d00c      	beq.n	d82a <z_impl_device_get_binding+0x3e>
	for (info = __device_init_start; info != __device_init_end; info++) {
    d810:	340c      	adds	r4, #12
    d812:	e7f0      	b.n	d7f6 <z_impl_device_get_binding+0xa>
		if (info->driver_api == NULL) {
    d814:	6863      	ldr	r3, [r4, #4]
    d816:	b90b      	cbnz	r3, d81c <z_impl_device_get_binding+0x30>
	for (info = __device_init_start; info != __device_init_end; info++) {
    d818:	340c      	adds	r4, #12
    d81a:	e7ef      	b.n	d7fc <z_impl_device_get_binding+0x10>
		if (strcmp(name, info->config->name) == 0) {
    d81c:	6823      	ldr	r3, [r4, #0]
    d81e:	4628      	mov	r0, r5
    d820:	6819      	ldr	r1, [r3, #0]
    d822:	f000 feac 	bl	e57e <strcmp>
    d826:	2800      	cmp	r0, #0
    d828:	d1f6      	bne.n	d818 <z_impl_device_get_binding+0x2c>
}
    d82a:	4620      	mov	r0, r4
    d82c:	bd70      	pop	{r4, r5, r6, pc}
    d82e:	bf00      	nop
    d830:	20020f44 	.word	0x20020f44
    d834:	20020ed8 	.word	0x20020ed8

0000d838 <idle>:
#else
#define IDLE_YIELD_IF_COOP() do { } while (false)
#endif

void idle(void *unused1, void *unused2, void *unused3)
{
    d838:	b508      	push	{r3, lr}
	_kernel.idle = ticks;
    d83a:	4d0b      	ldr	r5, [pc, #44]	; (d868 <idle+0x30>)
    d83c:	f04f 0220 	mov.w	r2, #32
    d840:	f3ef 8311 	mrs	r3, BASEPRI
    d844:	f382 8811 	msr	BASEPRI, r2
    d848:	f3bf 8f6f 	isb	sy
	s32_t ticks = z_get_next_timeout_expiry();
    d84c:	f001 f876 	bl	e93c <z_get_next_timeout_expiry>
	z_set_timeout_expiry((ticks < IDLE_THRESH) ? 1 : ticks, true);
    d850:	2101      	movs	r1, #1
	s32_t ticks = z_get_next_timeout_expiry();
    d852:	4604      	mov	r4, r0
	z_set_timeout_expiry((ticks < IDLE_THRESH) ? 1 : ticks, true);
    d854:	2802      	cmp	r0, #2
    d856:	bfd8      	it	le
    d858:	4608      	movle	r0, r1
    d85a:	f001 f87f 	bl	e95c <z_set_timeout_expiry>
	_kernel.idle = ticks;
    d85e:	622c      	str	r4, [r5, #32]
 * @return N/A
 * @req K-CPU-IDLE-001
 */
static inline void k_cpu_idle(void)
{
	arch_cpu_idle();
    d860:	f7ff f8e6 	bl	ca30 <arch_cpu_idle>
    d864:	e7ea      	b.n	d83c <idle+0x4>
    d866:	bf00      	nop
    d868:	20020134 	.word	0x20020134

0000d86c <z_bss_zero>:
 *
 * @return N/A
 */
void z_bss_zero(void)
{
	(void)memset(__bss_start, 0, __bss_end - __bss_start);
    d86c:	4802      	ldr	r0, [pc, #8]	; (d878 <z_bss_zero+0xc>)
    d86e:	4a03      	ldr	r2, [pc, #12]	; (d87c <z_bss_zero+0x10>)
    d870:	2100      	movs	r1, #0
    d872:	1a12      	subs	r2, r2, r0
    d874:	f000 bec9 	b.w	e60a <memset>
    d878:	20020000 	.word	0x20020000
    d87c:	20020178 	.word	0x20020178

0000d880 <z_data_copy>:
 * This routine copies the data section from ROM to RAM.
 *
 * @return N/A
 */
void z_data_copy(void)
{
    d880:	b508      	push	{r3, lr}
	(void)memcpy(&__data_ram_start, &__data_rom_start,
		 __data_ram_end - __data_ram_start);
    d882:	4806      	ldr	r0, [pc, #24]	; (d89c <z_data_copy+0x1c>)
	(void)memcpy(&__data_ram_start, &__data_rom_start,
    d884:	4a06      	ldr	r2, [pc, #24]	; (d8a0 <z_data_copy+0x20>)
    d886:	4907      	ldr	r1, [pc, #28]	; (d8a4 <z_data_copy+0x24>)
    d888:	1a12      	subs	r2, r2, r0
    d88a:	f000 fe94 	bl	e5b6 <memcpy>
#else
	(void)memcpy(&_app_smem_start, &_app_smem_rom_start,
		 _app_smem_end - _app_smem_start);
#endif /* CONFIG_STACK_CANARIES */
#endif /* CONFIG_USERSPACE */
}
    d88e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	(void)memcpy(&_ramfunc_ram_start, &_ramfunc_rom_start,
    d892:	4a05      	ldr	r2, [pc, #20]	; (d8a8 <z_data_copy+0x28>)
    d894:	4905      	ldr	r1, [pc, #20]	; (d8ac <z_data_copy+0x2c>)
    d896:	4806      	ldr	r0, [pc, #24]	; (d8b0 <z_data_copy+0x30>)
    d898:	f000 be8d 	b.w	e5b6 <memcpy>
    d89c:	20020eb8 	.word	0x20020eb8
    d8a0:	20020f58 	.word	0x20020f58
    d8a4:	0000ed54 	.word	0x0000ed54
    d8a8:	00000000 	.word	0x00000000
    d8ac:	0000ed54 	.word	0x0000ed54
    d8b0:	20020000 	.word	0x20020000

0000d8b4 <bg_thread_main>:
	static const unsigned int boot_delay = CONFIG_BOOT_DELAY;
#else
	static const unsigned int boot_delay;
#endif

	z_sys_post_kernel = true;
    d8b4:	2201      	movs	r2, #1
{
    d8b6:	b508      	push	{r3, lr}
	z_sys_post_kernel = true;
    d8b8:	4b0b      	ldr	r3, [pc, #44]	; (d8e8 <bg_thread_main+0x34>)

	z_sys_device_do_config_level(_SYS_INIT_LEVEL_POST_KERNEL);
    d8ba:	2002      	movs	r0, #2
	z_sys_post_kernel = true;
    d8bc:	701a      	strb	r2, [r3, #0]
	z_sys_device_do_config_level(_SYS_INIT_LEVEL_POST_KERNEL);
    d8be:	f7ff ff7f 	bl	d7c0 <z_sys_device_do_config_level>
		k_busy_wait(CONFIG_BOOT_DELAY * USEC_PER_MSEC);
	}

#if defined(CONFIG_BOOT_BANNER)
#ifdef BUILD_VERSION
	printk("*** Booting Zephyr OS build %s %s ***\n",
    d8c2:	4a0a      	ldr	r2, [pc, #40]	; (d8ec <bg_thread_main+0x38>)
    d8c4:	490a      	ldr	r1, [pc, #40]	; (d8f0 <bg_thread_main+0x3c>)
    d8c6:	480b      	ldr	r0, [pc, #44]	; (d8f4 <bg_thread_main+0x40>)
    d8c8:	f000 fd88 	bl	e3dc <printk>
			KERNEL_VERSION_STRING, BOOT_DELAY_BANNER);
#endif
#endif

	/* Final init level before app starts */
	z_sys_device_do_config_level(_SYS_INIT_LEVEL_APPLICATION);
    d8cc:	2003      	movs	r0, #3
    d8ce:	f7ff ff77 	bl	d7c0 <z_sys_device_do_config_level>
	extern void __do_init_array_aux(void);
	__do_global_ctors_aux();
	__do_init_array_aux();
#endif

	z_init_static_threads();
    d8d2:	f000 fa7d 	bl	ddd0 <z_init_static_threads>
	z_timestamp_main = k_cycle_get_32();
#endif

	extern void main(void);

	main();
    d8d6:	f7fe fe2f 	bl	c538 <main>

	/* Mark nonessenrial since main() has no more work to do */
	z_main_thread.base.user_options &= ~K_ESSENTIAL;
    d8da:	4a07      	ldr	r2, [pc, #28]	; (d8f8 <bg_thread_main+0x44>)
    d8dc:	7b13      	ldrb	r3, [r2, #12]
    d8de:	f023 0301 	bic.w	r3, r3, #1
    d8e2:	7313      	strb	r3, [r2, #12]

	/* Dump coverage data once the main() has exited. */
	gcov_coverage_dump();
} /* LCOV_EXCL_LINE ... because we just dumped final coverage data */
    d8e4:	bd08      	pop	{r3, pc}
    d8e6:	bf00      	nop
    d8e8:	20020176 	.word	0x20020176
    d8ec:	0000ece1 	.word	0x0000ece1
    d8f0:	0000ed0f 	.word	0x0000ed0f
    d8f4:	0000ed1c 	.word	0x0000ed1c
    d8f8:	200200c8 	.word	0x200200c8

0000d8fc <z_cstart>:
 * cleared/zeroed.
 *
 * @return Does not return
 */
FUNC_NORETURN void z_cstart(void)
{
    d8fc:	b580      	push	{r7, lr}
 *
 * @return N/A
 */
static ALWAYS_INLINE void z_arm_interrupt_stack_setup(void)
{
	u32_t msp = (u32_t)(Z_THREAD_STACK_BUFFER(_interrupt_stack)) +
    d8fe:	4b34      	ldr	r3, [pc, #208]	; (d9d0 <z_cstart+0xd4>)
    d900:	b0a2      	sub	sp, #136	; 0x88
  __ASM volatile ("MSR msp, %0" : : "r" (topOfMainStack) : );
    d902:	f383 8808 	msr	MSP, r3
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    d906:	2400      	movs	r4, #0
    d908:	23e0      	movs	r3, #224	; 0xe0
    d90a:	4d32      	ldr	r5, [pc, #200]	; (d9d4 <z_cstart+0xd8>)

	/* perform any architecture-specific initialization */
	arch_kernel_init();

#ifdef CONFIG_MULTITHREADING
	struct k_thread dummy_thread = {
    d90c:	2701      	movs	r7, #1
    d90e:	f885 3022 	strb.w	r3, [r5, #34]	; 0x22
    d912:	77ec      	strb	r4, [r5, #31]
    d914:	762c      	strb	r4, [r5, #24]
    d916:	766c      	strb	r4, [r5, #25]
    d918:	76ac      	strb	r4, [r5, #26]
#if defined(CONFIG_ARM_SECURE_FIRMWARE)
	NVIC_SetPriority(SecureFault_IRQn, _EXC_FAULT_PRIO);
#endif /* CONFIG_ARM_SECURE_FIRMWARE */

	/* Enable Usage, Mem, & Bus Faults */
	SCB->SHCSR |= SCB_SHCSR_USGFAULTENA_Msk | SCB_SHCSR_MEMFAULTENA_Msk |
    d91a:	6a6b      	ldr	r3, [r5, #36]	; 0x24
# ifdef CONFIG_SCHED_CPU_MASK
		 .base.cpu_mask = -1,
# endif
	};

	_current = &dummy_thread;
    d91c:	4e2e      	ldr	r6, [pc, #184]	; (d9d8 <z_cstart+0xdc>)
    d91e:	f443 23e0 	orr.w	r3, r3, #458752	; 0x70000
    d922:	626b      	str	r3, [r5, #36]	; 0x24

static ALWAYS_INLINE void arch_kernel_init(void)
{
	z_arm_interrupt_stack_setup();
	z_arm_exc_setup();
	z_arm_fault_init();
    d924:	f7ff fa30 	bl	cd88 <z_arm_fault_init>
	z_arm_cpu_idle_init();
    d928:	f7ff f87c 	bl	ca24 <z_arm_cpu_idle_init>
static ALWAYS_INLINE void z_arm_clear_faults(void)
{
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* Reset all faults */
	SCB->CFSR = SCB_CFSR_USGFAULTSR_Msk |
    d92c:	f04f 33ff 	mov.w	r3, #4294967295
    d930:	62ab      	str	r3, [r5, #40]	; 0x28
		    SCB_CFSR_MEMFAULTSR_Msk |
		    SCB_CFSR_BUSFAULTSR_Msk;

	/* Clear all Hard Faults - HFSR is write-one-to-clear */
	SCB->HFSR = 0xffffffff;
    d932:	62eb      	str	r3, [r5, #44]	; 0x2c
	struct k_thread dummy_thread = {
    d934:	ab07      	add	r3, sp, #28
    d936:	226c      	movs	r2, #108	; 0x6c
    d938:	4621      	mov	r1, r4
    d93a:	4618      	mov	r0, r3
    d93c:	f000 fe65 	bl	e60a <memset>
	_current = &dummy_thread;
    d940:	60b0      	str	r0, [r6, #8]
#ifdef CONFIG_USERSPACE
	z_app_shmem_bss_zero();
#endif

	/* perform basic hardware initialization */
	z_sys_device_do_config_level(_SYS_INIT_LEVEL_PRE_KERNEL_1);
    d942:	4620      	mov	r0, r4
	struct k_thread dummy_thread = {
    d944:	f88d 7029 	strb.w	r7, [sp, #41]	; 0x29
	z_sys_device_do_config_level(_SYS_INIT_LEVEL_PRE_KERNEL_1);
    d948:	f7ff ff3a 	bl	d7c0 <z_sys_device_do_config_level>
	z_sys_device_do_config_level(_SYS_INIT_LEVEL_PRE_KERNEL_2);
    d94c:	4638      	mov	r0, r7
    d94e:	f7ff ff37 	bl	d7c0 <z_sys_device_do_config_level>
	_kernel.ready_q.cache = &z_main_thread;
    d952:	4d22      	ldr	r5, [pc, #136]	; (d9dc <z_cstart+0xe0>)
	z_sched_init();
    d954:	f000 f9ee 	bl	dd34 <z_sched_init>
	z_setup_new_thread(&z_main_thread, z_main_stack,
    d958:	4b21      	ldr	r3, [pc, #132]	; (d9e0 <z_cstart+0xe4>)
    d95a:	f44f 6280 	mov.w	r2, #1024	; 0x400
    d95e:	e9cd 7304 	strd	r7, r3, [sp, #16]
    d962:	e9cd 4402 	strd	r4, r4, [sp, #8]
    d966:	4b1f      	ldr	r3, [pc, #124]	; (d9e4 <z_cstart+0xe8>)
    d968:	e9cd 4400 	strd	r4, r4, [sp]
    d96c:	491e      	ldr	r1, [pc, #120]	; (d9e8 <z_cstart+0xec>)
    d96e:	4628      	mov	r0, r5
	_kernel.ready_q.cache = &z_main_thread;
    d970:	6275      	str	r5, [r6, #36]	; 0x24
	z_setup_new_thread(&z_main_thread, z_main_stack,
    d972:	f000 fa15 	bl	dda0 <z_setup_new_thread>
	sys_trace_thread_resume(thread);
}

static inline void z_mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
    d976:	7b6b      	ldrb	r3, [r5, #13]
    d978:	f023 0204 	bic.w	r2, r3, #4
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
    d97c:	f013 0f1b 	tst.w	r3, #27
	thread->base.thread_state &= ~_THREAD_PRESTART;
    d980:	736a      	strb	r2, [r5, #13]
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
    d982:	d104      	bne.n	d98e <z_cstart+0x92>
	return true;
}

static ALWAYS_INLINE void z_ready_thread(struct k_thread *thread)
{
	if (z_is_thread_ready(thread)) {
    d984:	69ab      	ldr	r3, [r5, #24]
    d986:	b913      	cbnz	r3, d98e <z_cstart+0x92>
		z_add_thread_to_ready_q(thread);
    d988:	4628      	mov	r0, r5
    d98a:	f000 f8df 	bl	db4c <z_add_thread_to_ready_q>
	z_setup_new_thread(thread, stack,
    d98e:	4b17      	ldr	r3, [pc, #92]	; (d9ec <z_cstart+0xf0>)
    d990:	2201      	movs	r2, #1
    d992:	9305      	str	r3, [sp, #20]
    d994:	230f      	movs	r3, #15
    d996:	e9cd 3203 	strd	r3, r2, [sp, #12]
    d99a:	2300      	movs	r3, #0
    d99c:	4d14      	ldr	r5, [pc, #80]	; (d9f0 <z_cstart+0xf4>)
    d99e:	e9cd 3301 	strd	r3, r3, [sp, #4]
    d9a2:	9300      	str	r3, [sp, #0]
    d9a4:	f44f 72a0 	mov.w	r2, #320	; 0x140
    d9a8:	4b12      	ldr	r3, [pc, #72]	; (d9f4 <z_cstart+0xf8>)
    d9aa:	4913      	ldr	r1, [pc, #76]	; (d9f8 <z_cstart+0xfc>)
    d9ac:	4628      	mov	r0, r5
    d9ae:	f000 f9f7 	bl	dda0 <z_setup_new_thread>
	thread->base.thread_state &= ~_THREAD_PRESTART;
    d9b2:	7b6b      	ldrb	r3, [r5, #13]
	arch_switch_to_main_thread(&z_main_thread, z_main_stack,
    d9b4:	f44f 6280 	mov.w	r2, #1024	; 0x400
    d9b8:	f023 0304 	bic.w	r3, r3, #4
    d9bc:	736b      	strb	r3, [r5, #13]
 * @return N/A
 */

static inline void sys_dlist_init(sys_dlist_t *list)
{
	list->head = (sys_dnode_t *)list;
    d9be:	4b0f      	ldr	r3, [pc, #60]	; (d9fc <z_cstart+0x100>)
    d9c0:	4909      	ldr	r1, [pc, #36]	; (d9e8 <z_cstart+0xec>)
	list->tail = (sys_dnode_t *)list;
    d9c2:	e9c6 3306 	strd	r3, r3, [r6, #24]
    d9c6:	4805      	ldr	r0, [pc, #20]	; (d9dc <z_cstart+0xe0>)
    d9c8:	4b06      	ldr	r3, [pc, #24]	; (d9e4 <z_cstart+0xe8>)
	_kernel.cpus[0].idle_thread = &z_idle_thread;
    d9ca:	60f5      	str	r5, [r6, #12]
	arch_switch_to_main_thread(&z_main_thread, z_main_stack,
    d9cc:	f7ff f8c8 	bl	cb60 <arch_switch_to_main_thread>
	CODE_UNREACHABLE; /* LCOV_EXCL_LINE */
    d9d0:	20020eb8 	.word	0x20020eb8
    d9d4:	e000ed00 	.word	0xe000ed00
    d9d8:	20020134 	.word	0x20020134
    d9dc:	200200c8 	.word	0x200200c8
    d9e0:	0000ed43 	.word	0x0000ed43
    d9e4:	0000d8b5 	.word	0x0000d8b5
    d9e8:	20020178 	.word	0x20020178
    d9ec:	0000ed48 	.word	0x0000ed48
    d9f0:	2002005c 	.word	0x2002005c
    d9f4:	0000d839 	.word	0x0000d839
    d9f8:	20020578 	.word	0x20020578
    d9fc:	2002014c 	.word	0x2002014c

0000da00 <z_reset_time_slice>:
 */
static struct k_thread *pending_current;
#endif

void z_reset_time_slice(void)
{
    da00:	b510      	push	{r4, lr}
	/* Add the elapsed time since the last announced tick to the
	 * slice count, as we'll see those "expired" ticks arrive in a
	 * FUTURE z_time_slice() call.
	 */
	if (slice_time != 0) {
    da02:	4c08      	ldr	r4, [pc, #32]	; (da24 <z_reset_time_slice+0x24>)
    da04:	6823      	ldr	r3, [r4, #0]
    da06:	b15b      	cbz	r3, da20 <z_reset_time_slice+0x20>
		_current_cpu->slice_ticks = slice_time + z_clock_elapsed();
    da08:	f7fe ffaa 	bl	c960 <z_clock_elapsed>
    da0c:	6823      	ldr	r3, [r4, #0]
    da0e:	4a06      	ldr	r2, [pc, #24]	; (da28 <z_reset_time_slice+0x28>)
    da10:	4418      	add	r0, r3
    da12:	6110      	str	r0, [r2, #16]
		z_set_timeout_expiry(slice_time, false);
    da14:	2100      	movs	r1, #0
	}
}
    da16:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		z_set_timeout_expiry(slice_time, false);
    da1a:	4618      	mov	r0, r3
    da1c:	f000 bf9e 	b.w	e95c <z_set_timeout_expiry>
}
    da20:	bd10      	pop	{r4, pc}
    da22:	bf00      	nop
    da24:	2002016c 	.word	0x2002016c
    da28:	20020134 	.word	0x20020134

0000da2c <k_sched_time_slice_set>:

void k_sched_time_slice_set(s32_t slice, int prio)
{
    da2c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    da2e:	460d      	mov	r5, r1
    da30:	f04f 0320 	mov.w	r3, #32
    da34:	f3ef 8411 	mrs	r4, BASEPRI
    da38:	f383 8811 	msr	BASEPRI, r3
    da3c:	f3bf 8f6f 	isb	sy
		} else {
			return t * (to_hz / from_hz);
		}
	} else {
		if (result32) {
			return (u32_t)((t * to_hz + off) / from_hz);
    da40:	f44f 4100 	mov.w	r1, #32768	; 0x8000
    da44:	f240 36e7 	movw	r6, #999	; 0x3e7
    da48:	2700      	movs	r7, #0
	LOCKED(&sched_spinlock) {
		_current_cpu->slice_ticks = 0;
    da4a:	2200      	movs	r2, #0
    da4c:	fbe1 6700 	umlal	r6, r7, r1, r0
    da50:	4b09      	ldr	r3, [pc, #36]	; (da78 <k_sched_time_slice_set+0x4c>)
    da52:	4630      	mov	r0, r6
    da54:	611a      	str	r2, [r3, #16]
    da56:	4639      	mov	r1, r7
    da58:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    da5c:	2300      	movs	r3, #0
    da5e:	f7fe fbed 	bl	c23c <__aeabi_uldivmod>
		slice_time = k_ms_to_ticks_ceil32(slice);
    da62:	4b06      	ldr	r3, [pc, #24]	; (da7c <k_sched_time_slice_set+0x50>)
    da64:	6018      	str	r0, [r3, #0]
		slice_max_prio = prio;
    da66:	4b06      	ldr	r3, [pc, #24]	; (da80 <k_sched_time_slice_set+0x54>)
    da68:	601d      	str	r5, [r3, #0]
		z_reset_time_slice();
    da6a:	f7ff ffc9 	bl	da00 <z_reset_time_slice>
	__asm__ volatile(
    da6e:	f384 8811 	msr	BASEPRI, r4
    da72:	f3bf 8f6f 	isb	sy
	}
}
    da76:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    da78:	20020134 	.word	0x20020134
    da7c:	2002016c 	.word	0x2002016c
    da80:	20020168 	.word	0x20020168

0000da84 <k_sched_lock>:
	__asm__ volatile(
    da84:	f04f 0320 	mov.w	r3, #32
    da88:	f3ef 8111 	mrs	r1, BASEPRI
    da8c:	f383 8811 	msr	BASEPRI, r3
    da90:	f3bf 8f6f 	isb	sy
{
#ifdef CONFIG_PREEMPT_ENABLED
	__ASSERT(!arch_is_in_isr(), "");
	__ASSERT(_current->base.sched_locked != 1, "");

	--_current->base.sched_locked;
    da94:	4b04      	ldr	r3, [pc, #16]	; (daa8 <k_sched_lock+0x24>)
    da96:	689a      	ldr	r2, [r3, #8]
    da98:	7bd3      	ldrb	r3, [r2, #15]
    da9a:	3b01      	subs	r3, #1
    da9c:	73d3      	strb	r3, [r2, #15]
	__asm__ volatile(
    da9e:	f381 8811 	msr	BASEPRI, r1
    daa2:	f3bf 8f6f 	isb	sy
void k_sched_lock(void)
{
	LOCKED(&sched_spinlock) {
		z_sched_lock();
	}
}
    daa6:	4770      	bx	lr
    daa8:	20020134 	.word	0x20020134

0000daac <z_priq_dumb_remove>:
}

void z_priq_dumb_remove(sys_dlist_t *pq, struct k_thread *thread)
{
#if defined(CONFIG_SWAP_NONATOMIC) && defined(CONFIG_SCHED_DUMB)
	if (pq == &_kernel.ready_q.runq && thread == _current &&
    daac:	4b09      	ldr	r3, [pc, #36]	; (dad4 <z_priq_dumb_remove+0x28>)
    daae:	f103 0228 	add.w	r2, r3, #40	; 0x28
    dab2:	4282      	cmp	r2, r0
    dab4:	d105      	bne.n	dac2 <z_priq_dumb_remove+0x16>
    dab6:	689b      	ldr	r3, [r3, #8]
    dab8:	428b      	cmp	r3, r1
    daba:	d102      	bne.n	dac2 <z_priq_dumb_remove+0x16>
    dabc:	7b4b      	ldrb	r3, [r1, #13]
    dabe:	06db      	lsls	r3, r3, #27
    dac0:	d106      	bne.n	dad0 <z_priq_dumb_remove+0x24>
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
    dac2:	e9d1 3200 	ldrd	r3, r2, [r1]
    dac6:	6013      	str	r3, [r2, #0]
	node->next->prev = node->prev;
    dac8:	605a      	str	r2, [r3, #4]
	node->next = NULL;
    daca:	2300      	movs	r3, #0
	node->prev = NULL;
    dacc:	e9c1 3300 	strd	r3, r3, [r1]
#endif

	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));

	sys_dlist_remove(&thread->base.qnode_dlist);
}
    dad0:	4770      	bx	lr
    dad2:	bf00      	nop
    dad4:	20020134 	.word	0x20020134

0000dad8 <update_cache>:
{
    dad8:	b538      	push	{r3, r4, r5, lr}
	struct k_thread *thread = _priq_run_best(&_kernel.ready_q.runq);
    dada:	4c0d      	ldr	r4, [pc, #52]	; (db10 <update_cache+0x38>)
{
    dadc:	4602      	mov	r2, r0
	struct k_thread *thread = _priq_run_best(&_kernel.ready_q.runq);
    dade:	f104 0028 	add.w	r0, r4, #40	; 0x28
    dae2:	f000 fecf 	bl	e884 <z_priq_dumb_best>
	return thread ? thread : _current_cpu->idle_thread;
    dae6:	4605      	mov	r5, r0
    dae8:	b900      	cbnz	r0, daec <update_cache+0x14>
    daea:	68e5      	ldr	r5, [r4, #12]
	if (preempt_ok != 0) {
    daec:	68a3      	ldr	r3, [r4, #8]
    daee:	b94a      	cbnz	r2, db04 <update_cache+0x2c>
	if (z_is_thread_prevented_from_running(_current)) {
    daf0:	7b5a      	ldrb	r2, [r3, #13]
    daf2:	06d2      	lsls	r2, r2, #27
    daf4:	d106      	bne.n	db04 <update_cache+0x2c>
	if (IS_ENABLED(CONFIG_SWAP_NONATOMIC)
    daf6:	69aa      	ldr	r2, [r5, #24]
    daf8:	b922      	cbnz	r2, db04 <update_cache+0x2c>
	if (is_preempt(_current) || is_metairq(thread)) {
    dafa:	89da      	ldrh	r2, [r3, #14]
    dafc:	2a7f      	cmp	r2, #127	; 0x7f
    dafe:	d901      	bls.n	db04 <update_cache+0x2c>
		_kernel.ready_q.cache = _current;
    db00:	6263      	str	r3, [r4, #36]	; 0x24
}
    db02:	bd38      	pop	{r3, r4, r5, pc}
		if (thread != _current) {
    db04:	429d      	cmp	r5, r3
    db06:	d001      	beq.n	db0c <update_cache+0x34>
			z_reset_time_slice();
    db08:	f7ff ff7a 	bl	da00 <z_reset_time_slice>
		_kernel.ready_q.cache = thread;
    db0c:	6265      	str	r5, [r4, #36]	; 0x24
}
    db0e:	e7f8      	b.n	db02 <update_cache+0x2a>
    db10:	20020134 	.word	0x20020134

0000db14 <k_sched_unlock>:
{
    db14:	b510      	push	{r4, lr}
	__asm__ volatile(
    db16:	f04f 0320 	mov.w	r3, #32
    db1a:	f3ef 8411 	mrs	r4, BASEPRI
    db1e:	f383 8811 	msr	BASEPRI, r3
    db22:	f3bf 8f6f 	isb	sy
		++_current->base.sched_locked;
    db26:	4b08      	ldr	r3, [pc, #32]	; (db48 <k_sched_unlock+0x34>)
		update_cache(0);
    db28:	2000      	movs	r0, #0
		++_current->base.sched_locked;
    db2a:	689a      	ldr	r2, [r3, #8]
    db2c:	7bd3      	ldrb	r3, [r2, #15]
    db2e:	3301      	adds	r3, #1
    db30:	73d3      	strb	r3, [r2, #15]
		update_cache(0);
    db32:	f7ff ffd1 	bl	dad8 <update_cache>
	__asm__ volatile(
    db36:	f384 8811 	msr	BASEPRI, r4
    db3a:	f3bf 8f6f 	isb	sy
}
    db3e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	z_reschedule_unlocked();
    db42:	f000 be95 	b.w	e870 <z_reschedule_unlocked>
    db46:	bf00      	nop
    db48:	20020134 	.word	0x20020134

0000db4c <z_add_thread_to_ready_q>:
{
    db4c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	__asm__ volatile(
    db4e:	f04f 0320 	mov.w	r3, #32
    db52:	f3ef 8411 	mrs	r4, BASEPRI
    db56:	f383 8811 	msr	BASEPRI, r3
    db5a:	f3bf 8f6f 	isb	sy
	return list->head == list;
    db5e:	4a15      	ldr	r2, [pc, #84]	; (dbb4 <z_add_thread_to_ready_q+0x68>)
    db60:	4611      	mov	r1, r2
    db62:	f851 3f28 	ldr.w	r3, [r1, #40]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
    db66:	428b      	cmp	r3, r1
    db68:	d01d      	beq.n	dba6 <z_add_thread_to_ready_q+0x5a>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    db6a:	b1e3      	cbz	r3, dba6 <z_add_thread_to_ready_q+0x5a>
    db6c:	6ad6      	ldr	r6, [r2, #44]	; 0x2c
	if (thread_1->base.prio < thread_2->base.prio) {
    db6e:	f990 500e 	ldrsb.w	r5, [r0, #14]
    db72:	f993 700e 	ldrsb.w	r7, [r3, #14]
    db76:	42af      	cmp	r7, r5
    db78:	dd10      	ble.n	db9c <z_add_thread_to_ready_q+0x50>
	node->prev = successor->prev;
    db7a:	685a      	ldr	r2, [r3, #4]
	node->next = successor;
    db7c:	e9c0 3200 	strd	r3, r2, [r0]
	successor->prev->next = node;
    db80:	6010      	str	r0, [r2, #0]
	successor->prev = node;
    db82:	6058      	str	r0, [r3, #4]
	thread->base.thread_state |= states;
    db84:	7b43      	ldrb	r3, [r0, #13]
    db86:	f063 037f 	orn	r3, r3, #127	; 0x7f
    db8a:	7343      	strb	r3, [r0, #13]
		update_cache(0);
    db8c:	2000      	movs	r0, #0
    db8e:	f7ff ffa3 	bl	dad8 <update_cache>
	__asm__ volatile(
    db92:	f384 8811 	msr	BASEPRI, r4
    db96:	f3bf 8f6f 	isb	sy
}
    db9a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	return (node == list->tail) ? NULL : node->next;
    db9c:	42b3      	cmp	r3, r6
    db9e:	d002      	beq.n	dba6 <z_add_thread_to_ready_q+0x5a>
    dba0:	681b      	ldr	r3, [r3, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    dba2:	2b00      	cmp	r3, #0
    dba4:	d1e5      	bne.n	db72 <z_add_thread_to_ready_q+0x26>
	node->prev = list->tail;
    dba6:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
	node->next = list;
    dba8:	6001      	str	r1, [r0, #0]
	node->prev = list->tail;
    dbaa:	6043      	str	r3, [r0, #4]
	list->tail->next = node;
    dbac:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
    dbae:	6018      	str	r0, [r3, #0]
	list->tail = node;
    dbb0:	62d0      	str	r0, [r2, #44]	; 0x2c
    dbb2:	e7e7      	b.n	db84 <z_add_thread_to_ready_q+0x38>
    dbb4:	20020134 	.word	0x20020134

0000dbb8 <z_move_thread_to_end_of_prio_q>:
{
    dbb8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    dbba:	4604      	mov	r4, r0
	__asm__ volatile(
    dbbc:	f04f 0320 	mov.w	r3, #32
    dbc0:	f3ef 8511 	mrs	r5, BASEPRI
    dbc4:	f383 8811 	msr	BASEPRI, r3
    dbc8:	f3bf 8f6f 	isb	sy
		if (z_is_thread_queued(thread)) {
    dbcc:	f990 300d 	ldrsb.w	r3, [r0, #13]
    dbd0:	2b00      	cmp	r3, #0
    dbd2:	da03      	bge.n	dbdc <z_move_thread_to_end_of_prio_q+0x24>
			_priq_run_remove(&_kernel.ready_q.runq, thread);
    dbd4:	4601      	mov	r1, r0
    dbd6:	4818      	ldr	r0, [pc, #96]	; (dc38 <z_move_thread_to_end_of_prio_q+0x80>)
    dbd8:	f7ff ff68 	bl	daac <z_priq_dumb_remove>
	return list->head == list;
    dbdc:	4a17      	ldr	r2, [pc, #92]	; (dc3c <z_move_thread_to_end_of_prio_q+0x84>)
	return sys_dlist_is_empty(list) ? NULL : list->head;
    dbde:	f102 0128 	add.w	r1, r2, #40	; 0x28
    dbe2:	e9d2 300a 	ldrd	r3, r0, [r2, #40]	; 0x28
    dbe6:	428b      	cmp	r3, r1
    dbe8:	d01f      	beq.n	dc2a <z_move_thread_to_end_of_prio_q+0x72>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    dbea:	b1f3      	cbz	r3, dc2a <z_move_thread_to_end_of_prio_q+0x72>
	if (thread_1->base.prio < thread_2->base.prio) {
    dbec:	f994 600e 	ldrsb.w	r6, [r4, #14]
    dbf0:	f993 700e 	ldrsb.w	r7, [r3, #14]
    dbf4:	42b7      	cmp	r7, r6
    dbf6:	dd13      	ble.n	dc20 <z_move_thread_to_end_of_prio_q+0x68>
	node->prev = successor->prev;
    dbf8:	6859      	ldr	r1, [r3, #4]
	node->next = successor;
    dbfa:	e9c4 3100 	strd	r3, r1, [r4]
	successor->prev->next = node;
    dbfe:	600c      	str	r4, [r1, #0]
	successor->prev = node;
    dc00:	605c      	str	r4, [r3, #4]
    dc02:	7b63      	ldrb	r3, [r4, #13]
		update_cache(thread == _current);
    dc04:	6890      	ldr	r0, [r2, #8]
    dc06:	f063 037f 	orn	r3, r3, #127	; 0x7f
    dc0a:	7363      	strb	r3, [r4, #13]
    dc0c:	1b03      	subs	r3, r0, r4
    dc0e:	4258      	negs	r0, r3
    dc10:	4158      	adcs	r0, r3
    dc12:	f7ff ff61 	bl	dad8 <update_cache>
	__asm__ volatile(
    dc16:	f385 8811 	msr	BASEPRI, r5
    dc1a:	f3bf 8f6f 	isb	sy
}
    dc1e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	return (node == list->tail) ? NULL : node->next;
    dc20:	4298      	cmp	r0, r3
    dc22:	d002      	beq.n	dc2a <z_move_thread_to_end_of_prio_q+0x72>
    dc24:	681b      	ldr	r3, [r3, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    dc26:	2b00      	cmp	r3, #0
    dc28:	d1e2      	bne.n	dbf0 <z_move_thread_to_end_of_prio_q+0x38>
	node->prev = list->tail;
    dc2a:	e9c4 1000 	strd	r1, r0, [r4]
	list->tail->next = node;
    dc2e:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
    dc30:	601c      	str	r4, [r3, #0]
	list->tail = node;
    dc32:	62d4      	str	r4, [r2, #44]	; 0x2c
    dc34:	e7e5      	b.n	dc02 <z_move_thread_to_end_of_prio_q+0x4a>
    dc36:	bf00      	nop
    dc38:	2002015c 	.word	0x2002015c
    dc3c:	20020134 	.word	0x20020134

0000dc40 <z_time_slice>:
	if (pending_current == _current) {
    dc40:	4a15      	ldr	r2, [pc, #84]	; (dc98 <z_time_slice+0x58>)
    dc42:	4916      	ldr	r1, [pc, #88]	; (dc9c <z_time_slice+0x5c>)
{
    dc44:	b538      	push	{r3, r4, r5, lr}
	if (pending_current == _current) {
    dc46:	680c      	ldr	r4, [r1, #0]
    dc48:	6893      	ldr	r3, [r2, #8]
    dc4a:	42a3      	cmp	r3, r4
    dc4c:	4614      	mov	r4, r2
    dc4e:	d103      	bne.n	dc58 <z_time_slice+0x18>
}
    dc50:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
			z_reset_time_slice();
    dc54:	f7ff bed4 	b.w	da00 <z_reset_time_slice>
	pending_current = NULL;
    dc58:	2500      	movs	r5, #0
    dc5a:	600d      	str	r5, [r1, #0]
	if (slice_time && sliceable(_current)) {
    dc5c:	4910      	ldr	r1, [pc, #64]	; (dca0 <z_time_slice+0x60>)
    dc5e:	6809      	ldr	r1, [r1, #0]
    dc60:	b1b9      	cbz	r1, dc92 <z_time_slice+0x52>
		&& !z_is_thread_timeout_active(thread);
    dc62:	89d9      	ldrh	r1, [r3, #14]
    dc64:	297f      	cmp	r1, #127	; 0x7f
    dc66:	d814      	bhi.n	dc92 <z_time_slice+0x52>
		&& !z_is_prio_higher(thread->base.prio, slice_max_prio)
    dc68:	490e      	ldr	r1, [pc, #56]	; (dca4 <z_time_slice+0x64>)
    dc6a:	f993 500e 	ldrsb.w	r5, [r3, #14]
    dc6e:	6809      	ldr	r1, [r1, #0]
    dc70:	428d      	cmp	r5, r1
    dc72:	db0e      	blt.n	dc92 <z_time_slice+0x52>
		&& !z_is_idle_thread_object(thread)
    dc74:	490c      	ldr	r1, [pc, #48]	; (dca8 <z_time_slice+0x68>)
    dc76:	428b      	cmp	r3, r1
    dc78:	d00b      	beq.n	dc92 <z_time_slice+0x52>
		&& !z_is_thread_timeout_active(thread);
    dc7a:	6999      	ldr	r1, [r3, #24]
    dc7c:	b949      	cbnz	r1, dc92 <z_time_slice+0x52>
		if (ticks >= _current_cpu->slice_ticks) {
    dc7e:	6911      	ldr	r1, [r2, #16]
    dc80:	4281      	cmp	r1, r0
    dc82:	dc03      	bgt.n	dc8c <z_time_slice+0x4c>
			z_move_thread_to_end_of_prio_q(_current);
    dc84:	4618      	mov	r0, r3
    dc86:	f7ff ff97 	bl	dbb8 <z_move_thread_to_end_of_prio_q>
    dc8a:	e7e1      	b.n	dc50 <z_time_slice+0x10>
			_current_cpu->slice_ticks -= ticks;
    dc8c:	1a09      	subs	r1, r1, r0
    dc8e:	6111      	str	r1, [r2, #16]
}
    dc90:	bd38      	pop	{r3, r4, r5, pc}
		_current_cpu->slice_ticks = 0;
    dc92:	2300      	movs	r3, #0
    dc94:	6123      	str	r3, [r4, #16]
    dc96:	e7fb      	b.n	dc90 <z_time_slice+0x50>
    dc98:	20020134 	.word	0x20020134
    dc9c:	20020164 	.word	0x20020164
    dca0:	2002016c 	.word	0x2002016c
    dca4:	20020168 	.word	0x20020168
    dca8:	2002005c 	.word	0x2002005c

0000dcac <z_thread_single_abort>:
	if (thread->fn_abort != NULL) {
    dcac:	6d03      	ldr	r3, [r0, #80]	; 0x50
{
    dcae:	b570      	push	{r4, r5, r6, lr}
    dcb0:	4604      	mov	r4, r0
	if (thread->fn_abort != NULL) {
    dcb2:	b103      	cbz	r3, dcb6 <z_thread_single_abort+0xa>
		thread->fn_abort();
    dcb4:	4798      	blx	r3
	z_add_timeout(&th->base.timeout, z_thread_timeout, ticks);
}

static inline int z_abort_thread_timeout(struct k_thread *thread)
{
	return z_abort_timeout(&thread->base.timeout);
    dcb6:	f104 0018 	add.w	r0, r4, #24
    dcba:	f000 fe29 	bl	e910 <z_abort_timeout>
	__asm__ volatile(
    dcbe:	f04f 0320 	mov.w	r3, #32
    dcc2:	f3ef 8511 	mrs	r5, BASEPRI
    dcc6:	f383 8811 	msr	BASEPRI, r3
    dcca:	f3bf 8f6f 	isb	sy
		if (z_is_thread_ready(thread)) {
    dcce:	4620      	mov	r0, r4
    dcd0:	f000 fdae 	bl	e830 <z_is_thread_ready>
    dcd4:	4606      	mov	r6, r0
    dcd6:	b1d8      	cbz	r0, dd10 <z_thread_single_abort+0x64>
			if (z_is_thread_queued(thread)) {
    dcd8:	f994 300d 	ldrsb.w	r3, [r4, #13]
    dcdc:	2b00      	cmp	r3, #0
    dcde:	da07      	bge.n	dcf0 <z_thread_single_abort+0x44>
				_priq_run_remove(&_kernel.ready_q.runq,
    dce0:	4621      	mov	r1, r4
    dce2:	4812      	ldr	r0, [pc, #72]	; (dd2c <z_thread_single_abort+0x80>)
    dce4:	f7ff fee2 	bl	daac <z_priq_dumb_remove>
	thread->base.thread_state &= ~states;
    dce8:	7b63      	ldrb	r3, [r4, #13]
    dcea:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    dcee:	7363      	strb	r3, [r4, #13]
			update_cache(thread == _current);
    dcf0:	4b0f      	ldr	r3, [pc, #60]	; (dd30 <z_thread_single_abort+0x84>)
    dcf2:	6898      	ldr	r0, [r3, #8]
    dcf4:	1b02      	subs	r2, r0, r4
    dcf6:	4250      	negs	r0, r2
    dcf8:	4150      	adcs	r0, r2
    dcfa:	f7ff feed 	bl	dad8 <update_cache>
		thread->base.thread_state |= mask;
    dcfe:	7b63      	ldrb	r3, [r4, #13]
    dd00:	f043 0308 	orr.w	r3, r3, #8
    dd04:	7363      	strb	r3, [r4, #13]
	__asm__ volatile(
    dd06:	f385 8811 	msr	BASEPRI, r5
    dd0a:	f3bf 8f6f 	isb	sy
}
    dd0e:	bd70      	pop	{r4, r5, r6, pc}
			if (z_is_thread_pending(thread)) {
    dd10:	7b63      	ldrb	r3, [r4, #13]
    dd12:	079b      	lsls	r3, r3, #30
    dd14:	d5f3      	bpl.n	dcfe <z_thread_single_abort+0x52>
				_priq_wait_remove(&pended_on(thread)->waitq,
    dd16:	4621      	mov	r1, r4
    dd18:	68a0      	ldr	r0, [r4, #8]
    dd1a:	f7ff fec7 	bl	daac <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
    dd1e:	7b63      	ldrb	r3, [r4, #13]
				thread->base.pended_on = NULL;
    dd20:	60a6      	str	r6, [r4, #8]
    dd22:	f023 0302 	bic.w	r3, r3, #2
    dd26:	7363      	strb	r3, [r4, #13]
    dd28:	e7e9      	b.n	dcfe <z_thread_single_abort+0x52>
    dd2a:	bf00      	nop
    dd2c:	2002015c 	.word	0x2002015c
    dd30:	20020134 	.word	0x20020134

0000dd34 <z_sched_init>:
		sys_dlist_init(&_kernel.ready_q.runq.queues[i]);
	}
#endif

#ifdef CONFIG_TIMESLICING
	k_sched_time_slice_set(CONFIG_TIMESLICE_SIZE,
    dd34:	2100      	movs	r1, #0
	list->head = (sys_dnode_t *)list;
    dd36:	4b04      	ldr	r3, [pc, #16]	; (dd48 <z_sched_init+0x14>)
    dd38:	4608      	mov	r0, r1
    dd3a:	f103 0228 	add.w	r2, r3, #40	; 0x28
	list->tail = (sys_dnode_t *)list;
    dd3e:	e9c3 220a 	strd	r2, r2, [r3, #40]	; 0x28
    dd42:	f7ff be73 	b.w	da2c <k_sched_time_slice_set>
    dd46:	bf00      	nop
    dd48:	20020134 	.word	0x20020134

0000dd4c <z_impl_k_current_get>:
#endif

k_tid_t z_impl_k_current_get(void)
{
	return _current;
}
    dd4c:	4b01      	ldr	r3, [pc, #4]	; (dd54 <z_impl_k_current_get+0x8>)
    dd4e:	6898      	ldr	r0, [r3, #8]
    dd50:	4770      	bx	lr
    dd52:	bf00      	nop
    dd54:	20020134 	.word	0x20020134

0000dd58 <z_impl_k_thread_start>:
}
#endif

#ifdef CONFIG_MULTITHREADING
void z_impl_k_thread_start(struct k_thread *thread)
{
    dd58:	b510      	push	{r4, lr}
	__asm__ volatile(
    dd5a:	f04f 0220 	mov.w	r2, #32
    dd5e:	f3ef 8411 	mrs	r4, BASEPRI
    dd62:	f382 8811 	msr	BASEPRI, r2
    dd66:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&lock); /* protect kernel queues */

	if (z_has_thread_started(thread)) {
    dd6a:	7b42      	ldrb	r2, [r0, #13]
    dd6c:	0751      	lsls	r1, r2, #29
    dd6e:	d404      	bmi.n	dd7a <z_impl_k_thread_start+0x22>
	__asm__ volatile(
    dd70:	f384 8811 	msr	BASEPRI, r4
    dd74:	f3bf 8f6f 	isb	sy
	}

	z_mark_thread_as_started(thread);
	z_ready_thread(thread);
	z_reschedule(&lock, key);
}
    dd78:	bd10      	pop	{r4, pc}
	thread->base.thread_state &= ~_THREAD_PRESTART;
    dd7a:	f022 0104 	bic.w	r1, r2, #4
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
    dd7e:	f012 0f1b 	tst.w	r2, #27
	thread->base.thread_state &= ~_THREAD_PRESTART;
    dd82:	7341      	strb	r1, [r0, #13]
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
    dd84:	d103      	bne.n	dd8e <z_impl_k_thread_start+0x36>
	if (z_is_thread_ready(thread)) {
    dd86:	6983      	ldr	r3, [r0, #24]
    dd88:	b90b      	cbnz	r3, dd8e <z_impl_k_thread_start+0x36>
		z_add_thread_to_ready_q(thread);
    dd8a:	f7ff fedf 	bl	db4c <z_add_thread_to_ready_q>
	z_reschedule(&lock, key);
    dd8e:	4621      	mov	r1, r4
}
    dd90:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	z_reschedule(&lock, key);
    dd94:	4801      	ldr	r0, [pc, #4]	; (dd9c <z_impl_k_thread_start+0x44>)
    dd96:	f000 bd54 	b.w	e842 <z_reschedule>
    dd9a:	bf00      	nop
    dd9c:	20020177 	.word	0x20020177

0000dda0 <z_setup_new_thread>:
void z_setup_new_thread(struct k_thread *new_thread,
		       k_thread_stack_t *stack, size_t stack_size,
		       k_thread_entry_t entry,
		       void *p1, void *p2, void *p3,
		       int prio, u32_t options, const char *name)
{
    dda0:	b530      	push	{r4, r5, lr}
    dda2:	b087      	sub	sp, #28
	stack_size = STACK_ROUND_DOWN(stack_size
			- sizeof(*new_thread->userspace_local_data));
#endif
#endif

	arch_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
    dda4:	9d0e      	ldr	r5, [sp, #56]	; 0x38
{
    dda6:	4604      	mov	r4, r0
	arch_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
    dda8:	9504      	str	r5, [sp, #16]
    ddaa:	9d0d      	ldr	r5, [sp, #52]	; 0x34
    ddac:	9503      	str	r5, [sp, #12]
    ddae:	9d0c      	ldr	r5, [sp, #48]	; 0x30
    ddb0:	9502      	str	r5, [sp, #8]
    ddb2:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
    ddb4:	9501      	str	r5, [sp, #4]
    ddb6:	9d0a      	ldr	r5, [sp, #40]	; 0x28
    ddb8:	9500      	str	r5, [sp, #0]
    ddba:	f7fe feaf 	bl	cb1c <arch_new_thread>
#ifdef CONFIG_SCHED_CPU_MASK
	new_thread->base.cpu_mask = -1;
#endif
#ifdef CONFIG_ARCH_HAS_CUSTOM_SWAP_TO_MAIN
	/* _current may be null if the dummy thread is not used */
	if (!_current) {
    ddbe:	4b03      	ldr	r3, [pc, #12]	; (ddcc <z_setup_new_thread+0x2c>)
    ddc0:	689b      	ldr	r3, [r3, #8]
    ddc2:	b103      	cbz	r3, ddc6 <z_setup_new_thread+0x26>
	}
#endif
#ifdef CONFIG_SCHED_DEADLINE
	new_thread->base.prio_deadline = 0;
#endif
	new_thread->resource_pool = _current->resource_pool;
    ddc4:	6e1b      	ldr	r3, [r3, #96]	; 0x60
    ddc6:	6623      	str	r3, [r4, #96]	; 0x60
	sys_trace_thread_create(new_thread);
}
    ddc8:	b007      	add	sp, #28
    ddca:	bd30      	pop	{r4, r5, pc}
    ddcc:	20020134 	.word	0x20020134

0000ddd0 <z_init_static_threads>:
	}
}
#endif /* CONFIG_USERSPACE */

void z_init_static_threads(void)
{
    ddd0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	_FOREACH_STATIC_THREAD(thread_data) {
    ddd4:	4e28      	ldr	r6, [pc, #160]	; (de78 <z_init_static_threads+0xa8>)
    ddd6:	4d29      	ldr	r5, [pc, #164]	; (de7c <z_init_static_threads+0xac>)
    ddd8:	46b0      	mov	r8, r6
{
    ddda:	b087      	sub	sp, #28
	_FOREACH_STATIC_THREAD(thread_data) {
    dddc:	42b5      	cmp	r5, r6
    ddde:	f105 0430 	add.w	r4, r5, #48	; 0x30
    dde2:	d310      	bcc.n	de06 <z_init_static_threads+0x36>
	 * until they are all started.
	 *
	 * Note that static threads defined using the legacy API have a
	 * delay of K_FOREVER.
	 */
	k_sched_lock();
    dde4:	f7ff fe4e 	bl	da84 <k_sched_lock>
    dde8:	f44f 4900 	mov.w	r9, #32768	; 0x8000
    ddec:	f240 36e7 	movw	r6, #999	; 0x3e7
    ddf0:	2700      	movs	r7, #0
	_FOREACH_STATIC_THREAD(thread_data) {
    ddf2:	4c22      	ldr	r4, [pc, #136]	; (de7c <z_init_static_threads+0xac>)
	z_add_timeout(&th->base.timeout, z_thread_timeout, ticks);
    ddf4:	f8df a088 	ldr.w	sl, [pc, #136]	; de80 <z_init_static_threads+0xb0>
    ddf8:	4544      	cmp	r4, r8
    ddfa:	d321      	bcc.n	de40 <z_init_static_threads+0x70>
			schedule_new_thread(thread_data->init_thread,
					    thread_data->init_delay);
		}
	}
	k_sched_unlock();
}
    ddfc:	b007      	add	sp, #28
    ddfe:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	k_sched_unlock();
    de02:	f7ff be87 	b.w	db14 <k_sched_unlock>
		z_setup_new_thread(
    de06:	f854 3c04 	ldr.w	r3, [r4, #-4]
    de0a:	9305      	str	r3, [sp, #20]
    de0c:	f854 3c10 	ldr.w	r3, [r4, #-16]
    de10:	9304      	str	r3, [sp, #16]
    de12:	f854 3c14 	ldr.w	r3, [r4, #-20]
    de16:	9303      	str	r3, [sp, #12]
    de18:	f854 3c18 	ldr.w	r3, [r4, #-24]
    de1c:	9302      	str	r3, [sp, #8]
    de1e:	f854 3c1c 	ldr.w	r3, [r4, #-28]
    de22:	9301      	str	r3, [sp, #4]
    de24:	f854 3c20 	ldr.w	r3, [r4, #-32]
    de28:	9300      	str	r3, [sp, #0]
    de2a:	e954 230a 	ldrd	r2, r3, [r4, #-40]	; 0x28
    de2e:	e954 010c 	ldrd	r0, r1, [r4, #-48]	; 0x30
    de32:	f7ff ffb5 	bl	dda0 <z_setup_new_thread>
		thread_data->init_thread->init_data = thread_data;
    de36:	f854 3c30 	ldr.w	r3, [r4, #-48]
    de3a:	64dd      	str	r5, [r3, #76]	; 0x4c
    de3c:	4625      	mov	r5, r4
    de3e:	e7cd      	b.n	dddc <z_init_static_threads+0xc>
		if (thread_data->init_delay != K_FOREVER) {
    de40:	6a61      	ldr	r1, [r4, #36]	; 0x24
    de42:	1c4b      	adds	r3, r1, #1
    de44:	d004      	beq.n	de50 <z_init_static_threads+0x80>
			schedule_new_thread(thread_data->init_thread,
    de46:	6825      	ldr	r5, [r4, #0]
	if (delay == 0) {
    de48:	b921      	cbnz	r1, de54 <z_init_static_threads+0x84>
		arch_syscall_invoke1(*(uintptr_t *)&thread, K_SYSCALL_K_THREAD_START);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_thread_start(thread);
    de4a:	4628      	mov	r0, r5
    de4c:	f7ff ff84 	bl	dd58 <z_impl_k_thread_start>
	_FOREACH_STATIC_THREAD(thread_data) {
    de50:	3430      	adds	r4, #48	; 0x30
    de52:	e7d1      	b.n	ddf8 <z_init_static_threads+0x28>
    de54:	46b3      	mov	fp, r6
    de56:	46bc      	mov	ip, r7
    de58:	fbe9 bc01 	umlal	fp, ip, r9, r1
    de5c:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    de60:	2300      	movs	r3, #0
    de62:	4658      	mov	r0, fp
    de64:	4661      	mov	r1, ip
    de66:	f7fe f9e9 	bl	c23c <__aeabi_uldivmod>
    de6a:	4651      	mov	r1, sl
    de6c:	1c42      	adds	r2, r0, #1
    de6e:	f105 0018 	add.w	r0, r5, #24
    de72:	f000 f841 	bl	def8 <z_add_timeout>
    de76:	e7eb      	b.n	de50 <z_init_static_threads+0x80>
    de78:	20020f44 	.word	0x20020f44
    de7c:	20020f44 	.word	0x20020f44
    de80:	0000e891 	.word	0x0000e891

0000de84 <elapsed>:
	sys_dlist_remove(&t->node);
}

static s32_t elapsed(void)
{
	return announce_remaining == 0 ? z_clock_elapsed() : 0;
    de84:	4b03      	ldr	r3, [pc, #12]	; (de94 <elapsed+0x10>)
    de86:	681b      	ldr	r3, [r3, #0]
    de88:	b90b      	cbnz	r3, de8e <elapsed+0xa>
    de8a:	f7fe bd69 	b.w	c960 <z_clock_elapsed>
}
    de8e:	2000      	movs	r0, #0
    de90:	4770      	bx	lr
    de92:	bf00      	nop
    de94:	20020170 	.word	0x20020170

0000de98 <remove_timeout>:
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
    de98:	6803      	ldr	r3, [r0, #0]
    de9a:	b140      	cbz	r0, deae <remove_timeout+0x16>
    de9c:	4a07      	ldr	r2, [pc, #28]	; (debc <remove_timeout+0x24>)
	return (node == list->tail) ? NULL : node->next;
    de9e:	6852      	ldr	r2, [r2, #4]
    dea0:	4290      	cmp	r0, r2
    dea2:	d004      	beq.n	deae <remove_timeout+0x16>
	if (next(t) != NULL) {
    dea4:	b11b      	cbz	r3, deae <remove_timeout+0x16>
		next(t)->dticks += t->dticks;
    dea6:	689a      	ldr	r2, [r3, #8]
    dea8:	6881      	ldr	r1, [r0, #8]
    deaa:	440a      	add	r2, r1
    deac:	609a      	str	r2, [r3, #8]
	node->prev->next = node->next;
    deae:	6842      	ldr	r2, [r0, #4]
    deb0:	6013      	str	r3, [r2, #0]
	node->next->prev = node->prev;
    deb2:	605a      	str	r2, [r3, #4]
	node->next = NULL;
    deb4:	2300      	movs	r3, #0
	node->prev = NULL;
    deb6:	e9c0 3300 	strd	r3, r3, [r0]
}
    deba:	4770      	bx	lr
    debc:	20020ed0 	.word	0x20020ed0

0000dec0 <next_timeout>:
	return list->head == list;
    dec0:	4b0b      	ldr	r3, [pc, #44]	; (def0 <next_timeout+0x30>)

static s32_t next_timeout(void)
{
    dec2:	b510      	push	{r4, lr}
    dec4:	681c      	ldr	r4, [r3, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    dec6:	429c      	cmp	r4, r3
    dec8:	bf08      	it	eq
    deca:	2400      	moveq	r4, #0
	struct _timeout *to = first();
	s32_t ticks_elapsed = elapsed();
    decc:	f7ff ffda 	bl	de84 <elapsed>
	s32_t ret = to == NULL ? MAX_WAIT : MAX(0, to->dticks - ticks_elapsed);
    ded0:	b154      	cbz	r4, dee8 <next_timeout+0x28>
    ded2:	68a3      	ldr	r3, [r4, #8]
    ded4:	1a18      	subs	r0, r3, r0
    ded6:	ea20 70e0 	bic.w	r0, r0, r0, asr #31

#ifdef CONFIG_TIMESLICING
	if (_current_cpu->slice_ticks && _current_cpu->slice_ticks < ret) {
    deda:	4b06      	ldr	r3, [pc, #24]	; (def4 <next_timeout+0x34>)
    dedc:	691b      	ldr	r3, [r3, #16]
    dede:	b113      	cbz	r3, dee6 <next_timeout+0x26>
    dee0:	4298      	cmp	r0, r3
    dee2:	bfa8      	it	ge
    dee4:	4618      	movge	r0, r3
		ret = _current_cpu->slice_ticks;
	}
#endif
	return ret;
}
    dee6:	bd10      	pop	{r4, pc}
	s32_t ret = to == NULL ? MAX_WAIT : MAX(0, to->dticks - ticks_elapsed);
    dee8:	f06f 4000 	mvn.w	r0, #2147483648	; 0x80000000
    deec:	e7f5      	b.n	deda <next_timeout+0x1a>
    deee:	bf00      	nop
    def0:	20020ed0 	.word	0x20020ed0
    def4:	20020134 	.word	0x20020134

0000def8 <z_add_timeout>:

void z_add_timeout(struct _timeout *to, _timeout_func_t fn, s32_t ticks)
{
    def8:	b570      	push	{r4, r5, r6, lr}
    defa:	4604      	mov	r4, r0
    defc:	4616      	mov	r6, r2
	__ASSERT(!sys_dnode_is_linked(&to->node), "");
	to->fn = fn;
    defe:	60c1      	str	r1, [r0, #12]
	__asm__ volatile(
    df00:	f04f 0320 	mov.w	r3, #32
    df04:	f3ef 8511 	mrs	r5, BASEPRI
    df08:	f383 8811 	msr	BASEPRI, r3
    df0c:	f3bf 8f6f 	isb	sy
	ticks = MAX(1, ticks);

	LOCKED(&timeout_lock) {
		struct _timeout *t;

		to->dticks = ticks + elapsed();
    df10:	f7ff ffb8 	bl	de84 <elapsed>
    df14:	2e01      	cmp	r6, #1
    df16:	bfac      	ite	ge
    df18:	1980      	addge	r0, r0, r6
    df1a:	3001      	addlt	r0, #1
	return list->head == list;
    df1c:	4b16      	ldr	r3, [pc, #88]	; (df78 <z_add_timeout+0x80>)
    df1e:	60a0      	str	r0, [r4, #8]
    df20:	681a      	ldr	r2, [r3, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    df22:	429a      	cmp	r2, r3
    df24:	d001      	beq.n	df2a <z_add_timeout+0x32>
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
    df26:	685e      	ldr	r6, [r3, #4]
		for (t = first(); t != NULL; t = next(t)) {
    df28:	b932      	cbnz	r2, df38 <z_add_timeout+0x40>
	node->prev = list->tail;
    df2a:	685a      	ldr	r2, [r3, #4]
	node->next = list;
    df2c:	6023      	str	r3, [r4, #0]
	node->prev = list->tail;
    df2e:	6062      	str	r2, [r4, #4]
	list->tail->next = node;
    df30:	685a      	ldr	r2, [r3, #4]
    df32:	6014      	str	r4, [r2, #0]
	list->tail = node;
    df34:	605c      	str	r4, [r3, #4]
    df36:	e00a      	b.n	df4e <z_add_timeout+0x56>
			__ASSERT(t->dticks >= 0, "");

			if (t->dticks > to->dticks) {
    df38:	6890      	ldr	r0, [r2, #8]
    df3a:	68a1      	ldr	r1, [r4, #8]
    df3c:	4288      	cmp	r0, r1
    df3e:	dd15      	ble.n	df6c <z_add_timeout+0x74>
				t->dticks -= to->dticks;
    df40:	1a41      	subs	r1, r0, r1
    df42:	6091      	str	r1, [r2, #8]
	node->prev = successor->prev;
    df44:	6851      	ldr	r1, [r2, #4]
	node->next = successor;
    df46:	e9c4 2100 	strd	r2, r1, [r4]
	successor->prev->next = node;
    df4a:	600c      	str	r4, [r1, #0]
	successor->prev = node;
    df4c:	6054      	str	r4, [r2, #4]
	return list->head == list;
    df4e:	681a      	ldr	r2, [r3, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    df50:	429a      	cmp	r2, r3
    df52:	d006      	beq.n	df62 <z_add_timeout+0x6a>

		if (t == NULL) {
			sys_dlist_append(&timeout_list, &to->node);
		}

		if (to == first()) {
    df54:	4294      	cmp	r4, r2
    df56:	d104      	bne.n	df62 <z_add_timeout+0x6a>
			z_clock_set_timeout(next_timeout(), false);
    df58:	f7ff ffb2 	bl	dec0 <next_timeout>
    df5c:	2100      	movs	r1, #0
    df5e:	f7fe fca9 	bl	c8b4 <z_clock_set_timeout>
	__asm__ volatile(
    df62:	f385 8811 	msr	BASEPRI, r5
    df66:	f3bf 8f6f 	isb	sy
		}
	}
}
    df6a:	bd70      	pop	{r4, r5, r6, pc}
			to->dticks -= t->dticks;
    df6c:	1a09      	subs	r1, r1, r0
	return (node == list->tail) ? NULL : node->next;
    df6e:	4296      	cmp	r6, r2
    df70:	60a1      	str	r1, [r4, #8]
    df72:	d0da      	beq.n	df2a <z_add_timeout+0x32>
    df74:	6812      	ldr	r2, [r2, #0]
    df76:	e7d7      	b.n	df28 <z_add_timeout+0x30>
    df78:	20020ed0 	.word	0x20020ed0

0000df7c <z_clock_announce>:
		}
	}
}

void z_clock_announce(s32_t ticks)
{
    df7c:	e92d 4bf0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, fp, lr}
    df80:	4604      	mov	r4, r0
#ifdef CONFIG_TIMESLICING
	z_time_slice(ticks);
    df82:	f7ff fe5d 	bl	dc40 <z_time_slice>
	__asm__ volatile(
    df86:	f04f 0320 	mov.w	r3, #32
    df8a:	f3ef 8511 	mrs	r5, BASEPRI
    df8e:	f383 8811 	msr	BASEPRI, r3
    df92:	f3bf 8f6f 	isb	sy
#endif

	k_spinlock_key_t key = k_spin_lock(&timeout_lock);

	announce_remaining = ticks;
    df96:	4f21      	ldr	r7, [pc, #132]	; (e01c <z_clock_announce+0xa0>)
    df98:	4e21      	ldr	r6, [pc, #132]	; (e020 <z_clock_announce+0xa4>)
    df9a:	46b8      	mov	r8, r7
	return list->head == list;
    df9c:	f8df 9084 	ldr.w	r9, [pc, #132]	; e024 <z_clock_announce+0xa8>
    dfa0:	6034      	str	r4, [r6, #0]
    dfa2:	f8d9 4000 	ldr.w	r4, [r9]
    dfa6:	6832      	ldr	r2, [r6, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    dfa8:	454c      	cmp	r4, r9
    dfaa:	e9d7 bc00 	ldrd	fp, ip, [r7]
    dfae:	d005      	beq.n	dfbc <z_clock_announce+0x40>

	while (first() != NULL && first()->dticks <= announce_remaining) {
    dfb0:	b124      	cbz	r4, dfbc <z_clock_announce+0x40>
    dfb2:	68a3      	ldr	r3, [r4, #8]
    dfb4:	4293      	cmp	r3, r2
    dfb6:	dd14      	ble.n	dfe2 <z_clock_announce+0x66>
		t->fn(t);
		key = k_spin_lock(&timeout_lock);
	}

	if (first() != NULL) {
		first()->dticks -= announce_remaining;
    dfb8:	1a9b      	subs	r3, r3, r2
    dfba:	60a3      	str	r3, [r4, #8]
	}

	curr_tick += announce_remaining;
	announce_remaining = 0;
    dfbc:	2400      	movs	r4, #0
	curr_tick += announce_remaining;
    dfbe:	eb1b 0002 	adds.w	r0, fp, r2
    dfc2:	eb4c 71e2 	adc.w	r1, ip, r2, asr #31
    dfc6:	e9c8 0100 	strd	r0, r1, [r8]
	announce_remaining = 0;
    dfca:	6034      	str	r4, [r6, #0]

	z_clock_set_timeout(next_timeout(), false);
    dfcc:	f7ff ff78 	bl	dec0 <next_timeout>
    dfd0:	4621      	mov	r1, r4
    dfd2:	f7fe fc6f 	bl	c8b4 <z_clock_set_timeout>
	__asm__ volatile(
    dfd6:	f385 8811 	msr	BASEPRI, r5
    dfda:	f3bf 8f6f 	isb	sy

	k_spin_unlock(&timeout_lock, key);
}
    dfde:	e8bd 8bf0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, fp, pc}
		curr_tick += dt;
    dfe2:	eb1b 0003 	adds.w	r0, fp, r3
    dfe6:	eb4c 71e3 	adc.w	r1, ip, r3, asr #31
		announce_remaining -= dt;
    dfea:	1ad3      	subs	r3, r2, r3
    dfec:	6033      	str	r3, [r6, #0]
		t->dticks = 0;
    dfee:	2300      	movs	r3, #0
		curr_tick += dt;
    dff0:	e9c7 0100 	strd	r0, r1, [r7]
		t->dticks = 0;
    dff4:	60a3      	str	r3, [r4, #8]
		remove_timeout(t);
    dff6:	4620      	mov	r0, r4
    dff8:	f7ff ff4e 	bl	de98 <remove_timeout>
    dffc:	f385 8811 	msr	BASEPRI, r5
    e000:	f3bf 8f6f 	isb	sy
		t->fn(t);
    e004:	68e3      	ldr	r3, [r4, #12]
    e006:	4798      	blx	r3
	__asm__ volatile(
    e008:	f04f 0320 	mov.w	r3, #32
    e00c:	f3ef 8511 	mrs	r5, BASEPRI
    e010:	f383 8811 	msr	BASEPRI, r3
    e014:	f3bf 8f6f 	isb	sy
#endif

#ifdef CONFIG_SPIN_VALIDATE
	z_spin_lock_set_owner(l);
#endif
	return k;
    e018:	e7c3      	b.n	dfa2 <z_clock_announce+0x26>
    e01a:	bf00      	nop
    e01c:	20020000 	.word	0x20020000
    e020:	20020170 	.word	0x20020170
    e024:	20020ed0 	.word	0x20020ed0

0000e028 <init_static_pools>:
	z_waitq_init(&p->wait_q);
	z_sys_mem_pool_base_init(&p->base);
}

int init_static_pools(struct device *unused)
{
    e028:	b538      	push	{r3, r4, r5, lr}
	ARG_UNUSED(unused);

	Z_STRUCT_SECTION_FOREACH(k_mem_pool, p) {
    e02a:	4c07      	ldr	r4, [pc, #28]	; (e048 <init_static_pools+0x20>)
    e02c:	4d07      	ldr	r5, [pc, #28]	; (e04c <init_static_pools+0x24>)
    e02e:	42ac      	cmp	r4, r5
    e030:	d301      	bcc.n	e036 <init_static_pools+0xe>
		k_mem_pool_init(p);
	}

	return 0;
}
    e032:	2000      	movs	r0, #0
    e034:	bd38      	pop	{r3, r4, r5, pc}
	SYS_DLIST_FOR_EACH_CONTAINER(&((wq)->waitq), thread_ptr, \
				     base.qnode_dlist)

static inline void z_waitq_init(_wait_q_t *w)
{
	sys_dlist_init(&w->waitq);
    e036:	f104 0314 	add.w	r3, r4, #20
	z_sys_mem_pool_base_init(&p->base);
    e03a:	4620      	mov	r0, r4
	list->tail = (sys_dnode_t *)list;
    e03c:	e9c4 3305 	strd	r3, r3, [r4, #20]
    e040:	f000 f806 	bl	e050 <z_sys_mem_pool_base_init>
	Z_STRUCT_SECTION_FOREACH(k_mem_pool, p) {
    e044:	341c      	adds	r4, #28
    e046:	e7f2      	b.n	e02e <init_static_pools+0x6>
    e048:	20020f44 	.word	0x20020f44
    e04c:	20020f44 	.word	0x20020f44

0000e050 <z_sys_mem_pool_base_init>:
{
	int i;
	size_t buflen = p->n_max * p->max_sz, sz = p->max_sz;
	u32_t *bits = (u32_t *)((u8_t *)p->buf + buflen);

	p->max_inline_level = -1;
    e050:	23ff      	movs	r3, #255	; 0xff
{
    e052:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	size_t buflen = p->n_max * p->max_sz, sz = p->max_sz;
    e056:	6846      	ldr	r6, [r0, #4]
	p->max_inline_level = -1;
    e058:	72c3      	strb	r3, [r0, #11]
	size_t buflen = p->n_max * p->max_sz, sz = p->max_sz;
    e05a:	4632      	mov	r2, r6

	for (i = 0; i < p->n_levels; i++) {
    e05c:	2300      	movs	r3, #0
		int nblocks = buflen / sz;

		sys_dlist_init(&p->levels[i].free_list);
    e05e:	f04f 090c 	mov.w	r9, #12
	size_t buflen = p->n_max * p->max_sz, sz = p->max_sz;
    e062:	8907      	ldrh	r7, [r0, #8]
	u32_t *bits = (u32_t *)((u8_t *)p->buf + buflen);
    e064:	6801      	ldr	r1, [r0, #0]
	size_t buflen = p->n_max * p->max_sz, sz = p->max_sz;
    e066:	fb06 fc07 	mul.w	ip, r6, r7
	for (i = 0; i < p->n_levels; i++) {
    e06a:	f890 800a 	ldrb.w	r8, [r0, #10]
	u32_t *bits = (u32_t *)((u8_t *)p->buf + buflen);
    e06e:	4461      	add	r1, ip
	for (i = 0; i < p->n_levels; i++) {
    e070:	4598      	cmp	r8, r3
    e072:	dc05      	bgt.n	e080 <z_sys_mem_pool_base_init+0x30>
    e074:	2300      	movs	r3, #0
		}

		sz = WB_DN(sz / 4);
	}

	for (i = 0; i < p->n_max; i++) {
    e076:	4619      	mov	r1, r3
    e078:	428f      	cmp	r7, r1
    e07a:	dc20      	bgt.n	e0be <z_sys_mem_pool_base_init+0x6e>
		void *block = block_ptr(p, p->max_sz, i);

		sys_dlist_append(&p->levels[0].free_list, block);
	}
}
    e07c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		int nblocks = buflen / sz;
    e080:	fbbc f5f2 	udiv	r5, ip, r2
		sys_dlist_init(&p->levels[i].free_list);
    e084:	fb09 fe03 	mul.w	lr, r9, r3
    e088:	f8d0 a00c 	ldr.w	sl, [r0, #12]
		if (nblocks <= sizeof(p->levels[i].bits)*8) {
    e08c:	2d20      	cmp	r5, #32
		sys_dlist_init(&p->levels[i].free_list);
    e08e:	eb0a 040e 	add.w	r4, sl, lr
    e092:	f104 0b04 	add.w	fp, r4, #4
    e096:	e9c4 bb01 	strd	fp, fp, [r4, #4]
		if (nblocks <= sizeof(p->levels[i].bits)*8) {
    e09a:	d805      	bhi.n	e0a8 <z_sys_mem_pool_base_init+0x58>
			p->max_inline_level = i;
    e09c:	72c3      	strb	r3, [r0, #11]
		sz = WB_DN(sz / 4);
    e09e:	0892      	lsrs	r2, r2, #2
    e0a0:	f022 0203 	bic.w	r2, r2, #3
	for (i = 0; i < p->n_levels; i++) {
    e0a4:	3301      	adds	r3, #1
    e0a6:	e7e3      	b.n	e070 <z_sys_mem_pool_base_init+0x20>
			bits += (nblocks + 31)/32;
    e0a8:	f115 041f 	adds.w	r4, r5, #31
    e0ac:	bf48      	it	mi
    e0ae:	f105 043e 	addmi.w	r4, r5, #62	; 0x3e
    e0b2:	1164      	asrs	r4, r4, #5
			p->levels[i].bits_p = bits;
    e0b4:	f84a 100e 	str.w	r1, [sl, lr]
			bits += (nblocks + 31)/32;
    e0b8:	eb01 0184 	add.w	r1, r1, r4, lsl #2
    e0bc:	e7ef      	b.n	e09e <z_sys_mem_pool_base_init+0x4e>
		sys_dlist_append(&p->levels[0].free_list, block);
    e0be:	68c2      	ldr	r2, [r0, #12]
	return (u8_t *)p->buf + lsz * block;
    e0c0:	6805      	ldr	r5, [r0, #0]
		sys_dlist_append(&p->levels[0].free_list, block);
    e0c2:	f102 0c04 	add.w	ip, r2, #4
	return (u8_t *)p->buf + lsz * block;
    e0c6:	18ec      	adds	r4, r5, r3
	node->next = list;
    e0c8:	f845 c003 	str.w	ip, [r5, r3]
	node->prev = list->tail;
    e0cc:	6895      	ldr	r5, [r2, #8]
	for (i = 0; i < p->n_max; i++) {
    e0ce:	3101      	adds	r1, #1
    e0d0:	6065      	str	r5, [r4, #4]
	list->tail->next = node;
    e0d2:	6895      	ldr	r5, [r2, #8]
    e0d4:	4433      	add	r3, r6
    e0d6:	602c      	str	r4, [r5, #0]
	list->tail = node;
    e0d8:	6094      	str	r4, [r2, #8]
    e0da:	e7cd      	b.n	e078 <z_sys_mem_pool_base_init+0x28>

0000e0dc <arch_printk_char_out>:
}
    e0dc:	2000      	movs	r0, #0
    e0de:	4770      	bx	lr

0000e0e0 <print_err>:
{
    e0e0:	b570      	push	{r4, r5, r6, lr}
    e0e2:	460d      	mov	r5, r1
    e0e4:	4604      	mov	r4, r0
	out('E', ctx);
    e0e6:	2045      	movs	r0, #69	; 0x45
    e0e8:	47a0      	blx	r4
	out('R', ctx);
    e0ea:	4629      	mov	r1, r5
    e0ec:	2052      	movs	r0, #82	; 0x52
    e0ee:	47a0      	blx	r4
	out('R', ctx);
    e0f0:	4629      	mov	r1, r5
    e0f2:	4623      	mov	r3, r4
}
    e0f4:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	out('R', ctx);
    e0f8:	2052      	movs	r0, #82	; 0x52
    e0fa:	4718      	bx	r3

0000e0fc <z_vprintk>:
{
    e0fc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	char length_mod = 0;
    e100:	f04f 0800 	mov.w	r8, #0
{
    e104:	4606      	mov	r6, r0
    e106:	460f      	mov	r7, r1
    e108:	461c      	mov	r4, r3
	int min_width = -1;
    e10a:	f04f 3aff 	mov.w	sl, #4294967295
	enum pad_type padding = PAD_NONE;
    e10e:	46c1      	mov	r9, r8
	int might_format = 0; /* 1 if encountered a '%' */
    e110:	4645      	mov	r5, r8
{
    e112:	b08b      	sub	sp, #44	; 0x2c
    e114:	9202      	str	r2, [sp, #8]
	while (*fmt) {
    e116:	9b02      	ldr	r3, [sp, #8]
    e118:	7818      	ldrb	r0, [r3, #0]
    e11a:	b910      	cbnz	r0, e122 <z_vprintk+0x26>
}
    e11c:	b00b      	add	sp, #44	; 0x2c
    e11e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (!might_format) {
    e122:	b945      	cbnz	r5, e136 <z_vprintk+0x3a>
			if (*fmt != '%') {
    e124:	2825      	cmp	r0, #37	; 0x25
    e126:	f000 814b 	beq.w	e3c0 <z_vprintk+0x2c4>
				out((int)*fmt, ctx);
    e12a:	4639      	mov	r1, r7
    e12c:	47b0      	blx	r6
		++fmt;
    e12e:	9b02      	ldr	r3, [sp, #8]
    e130:	3301      	adds	r3, #1
    e132:	9302      	str	r3, [sp, #8]
    e134:	e7ef      	b.n	e116 <z_vprintk+0x1a>
			switch (*fmt) {
    e136:	2864      	cmp	r0, #100	; 0x64
    e138:	d06d      	beq.n	e216 <z_vprintk+0x11a>
    e13a:	d819      	bhi.n	e170 <z_vprintk+0x74>
    e13c:	2839      	cmp	r0, #57	; 0x39
    e13e:	d80a      	bhi.n	e156 <z_vprintk+0x5a>
    e140:	2831      	cmp	r0, #49	; 0x31
    e142:	d25f      	bcs.n	e204 <z_vprintk+0x108>
    e144:	282d      	cmp	r0, #45	; 0x2d
    e146:	f000 8141 	beq.w	e3cc <z_vprintk+0x2d0>
    e14a:	2830      	cmp	r0, #48	; 0x30
    e14c:	d04b      	beq.n	e1e6 <z_vprintk+0xea>
    e14e:	2825      	cmp	r0, #37	; 0x25
    e150:	d107      	bne.n	e162 <z_vprintk+0x66>
				out((int)'%', ctx);
    e152:	4639      	mov	r1, r7
    e154:	e132      	b.n	e3bc <z_vprintk+0x2c0>
			switch (*fmt) {
    e156:	2858      	cmp	r0, #88	; 0x58
    e158:	f000 80bb 	beq.w	e2d2 <z_vprintk+0x1d6>
    e15c:	2863      	cmp	r0, #99	; 0x63
    e15e:	f000 812a 	beq.w	e3b6 <z_vprintk+0x2ba>
				out((int)'%', ctx);
    e162:	4639      	mov	r1, r7
    e164:	2025      	movs	r0, #37	; 0x25
    e166:	47b0      	blx	r6
				out((int)*fmt, ctx);
    e168:	9b02      	ldr	r3, [sp, #8]
    e16a:	4639      	mov	r1, r7
    e16c:	7818      	ldrb	r0, [r3, #0]
    e16e:	e125      	b.n	e3bc <z_vprintk+0x2c0>
			switch (*fmt) {
    e170:	2870      	cmp	r0, #112	; 0x70
    e172:	f000 80a4 	beq.w	e2be <z_vprintk+0x1c2>
    e176:	d811      	bhi.n	e19c <z_vprintk+0xa0>
    e178:	2869      	cmp	r0, #105	; 0x69
    e17a:	d04c      	beq.n	e216 <z_vprintk+0x11a>
    e17c:	286c      	cmp	r0, #108	; 0x6c
    e17e:	d105      	bne.n	e18c <z_vprintk+0x90>
				} else if (*fmt == 'l' && length_mod == 'l') {
    e180:	f1b8 0f6c 	cmp.w	r8, #108	; 0x6c
    e184:	d12a      	bne.n	e1dc <z_vprintk+0xe0>
					length_mod = 'L';
    e186:	f04f 084c 	mov.w	r8, #76	; 0x4c
    e18a:	e7d0      	b.n	e12e <z_vprintk+0x32>
			switch (*fmt) {
    e18c:	2868      	cmp	r0, #104	; 0x68
    e18e:	d1e8      	bne.n	e162 <z_vprintk+0x66>
				if (*fmt == 'h' && length_mod == 'h') {
    e190:	f1b8 0f68 	cmp.w	r8, #104	; 0x68
    e194:	d122      	bne.n	e1dc <z_vprintk+0xe0>
					length_mod = 'H';
    e196:	f04f 0848 	mov.w	r8, #72	; 0x48
    e19a:	e7c8      	b.n	e12e <z_vprintk+0x32>
			switch (*fmt) {
    e19c:	2875      	cmp	r0, #117	; 0x75
    e19e:	d072      	beq.n	e286 <z_vprintk+0x18a>
    e1a0:	d818      	bhi.n	e1d4 <z_vprintk+0xd8>
    e1a2:	2873      	cmp	r0, #115	; 0x73
    e1a4:	d1dd      	bne.n	e162 <z_vprintk+0x66>
				char *s = va_arg(ap, char *);
    e1a6:	f854 5b04 	ldr.w	r5, [r4], #4
				while (*s) {
    e1aa:	46ab      	mov	fp, r5
    e1ac:	465b      	mov	r3, fp
    e1ae:	f81b 0b01 	ldrb.w	r0, [fp], #1
    e1b2:	2800      	cmp	r0, #0
    e1b4:	f040 80fc 	bne.w	e3b0 <z_vprintk+0x2b4>
				if (padding == PAD_SPACE_AFTER) {
    e1b8:	f1b9 0f03 	cmp.w	r9, #3
    e1bc:	f040 810c 	bne.w	e3d8 <z_vprintk+0x2dc>
					int remaining = min_width - (s - start);
    e1c0:	1b5d      	subs	r5, r3, r5
    e1c2:	ebaa 0505 	sub.w	r5, sl, r5
					while (remaining-- > 0) {
    e1c6:	2d00      	cmp	r5, #0
    e1c8:	dd49      	ble.n	e25e <z_vprintk+0x162>
						out(' ', ctx);
    e1ca:	4639      	mov	r1, r7
    e1cc:	2020      	movs	r0, #32
    e1ce:	47b0      	blx	r6
    e1d0:	3d01      	subs	r5, #1
    e1d2:	e7f8      	b.n	e1c6 <z_vprintk+0xca>
			switch (*fmt) {
    e1d4:	2878      	cmp	r0, #120	; 0x78
    e1d6:	d07c      	beq.n	e2d2 <z_vprintk+0x1d6>
    e1d8:	287a      	cmp	r0, #122	; 0x7a
    e1da:	d1c2      	bne.n	e162 <z_vprintk+0x66>
				} else if (length_mod == 0) {
    e1dc:	f1b8 0f00 	cmp.w	r8, #0
    e1e0:	d1bf      	bne.n	e162 <z_vprintk+0x66>
    e1e2:	4680      	mov	r8, r0
    e1e4:	e7a3      	b.n	e12e <z_vprintk+0x32>
				if (min_width < 0 && padding == PAD_NONE) {
    e1e6:	f1ba 0f00 	cmp.w	sl, #0
    e1ea:	da0e      	bge.n	e20a <z_vprintk+0x10e>
    e1ec:	f1b9 0f00 	cmp.w	r9, #0
    e1f0:	f000 80ef 	beq.w	e3d2 <z_vprintk+0x2d6>
					min_width = *fmt - '0';
    e1f4:	f1a0 0a30 	sub.w	sl, r0, #48	; 0x30
					padding = PAD_SPACE_BEFORE;
    e1f8:	f1b9 0f00 	cmp.w	r9, #0
    e1fc:	bf08      	it	eq
    e1fe:	f04f 0902 	moveq.w	r9, #2
    e202:	e794      	b.n	e12e <z_vprintk+0x32>
				if (min_width < 0) {
    e204:	f1ba 0f00 	cmp.w	sl, #0
    e208:	dbf4      	blt.n	e1f4 <z_vprintk+0xf8>
					min_width = 10 * min_width + *fmt - '0';
    e20a:	230a      	movs	r3, #10
    e20c:	fb03 0a0a 	mla	sl, r3, sl, r0
    e210:	f1aa 0a30 	sub.w	sl, sl, #48	; 0x30
    e214:	e7f0      	b.n	e1f8 <z_vprintk+0xfc>
				if (length_mod == 'z') {
    e216:	f1b8 0f7a 	cmp.w	r8, #122	; 0x7a
    e21a:	d102      	bne.n	e222 <z_vprintk+0x126>
					d = va_arg(ap, int);
    e21c:	f854 5b04 	ldr.w	r5, [r4], #4
    e220:	e020      	b.n	e264 <z_vprintk+0x168>
				} else if (length_mod == 'l') {
    e222:	f1b8 0f6c 	cmp.w	r8, #108	; 0x6c
    e226:	d0f9      	beq.n	e21c <z_vprintk+0x120>
				} else if (length_mod == 'L') {
    e228:	f1b8 0f4c 	cmp.w	r8, #76	; 0x4c
    e22c:	d1f6      	bne.n	e21c <z_vprintk+0x120>
					long long lld = va_arg(ap, long long);
    e22e:	3407      	adds	r4, #7
    e230:	f024 0407 	bic.w	r4, r4, #7
    e234:	e8f4 2302 	ldrd	r2, r3, [r4], #8
					if (lld > __LONG_MAX__ ||
    e238:	f112 4100 	adds.w	r1, r2, #2147483648	; 0x80000000
    e23c:	9106      	str	r1, [sp, #24]
    e23e:	f143 0100 	adc.w	r1, r3, #0
    e242:	9107      	str	r1, [sp, #28]
    e244:	2100      	movs	r1, #0
    e246:	e9dd bc06 	ldrd	fp, ip, [sp, #24]
    e24a:	f04f 30ff 	mov.w	r0, #4294967295
    e24e:	4561      	cmp	r1, ip
    e250:	bf08      	it	eq
    e252:	4558      	cmpeq	r0, fp
    e254:	d205      	bcs.n	e262 <z_vprintk+0x166>
						print_err(out, ctx);
    e256:	4639      	mov	r1, r7
    e258:	4630      	mov	r0, r6
    e25a:	f7ff ff41 	bl	e0e0 <print_err>
			might_format = 0;
    e25e:	2500      	movs	r5, #0
				break;
    e260:	e765      	b.n	e12e <z_vprintk+0x32>
					d = lld;
    e262:	4615      	mov	r5, r2
				if (d < 0) {
    e264:	2d00      	cmp	r5, #0
    e266:	da05      	bge.n	e274 <z_vprintk+0x178>
					out((int)'-', ctx);
    e268:	4639      	mov	r1, r7
    e26a:	202d      	movs	r0, #45	; 0x2d
    e26c:	47b0      	blx	r6
					d = -d;
    e26e:	426d      	negs	r5, r5
					min_width--;
    e270:	f10a 3aff 	add.w	sl, sl, #4294967295
				_printk_dec_ulong(out, ctx, d, padding,
    e274:	464b      	mov	r3, r9
    e276:	462a      	mov	r2, r5
    e278:	f8cd a000 	str.w	sl, [sp]
				_printk_dec_ulong(out, ctx, u, padding,
    e27c:	4639      	mov	r1, r7
    e27e:	4630      	mov	r0, r6
    e280:	f7fe f968 	bl	c554 <_printk_dec_ulong>
				break;
    e284:	e7eb      	b.n	e25e <z_vprintk+0x162>
				if (length_mod == 'z') {
    e286:	f1b8 0f7a 	cmp.w	r8, #122	; 0x7a
    e28a:	d102      	bne.n	e292 <z_vprintk+0x196>
					u = va_arg(ap, unsigned int);
    e28c:	f854 2b04 	ldr.w	r2, [r4], #4
    e290:	e011      	b.n	e2b6 <z_vprintk+0x1ba>
				} else if (length_mod == 'l') {
    e292:	f1b8 0f6c 	cmp.w	r8, #108	; 0x6c
    e296:	d0f9      	beq.n	e28c <z_vprintk+0x190>
				} else if (length_mod == 'L') {
    e298:	f1b8 0f4c 	cmp.w	r8, #76	; 0x4c
    e29c:	d1f6      	bne.n	e28c <z_vprintk+0x190>
					if (llu > ~0UL) {
    e29e:	2100      	movs	r1, #0
    e2a0:	f04f 30ff 	mov.w	r0, #4294967295
					unsigned long long llu =
    e2a4:	3407      	adds	r4, #7
    e2a6:	f024 0407 	bic.w	r4, r4, #7
    e2aa:	e8f4 2302 	ldrd	r2, r3, [r4], #8
					if (llu > ~0UL) {
    e2ae:	4299      	cmp	r1, r3
    e2b0:	bf08      	it	eq
    e2b2:	4290      	cmpeq	r0, r2
    e2b4:	d3cf      	bcc.n	e256 <z_vprintk+0x15a>
				_printk_dec_ulong(out, ctx, u, padding,
    e2b6:	f8cd a000 	str.w	sl, [sp]
    e2ba:	464b      	mov	r3, r9
    e2bc:	e7de      	b.n	e27c <z_vprintk+0x180>
				out('0', ctx);
    e2be:	4639      	mov	r1, r7
    e2c0:	2030      	movs	r0, #48	; 0x30
    e2c2:	47b0      	blx	r6
				out('x', ctx);
    e2c4:	4639      	mov	r1, r7
    e2c6:	2078      	movs	r0, #120	; 0x78
    e2c8:	47b0      	blx	r6
					min_width = 8;
    e2ca:	f04f 0a08 	mov.w	sl, #8
				padding = PAD_ZERO_BEFORE;
    e2ce:	f04f 0901 	mov.w	r9, #1
				if (*fmt == 'p') {
    e2d2:	9b02      	ldr	r3, [sp, #8]
    e2d4:	781b      	ldrb	r3, [r3, #0]
    e2d6:	2b70      	cmp	r3, #112	; 0x70
    e2d8:	d104      	bne.n	e2e4 <z_vprintk+0x1e8>
					x = va_arg(ap, unsigned int);
    e2da:	f854 3b04 	ldr.w	r3, [r4], #4
    e2de:	9304      	str	r3, [sp, #16]
    e2e0:	2300      	movs	r3, #0
    e2e2:	e00d      	b.n	e300 <z_vprintk+0x204>
				} else if (length_mod == 'l') {
    e2e4:	f1b8 0f6c 	cmp.w	r8, #108	; 0x6c
    e2e8:	d0f7      	beq.n	e2da <z_vprintk+0x1de>
				} else if (length_mod == 'L') {
    e2ea:	f1b8 0f4c 	cmp.w	r8, #76	; 0x4c
    e2ee:	d1f4      	bne.n	e2da <z_vprintk+0x1de>
					x = va_arg(ap, unsigned long long);
    e2f0:	3407      	adds	r4, #7
    e2f2:	f024 0307 	bic.w	r3, r4, #7
    e2f6:	461c      	mov	r4, r3
    e2f8:	f854 2b08 	ldr.w	r2, [r4], #8
    e2fc:	685b      	ldr	r3, [r3, #4]
    e2fe:	9204      	str	r2, [sp, #16]
	int digits = 0;
    e300:	2100      	movs	r1, #0
	int remaining = 16; /* 16 digits max */
    e302:	2210      	movs	r2, #16
	int shift = sizeof(num) * 8;
    e304:	f04f 0b40 	mov.w	fp, #64	; 0x40
	int digits = 0;
    e308:	9103      	str	r1, [sp, #12]
	int found_largest_digit = 0;
    e30a:	9105      	str	r1, [sp, #20]
		shift -= 4;
    e30c:	f1ab 0b04 	sub.w	fp, fp, #4
		nibble = (num >> shift) & 0xf;
    e310:	9804      	ldr	r0, [sp, #16]
    e312:	f1cb 0c20 	rsb	ip, fp, #32
    e316:	f1ab 0120 	sub.w	r1, fp, #32
    e31a:	fa20 f00b 	lsr.w	r0, r0, fp
    e31e:	fa03 fc0c 	lsl.w	ip, r3, ip
    e322:	ea40 000c 	orr.w	r0, r0, ip
    e326:	fa23 f101 	lsr.w	r1, r3, r1
    e32a:	4308      	orrs	r0, r1
		if (nibble != 0 || found_largest_digit != 0 || shift == 0) {
    e32c:	f010 000f 	ands.w	r0, r0, #15
    e330:	d106      	bne.n	e340 <z_vprintk+0x244>
    e332:	9905      	ldr	r1, [sp, #20]
    e334:	b911      	cbnz	r1, e33c <z_vprintk+0x240>
    e336:	f1bb 0f00 	cmp.w	fp, #0
    e33a:	d122      	bne.n	e382 <z_vprintk+0x286>
			nibble += nibble > 9 ? 87 : 48;
    e33c:	2130      	movs	r1, #48	; 0x30
    e33e:	e003      	b.n	e348 <z_vprintk+0x24c>
    e340:	2809      	cmp	r0, #9
    e342:	bf8c      	ite	hi
    e344:	2157      	movhi	r1, #87	; 0x57
    e346:	2130      	movls	r1, #48	; 0x30
    e348:	4408      	add	r0, r1
			out((int)nibble, ctx);
    e34a:	b240      	sxtb	r0, r0
    e34c:	4639      	mov	r1, r7
    e34e:	9308      	str	r3, [sp, #32]
    e350:	9205      	str	r2, [sp, #20]
    e352:	47b0      	blx	r6
			digits++;
    e354:	9b03      	ldr	r3, [sp, #12]
	while (shift >= 4) {
    e356:	9a05      	ldr	r2, [sp, #20]
			digits++;
    e358:	3301      	adds	r3, #1
    e35a:	9303      	str	r3, [sp, #12]
	while (shift >= 4) {
    e35c:	9b08      	ldr	r3, [sp, #32]
    e35e:	f1bb 0f00 	cmp.w	fp, #0
    e362:	d123      	bne.n	e3ac <z_vprintk+0x2b0>
	if (padding == PAD_SPACE_AFTER) {
    e364:	f1b9 0f03 	cmp.w	r9, #3
    e368:	f47f af79 	bne.w	e25e <z_vprintk+0x162>
		remaining = min_width * 2 - digits;
    e36c:	9b03      	ldr	r3, [sp, #12]
    e36e:	ebc3 054a 	rsb	r5, r3, sl, lsl #1
		while (remaining-- > 0) {
    e372:	2d00      	cmp	r5, #0
    e374:	f77f af73 	ble.w	e25e <z_vprintk+0x162>
			out(' ', ctx);
    e378:	4639      	mov	r1, r7
    e37a:	2020      	movs	r0, #32
    e37c:	47b0      	blx	r6
    e37e:	3d01      	subs	r5, #1
    e380:	e7f7      	b.n	e372 <z_vprintk+0x276>
		if (remaining-- <= min_width) {
    e382:	1e51      	subs	r1, r2, #1
    e384:	4592      	cmp	sl, r2
    e386:	9108      	str	r1, [sp, #32]
    e388:	db07      	blt.n	e39a <z_vprintk+0x29e>
			if (padding == PAD_ZERO_BEFORE) {
    e38a:	f1b9 0f01 	cmp.w	r9, #1
    e38e:	d106      	bne.n	e39e <z_vprintk+0x2a2>
				out('0', ctx);
    e390:	4639      	mov	r1, r7
    e392:	2030      	movs	r0, #48	; 0x30
    e394:	9309      	str	r3, [sp, #36]	; 0x24
				out(' ', ctx);
    e396:	47b0      	blx	r6
    e398:	9b09      	ldr	r3, [sp, #36]	; 0x24
			nibble += nibble > 9 ? 87 : 48;
    e39a:	9a08      	ldr	r2, [sp, #32]
    e39c:	e7b6      	b.n	e30c <z_vprintk+0x210>
			} else if (padding == PAD_SPACE_BEFORE) {
    e39e:	f1b9 0f02 	cmp.w	r9, #2
    e3a2:	d1fa      	bne.n	e39a <z_vprintk+0x29e>
    e3a4:	9309      	str	r3, [sp, #36]	; 0x24
				out(' ', ctx);
    e3a6:	4639      	mov	r1, r7
    e3a8:	2020      	movs	r0, #32
    e3aa:	e7f4      	b.n	e396 <z_vprintk+0x29a>
			found_largest_digit = 1;
    e3ac:	9505      	str	r5, [sp, #20]
    e3ae:	e7ad      	b.n	e30c <z_vprintk+0x210>
					out((int)(*s++), ctx);
    e3b0:	4639      	mov	r1, r7
    e3b2:	47b0      	blx	r6
    e3b4:	e6fa      	b.n	e1ac <z_vprintk+0xb0>
				out(c, ctx);
    e3b6:	4639      	mov	r1, r7
    e3b8:	f854 0b04 	ldr.w	r0, [r4], #4
				out((int)'%', ctx);
    e3bc:	47b0      	blx	r6
    e3be:	e74e      	b.n	e25e <z_vprintk+0x162>
				length_mod = 0;
    e3c0:	46a8      	mov	r8, r5
				padding = PAD_NONE;
    e3c2:	46a9      	mov	r9, r5
				min_width = -1;
    e3c4:	f04f 3aff 	mov.w	sl, #4294967295
				might_format = 1;
    e3c8:	2501      	movs	r5, #1
    e3ca:	e6b0      	b.n	e12e <z_vprintk+0x32>
				padding = PAD_SPACE_AFTER;
    e3cc:	f04f 0903 	mov.w	r9, #3
    e3d0:	e6ad      	b.n	e12e <z_vprintk+0x32>
					padding = PAD_ZERO_BEFORE;
    e3d2:	f04f 0901 	mov.w	r9, #1
    e3d6:	e6aa      	b.n	e12e <z_vprintk+0x32>
			might_format = 0;
    e3d8:	4605      	mov	r5, r0
    e3da:	e6a8      	b.n	e12e <z_vprintk+0x32>

0000e3dc <printk>:
{
    e3dc:	b40f      	push	{r0, r1, r2, r3}
    e3de:	b507      	push	{r0, r1, r2, lr}
    e3e0:	a904      	add	r1, sp, #16
    e3e2:	f851 0b04 	ldr.w	r0, [r1], #4
	va_start(ap, fmt);
    e3e6:	9101      	str	r1, [sp, #4]
		vprintk(fmt, ap);
    e3e8:	f7fe f906 	bl	c5f8 <vprintk>
}
    e3ec:	b003      	add	sp, #12
    e3ee:	f85d eb04 	ldr.w	lr, [sp], #4
    e3f2:	b004      	add	sp, #16
    e3f4:	4770      	bx	lr

0000e3f6 <z_thread_entry>:
 * This routine does not return, and is marked as such so the compiler won't
 * generate preamble code that is only used by functions that actually return.
 */
FUNC_NORETURN void z_thread_entry(k_thread_entry_t entry,
				 void *p1, void *p2, void *p3)
{
    e3f6:	4604      	mov	r4, r0
    e3f8:	b508      	push	{r3, lr}
    e3fa:	4608      	mov	r0, r1
    e3fc:	4611      	mov	r1, r2
	entry(p1, p2, p3);
    e3fe:	461a      	mov	r2, r3
    e400:	47a0      	blx	r4
	return z_impl_k_current_get();
    e402:	f7ff fca3 	bl	dd4c <z_impl_k_current_get>
	z_impl_k_thread_abort(thread);
    e406:	f7fe fce5 	bl	cdd4 <z_impl_k_thread_abort>

0000e40a <_ConfigAbsSyms>:
GEN_ABSOLUTE_SYM(CONFIG_OUTPUT_DISASSEMBLY, 1);
GEN_ABSOLUTE_SYM(CONFIG_OUTPUT_PRINT_MEMORY_USAGE, 1);
GEN_ABSOLUTE_SYM(CONFIG_BUILD_OUTPUT_BIN, 1);
GEN_ABSOLUTE_SYM(CONFIG_COMPAT_INCLUDES, 1);

GEN_ABS_SYM_END
    e40a:	4770      	bx	lr

0000e40c <z_platform_init>:
	nrfx_coredep_delay_us(time_us);
}

void z_platform_init(void)
{
	SystemInit();
    e40c:	f7ff b9d0 	b.w	d7b0 <SystemInit>

0000e410 <get_status>:
	if (data->started) {
    e410:	220c      	movs	r2, #12
	data = get_sub_data(dev, type);
    e412:	6883      	ldr	r3, [r0, #8]
	return &data->subsys[type];
    e414:	b2c9      	uxtb	r1, r1
	if (data->started) {
    e416:	fb02 3101 	mla	r1, r2, r1, r3
    e41a:	7a4b      	ldrb	r3, [r1, #9]
    e41c:	b923      	cbnz	r3, e428 <get_status+0x18>
	if (data->ref > 0) {
    e41e:	7a08      	ldrb	r0, [r1, #8]
		return CLOCK_CONTROL_STATUS_ON;
    e420:	fab0 f080 	clz	r0, r0
    e424:	0940      	lsrs	r0, r0, #5
    e426:	4770      	bx	lr
    e428:	2002      	movs	r0, #2
}
    e42a:	4770      	bx	lr

0000e42c <clock_stop>:
	const struct nrf_clock_control_config *config =
    e42c:	6802      	ldr	r2, [r0, #0]
{
    e42e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	const struct nrf_clock_control_config *config =
    e430:	6897      	ldr	r7, [r2, #8]
	return &config->subsys[type];
    e432:	b2cc      	uxtb	r4, r1
	data = get_sub_data(dev, type);
    e434:	6886      	ldr	r6, [r0, #8]
    e436:	f04f 0320 	mov.w	r3, #32
    e43a:	f3ef 8511 	mrs	r5, BASEPRI
    e43e:	f383 8811 	msr	BASEPRI, r3
    e442:	f3bf 8f6f 	isb	sy
	if (data->ref == 0) {
    e446:	220c      	movs	r2, #12
    e448:	4362      	muls	r2, r4
    e44a:	18b1      	adds	r1, r6, r2
    e44c:	7a0b      	ldrb	r3, [r1, #8]
    e44e:	b33b      	cbz	r3, e4a0 <clock_stop+0x74>
	data->ref--;
    e450:	3b01      	subs	r3, #1
    e452:	b2db      	uxtb	r3, r3
    e454:	720b      	strb	r3, [r1, #8]
	if (data->ref == 0) {
    e456:	bb33      	cbnz	r3, e4a6 <clock_stop+0x7a>
	list->head = NULL;
    e458:	50b3      	str	r3, [r6, r2]
		do_stop =  (config->stop_handler) ?
    e45a:	443a      	add	r2, r7
	list->tail = NULL;
    e45c:	604b      	str	r3, [r1, #4]
    e45e:	6853      	ldr	r3, [r2, #4]
				config->stop_handler(dev) : true;
    e460:	b9d3      	cbnz	r3, e498 <clock_stop+0x6c>
			nrf_clock_task_trigger(NRF_CLOCK, config->stop_tsk);
    e462:	220c      	movs	r2, #12
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    e464:	2101      	movs	r1, #1
    e466:	fb02 7204 	mla	r2, r2, r4, r7
    e46a:	7ad3      	ldrb	r3, [r2, #11]
    e46c:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
    e470:	f503 43a0 	add.w	r3, r3, #20480	; 0x5000
    e474:	6019      	str	r1, [r3, #0]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    e476:	8913      	ldrh	r3, [r2, #8]
    e478:	2200      	movs	r2, #0
    e47a:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
    e47e:	f503 43a0 	add.w	r3, r3, #20480	; 0x5000
    e482:	601a      	str	r2, [r3, #0]
		data->started = false;
    e484:	210c      	movs	r1, #12
    e486:	2000      	movs	r0, #0
    e488:	fb01 6404 	mla	r4, r1, r4, r6
    e48c:	7260      	strb	r0, [r4, #9]
	__asm__ volatile(
    e48e:	f385 8811 	msr	BASEPRI, r5
    e492:	f3bf 8f6f 	isb	sy
}
    e496:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
				config->stop_handler(dev) : true;
    e498:	4798      	blx	r3
    e49a:	2800      	cmp	r0, #0
    e49c:	d1e1      	bne.n	e462 <clock_stop+0x36>
    e49e:	e7f1      	b.n	e484 <clock_stop+0x58>
		err = -EALREADY;
    e4a0:	f06f 0044 	mvn.w	r0, #68	; 0x44
    e4a4:	e7f3      	b.n	e48e <clock_stop+0x62>
	int err = 0;
    e4a6:	2000      	movs	r0, #0
    e4a8:	e7f1      	b.n	e48e <clock_stop+0x62>

0000e4aa <clkstarted_handle>:
{
    e4aa:	b538      	push	{r3, r4, r5, lr}
	sub_data->started = true;
    e4ac:	240c      	movs	r4, #12
	struct nrf_clock_control_sub_data *sub_data = get_sub_data(dev, type);
    e4ae:	6883      	ldr	r3, [r0, #8]
{
    e4b0:	4605      	mov	r5, r0
	sub_data->started = true;
    e4b2:	fb04 3401 	mla	r4, r4, r1, r3
    e4b6:	2301      	movs	r3, #1
    e4b8:	7263      	strb	r3, [r4, #9]
	__asm__ volatile(
    e4ba:	f04f 0320 	mov.w	r3, #32
    e4be:	f3ef 8111 	mrs	r1, BASEPRI
    e4c2:	f383 8811 	msr	BASEPRI, r3
    e4c6:	f3bf 8f6f 	isb	sy
Z_GENLIST_IS_EMPTY(slist)
    e4ca:	6823      	ldr	r3, [r4, #0]
 *
 * @return A pointer to the first node of the list (or NULL if empty)
 */
static inline sys_snode_t *sys_slist_get(sys_slist_t *list);

Z_GENLIST_GET(slist, snode)
    e4cc:	b12b      	cbz	r3, e4da <clkstarted_handle+0x30>
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
    e4ce:	6860      	ldr	r0, [r4, #4]
    e4d0:	681a      	ldr	r2, [r3, #0]
    e4d2:	4283      	cmp	r3, r0
	list->head = node;
    e4d4:	6022      	str	r2, [r4, #0]
	list->tail = node;
    e4d6:	bf08      	it	eq
    e4d8:	6062      	streq	r2, [r4, #4]
	__asm__ volatile(
    e4da:	f381 8811 	msr	BASEPRI, r1
    e4de:	f3bf 8f6f 	isb	sy
	while ((async_data = list_get(&sub_data->list)) != NULL) {
    e4e2:	b903      	cbnz	r3, e4e6 <clkstarted_handle+0x3c>
}
    e4e4:	bd38      	pop	{r3, r4, r5, pc}
		async_data->cb(dev, async_data->user_data);
    e4e6:	e9d3 2101 	ldrd	r2, r1, [r3, #4]
    e4ea:	4628      	mov	r0, r5
    e4ec:	4790      	blx	r2
    e4ee:	e7e4      	b.n	e4ba <clkstarted_handle+0x10>

0000e4f0 <clock_start>:
	return clock_async_start(dev, sub_system, NULL);
    e4f0:	2200      	movs	r2, #0
    e4f2:	f7fe b8d1 	b.w	c698 <clock_async_start>

0000e4f6 <z_clock_isr>:
/* Weak-linked noop defaults for optional driver interfaces: */

void __weak z_clock_isr(void *arg)
{
	__ASSERT_NO_MSG(false);
}
    e4f6:	4770      	bx	lr

0000e4f8 <z_clock_idle_exit>:
{
}

void __weak z_clock_idle_exit(void)
{
}
    e4f8:	4770      	bx	lr

0000e4fa <z_irq_spurious>:
 * @return N/A
 */
void z_irq_spurious(void *unused)
{
	ARG_UNUSED(unused);
	z_arm_reserved();
    e4fa:	f7fe ba9f 	b.w	ca3c <z_arm_bus_fault>

0000e4fe <z_arm_fatal_error>:
{

	if (esf != NULL) {
		esf_dump(esf);
	}
	z_fatal_error(reason, esf);
    e4fe:	f000 b986 	b.w	e80e <z_fatal_error>

0000e502 <z_do_kernel_oops>:
 *   fault handler will executed insted of the SVC.
 *
 * @param esf exception frame
 */
void z_do_kernel_oops(const z_arch_esf_t *esf)
{
    e502:	4601      	mov	r1, r0
	z_fatal_error(reason, esf);
    e504:	6800      	ldr	r0, [r0, #0]
    e506:	f000 b982 	b.w	e80e <z_fatal_error>

0000e50a <z_arm_nmi>:
 *
 * @return N/A
 */

void z_arm_nmi(void)
{
    e50a:	b508      	push	{r3, lr}
	handler();
    e50c:	f7fe faa0 	bl	ca50 <z_SysNmiOnReset>
	z_arm_exc_exit();
}
    e510:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	z_arm_exc_exit();
    e514:	f7fe ba3e 	b.w	c994 <z_arm_exc_exit>

0000e518 <z_arm_configure_dynamic_mpu_regions>:
 *
 * For some MPU architectures, such as the unmodified ARMv8-M MPU,
 * the function must execute with MPU enabled.
 */
void z_arm_configure_dynamic_mpu_regions(struct k_thread *thread)
{
    e518:	b507      	push	{r0, r1, r2, lr}

	region_num++;
#endif /* CONFIG_MPU_STACK_GUARD */

	/* Configure the dynamic MPU regions */
	arm_core_mpu_configure_dynamic_mpu_regions(
    e51a:	2100      	movs	r1, #0
    e51c:	a801      	add	r0, sp, #4
    e51e:	f7fe fdf1 	bl	d104 <arm_core_mpu_configure_dynamic_mpu_regions>
		(const struct k_mem_partition **)dynamic_regions,
		region_num);
}
    e522:	b003      	add	sp, #12
    e524:	f85d fb04 	ldr.w	pc, [sp], #4

0000e528 <mpu_configure_region>:
{
    e528:	b530      	push	{r4, r5, lr}
	region_conf.base = new_region->start;
    e52a:	680b      	ldr	r3, [r1, #0]
{
    e52c:	b085      	sub	sp, #20
	get_region_attr_from_k_mem_partition_info(&region_conf.attr,
    e52e:	684c      	ldr	r4, [r1, #4]
	p_attr->rbar = attr->rbar &
    e530:	f89d 2008 	ldrb.w	r2, [sp, #8]
    e534:	890d      	ldrh	r5, [r1, #8]
	p_attr->r_limit = REGION_LIMIT_ADDR(base, size);
    e536:	3c01      	subs	r4, #1
	region_conf.base = new_region->start;
    e538:	9300      	str	r3, [sp, #0]
	p_attr->mair_idx = attr->mair_idx;
    e53a:	8949      	ldrh	r1, [r1, #10]
	p_attr->r_limit = REGION_LIMIT_ADDR(base, size);
    e53c:	f023 031f 	bic.w	r3, r3, #31
    e540:	4423      	add	r3, r4
	p_attr->rbar = attr->rbar &
    e542:	f365 0204 	bfi	r2, r5, #0, #5
	p_attr->mair_idx = attr->mair_idx;
    e546:	f361 1247 	bfi	r2, r1, #5, #3
	p_attr->r_limit = REGION_LIMIT_ADDR(base, size);
    e54a:	f023 031f 	bic.w	r3, r3, #31
	if (index > (get_num_regions() - 1)) {
    e54e:	280f      	cmp	r0, #15
	p_attr->mair_idx = attr->mair_idx;
    e550:	f88d 2008 	strb.w	r2, [sp, #8]
	p_attr->r_limit = REGION_LIMIT_ADDR(base, size);
    e554:	9303      	str	r3, [sp, #12]
    e556:	4604      	mov	r4, r0
    e558:	d805      	bhi.n	e566 <mpu_configure_region+0x3e>
	region_init(index, region_conf);
    e55a:	4669      	mov	r1, sp
    e55c:	f7fe fc8a 	bl	ce74 <region_init>
}
    e560:	4620      	mov	r0, r4
    e562:	b005      	add	sp, #20
    e564:	bd30      	pop	{r4, r5, pc}
		return -EINVAL;
    e566:	f06f 0415 	mvn.w	r4, #21
	return region_allocate_and_init(index,
    e56a:	e7f9      	b.n	e560 <mpu_configure_region+0x38>

0000e56c <arm_cmse_mpu_region_get>:
__CMSE_TT_ASM ()

__extension__ static __inline __attribute__ ((__always_inline__))
cmse_address_info_t
cmse_TT (void *__p)
__CMSE_TT_ASM ()
    e56c:	e840 f300 	tt	r3, r0

int arm_cmse_mpu_region_get(u32_t addr)
{
	cmse_address_info_t addr_info =	cmse_TT((void *)addr);

	if (addr_info.flags.mpu_region_valid) {
    e570:	f413 3f80 	tst.w	r3, #65536	; 0x10000
    e574:	b2d8      	uxtb	r0, r3
		return addr_info.flags.mpu_region;
	}

	return -EINVAL;
}
    e576:	bf08      	it	eq
    e578:	f06f 0015 	mvneq.w	r0, #21
    e57c:	4770      	bx	lr

0000e57e <strcmp>:
 * @return negative # if <s1> < <s2>, 0 if <s1> == <s2>, else positive #
 */

int strcmp(const char *s1, const char *s2)
{
	while ((*s1 == *s2) && (*s1 != '\0')) {
    e57e:	3801      	subs	r0, #1
    e580:	3901      	subs	r1, #1
    e582:	f810 3f01 	ldrb.w	r3, [r0, #1]!
    e586:	f811 2f01 	ldrb.w	r2, [r1, #1]!
    e58a:	4293      	cmp	r3, r2
    e58c:	d101      	bne.n	e592 <strcmp+0x14>
    e58e:	2b00      	cmp	r3, #0
    e590:	d1f7      	bne.n	e582 <strcmp+0x4>
		s1++;
		s2++;
	}

	return *s1 - *s2;
}
    e592:	1a98      	subs	r0, r3, r2
    e594:	4770      	bx	lr

0000e596 <memcmp>:
 * @brief Compare two memory areas
 *
 * @return negative # if <m1> < <m2>, 0 if <m1> == <m2>, else positive #
 */
int memcmp(const void *m1, const void *m2, size_t n)
{
    e596:	b510      	push	{r4, lr}
	const char *c1 = m1;
	const char *c2 = m2;

	if (!n) {
    e598:	b15a      	cbz	r2, e5b2 <memcmp+0x1c>
    e59a:	3901      	subs	r1, #1
    e59c:	1884      	adds	r4, r0, r2
    e59e:	f810 2b01 	ldrb.w	r2, [r0], #1
    e5a2:	f811 3f01 	ldrb.w	r3, [r1, #1]!
		return 0;
	}

	while ((--n > 0) && (*c1 == *c2)) {
    e5a6:	42a0      	cmp	r0, r4
    e5a8:	d001      	beq.n	e5ae <memcmp+0x18>
    e5aa:	429a      	cmp	r2, r3
    e5ac:	d0f7      	beq.n	e59e <memcmp+0x8>
		c1++;
		c2++;
	}

	return *c1 - *c2;
    e5ae:	1ad0      	subs	r0, r2, r3
}
    e5b0:	bd10      	pop	{r4, pc}
		return 0;
    e5b2:	4610      	mov	r0, r2
    e5b4:	e7fc      	b.n	e5b0 <memcmp+0x1a>

0000e5b6 <memcpy>:
 *
 * @return pointer to start of destination buffer
 */

void *memcpy(void *_MLIBC_RESTRICT d, const void *_MLIBC_RESTRICT s, size_t n)
{
    e5b6:	b5f0      	push	{r4, r5, r6, r7, lr}

	unsigned char *d_byte = (unsigned char *)d;
	const unsigned char *s_byte = (const unsigned char *)s;
	const uintptr_t mask = sizeof(mem_word_t) - 1;

	if ((((uintptr_t)d ^ (uintptr_t)s_byte) & mask) == 0) {
    e5b8:	ea81 0400 	eor.w	r4, r1, r0
    e5bc:	07a5      	lsls	r5, r4, #30
    e5be:	4603      	mov	r3, r0
    e5c0:	d00b      	beq.n	e5da <memcpy+0x24>
    e5c2:	3b01      	subs	r3, #1
    e5c4:	440a      	add	r2, r1
		s_byte = (unsigned char *)s_word;
	}

	/* do byte-sized copying until finished */

	while (n > 0) {
    e5c6:	4291      	cmp	r1, r2
    e5c8:	d11a      	bne.n	e600 <memcpy+0x4a>
		*(d_byte++) = *(s_byte++);
		n--;
	}

	return d;
}
    e5ca:	bdf0      	pop	{r4, r5, r6, r7, pc}
			if (n == 0) {
    e5cc:	2a00      	cmp	r2, #0
    e5ce:	d0fc      	beq.n	e5ca <memcpy+0x14>
			*(d_byte++) = *(s_byte++);
    e5d0:	f811 4b01 	ldrb.w	r4, [r1], #1
			n--;
    e5d4:	3a01      	subs	r2, #1
			*(d_byte++) = *(s_byte++);
    e5d6:	f803 4b01 	strb.w	r4, [r3], #1
		while (((uintptr_t)d_byte) & mask) {
    e5da:	079c      	lsls	r4, r3, #30
    e5dc:	d1f6      	bne.n	e5cc <memcpy+0x16>
    e5de:	0895      	lsrs	r5, r2, #2
    e5e0:	00ac      	lsls	r4, r5, #2
    e5e2:	1f1e      	subs	r6, r3, #4
    e5e4:	190f      	adds	r7, r1, r4
		while (n >= sizeof(mem_word_t)) {
    e5e6:	42b9      	cmp	r1, r7
    e5e8:	d105      	bne.n	e5f6 <memcpy+0x40>
    e5ea:	f06f 0603 	mvn.w	r6, #3
    e5ee:	4423      	add	r3, r4
    e5f0:	fb06 2205 	mla	r2, r6, r5, r2
    e5f4:	e7e5      	b.n	e5c2 <memcpy+0xc>
			*(d_word++) = *(s_word++);
    e5f6:	f851 cb04 	ldr.w	ip, [r1], #4
    e5fa:	f846 cf04 	str.w	ip, [r6, #4]!
			n -= sizeof(mem_word_t);
    e5fe:	e7f2      	b.n	e5e6 <memcpy+0x30>
		*(d_byte++) = *(s_byte++);
    e600:	f811 4b01 	ldrb.w	r4, [r1], #1
    e604:	f803 4f01 	strb.w	r4, [r3, #1]!
		n--;
    e608:	e7dd      	b.n	e5c6 <memcpy+0x10>

0000e60a <memset>:

void *memset(void *buf, int c, size_t n)
{
	/* do byte-sized initialization until word-aligned or finished */

	unsigned char *d_byte = (unsigned char *)buf;
    e60a:	4603      	mov	r3, r0
{
    e60c:	b570      	push	{r4, r5, r6, lr}
	unsigned char c_byte = (unsigned char)c;
    e60e:	b2c9      	uxtb	r1, r1

	while (((uintptr_t)d_byte) & (sizeof(mem_word_t) - 1)) {
    e610:	079c      	lsls	r4, r3, #30
    e612:	d110      	bne.n	e636 <memset+0x2c>
	/* do word-sized initialization as long as possible */

	mem_word_t *d_word = (mem_word_t *)d_byte;
	mem_word_t c_word = (mem_word_t)c_byte;

	c_word |= c_word << 8;
    e614:	ea41 2401 	orr.w	r4, r1, r1, lsl #8
	c_word |= c_word << 16;
    e618:	ea44 4504 	orr.w	r5, r4, r4, lsl #16
#if Z_MEM_WORD_T_WIDTH > 32
	c_word |= c_word << 32;
#endif

	while (n >= sizeof(mem_word_t)) {
    e61c:	0894      	lsrs	r4, r2, #2
    e61e:	eb03 0684 	add.w	r6, r3, r4, lsl #2
    e622:	42b3      	cmp	r3, r6
    e624:	d10d      	bne.n	e642 <memset+0x38>
    e626:	f06f 0503 	mvn.w	r5, #3
    e62a:	fb05 2404 	mla	r4, r5, r4, r2
    e62e:	441c      	add	r4, r3

	/* do byte-sized initialization until finished */

	d_byte = (unsigned char *)d_word;

	while (n > 0) {
    e630:	42a3      	cmp	r3, r4
    e632:	d109      	bne.n	e648 <memset+0x3e>
		*(d_byte++) = c_byte;
		n--;
	}

	return buf;
}
    e634:	bd70      	pop	{r4, r5, r6, pc}
		if (n == 0) {
    e636:	2a00      	cmp	r2, #0
    e638:	d0fc      	beq.n	e634 <memset+0x2a>
		*(d_byte++) = c_byte;
    e63a:	f803 1b01 	strb.w	r1, [r3], #1
		n--;
    e63e:	3a01      	subs	r2, #1
    e640:	e7e6      	b.n	e610 <memset+0x6>
		*(d_word++) = c_word;
    e642:	f843 5b04 	str.w	r5, [r3], #4
		n -= sizeof(mem_word_t);
    e646:	e7ec      	b.n	e622 <memset+0x18>
		*(d_byte++) = c_byte;
    e648:	f803 1b01 	strb.w	r1, [r3], #1
		n--;
    e64c:	e7f0      	b.n	e630 <memset+0x26>

0000e64e <_stdout_hook_default>:
}
    e64e:	f04f 30ff 	mov.w	r0, #4294967295
    e652:	4770      	bx	lr

0000e654 <gpio_nrfx_write>:
{
    e654:	b510      	push	{r4, lr}
	return port->config->config_info;
    e656:	6804      	ldr	r4, [r0, #0]
    e658:	6880      	ldr	r0, [r0, #8]
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
    e65a:	68a4      	ldr	r4, [r4, #8]
	if (access_op == GPIO_ACCESS_BY_PORT) {
    e65c:	2901      	cmp	r1, #1
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
    e65e:	6824      	ldr	r4, [r4, #0]
	if (access_op == GPIO_ACCESS_BY_PORT) {
    e660:	69c0      	ldr	r0, [r0, #28]
    e662:	d103      	bne.n	e66c <gpio_nrfx_write+0x18>
		nrf_gpio_port_out_write(reg, value ^ data->inverted);
    e664:	4058      	eors	r0, r3
    p_reg->OUT = value;
    e666:	6060      	str	r0, [r4, #4]
}
    e668:	2000      	movs	r0, #0
    e66a:	bd10      	pop	{r4, pc}
		if ((value > 0) ^ ((BIT(pin) & data->inverted) != 0)) {
    e66c:	3300      	adds	r3, #0
    e66e:	f04f 0101 	mov.w	r1, #1
    e672:	bf18      	it	ne
    e674:	2301      	movne	r3, #1
    e676:	40d0      	lsrs	r0, r2
    e678:	f000 0001 	and.w	r0, r0, #1
    e67c:	4091      	lsls	r1, r2
    e67e:	4283      	cmp	r3, r0
    p_reg->OUTSET = set_mask;
    e680:	bf14      	ite	ne
    e682:	60a1      	strne	r1, [r4, #8]
}


NRF_STATIC_INLINE void nrf_gpio_port_out_clear(NRF_GPIO_Type * p_reg, uint32_t clr_mask)
{
    p_reg->OUTCLR = clr_mask;
    e684:	60e1      	streq	r1, [r4, #12]
    e686:	e7ef      	b.n	e668 <gpio_nrfx_write+0x14>

0000e688 <gpio_nrfx_read>:
{
    e688:	b570      	push	{r4, r5, r6, lr}
	return port->config->config_info;
    e68a:	6804      	ldr	r4, [r0, #0]
	u32_t port_val = (port_in | port_out) ^ data->inverted;
    e68c:	6880      	ldr	r0, [r0, #8]
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
    e68e:	68a4      	ldr	r4, [r4, #8]
	u32_t port_val = (port_in | port_out) ^ data->inverted;
    e690:	69c0      	ldr	r0, [r0, #28]
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
    e692:	6825      	ldr	r5, [r4, #0]
	if (access_op == GPIO_ACCESS_BY_PORT) {
    e694:	2901      	cmp	r1, #1
    return p_reg->DIR;
    e696:	696e      	ldr	r6, [r5, #20]
    return p_reg->IN;
    e698:	692c      	ldr	r4, [r5, #16]
    return p_reg->OUT;
    e69a:	686d      	ldr	r5, [r5, #4]
	u32_t port_val = (port_in | port_out) ^ data->inverted;
    e69c:	ea80 0004 	eor.w	r0, r0, r4
    e6a0:	ea84 0405 	eor.w	r4, r4, r5
    e6a4:	ea04 0406 	and.w	r4, r4, r6
    e6a8:	ea80 0004 	eor.w	r0, r0, r4
		*value = (port_val & BIT(pin)) ? 1 : 0;
    e6ac:	bf1c      	itt	ne
    e6ae:	40d0      	lsrne	r0, r2
    e6b0:	f000 0001 	andne.w	r0, r0, #1
    e6b4:	6018      	str	r0, [r3, #0]
}
    e6b6:	2000      	movs	r0, #0
    e6b8:	bd70      	pop	{r4, r5, r6, pc}

0000e6ba <gpio_nrfx_manage_callback>:
	return gpio_manage_callback(&get_port_data(port)->callbacks,
    e6ba:	6883      	ldr	r3, [r0, #8]
{
    e6bc:	b530      	push	{r4, r5, lr}
Z_GENLIST_IS_EMPTY(slist)
    e6be:	6818      	ldr	r0, [r3, #0]
					bool set)
{
	__ASSERT(callback, "No callback!");
	__ASSERT(callback->handler, "No callback handler!");

	if (!sys_slist_is_empty(callbacks)) {
    e6c0:	b158      	cbz	r0, e6da <gpio_nrfx_manage_callback+0x20>
 * @return true if node was removed
 */
static inline bool sys_slist_find_and_remove(sys_slist_t *list,
					     sys_snode_t *node);

Z_GENLIST_FIND_AND_REMOVE(slist, snode)
    e6c2:	2400      	movs	r4, #0
    e6c4:	4281      	cmp	r1, r0
    e6c6:	d113      	bne.n	e6f0 <gpio_nrfx_manage_callback+0x36>
Z_GENLIST_REMOVE(slist, snode)
    e6c8:	6808      	ldr	r0, [r1, #0]
    e6ca:	b95c      	cbnz	r4, e6e4 <gpio_nrfx_manage_callback+0x2a>
    e6cc:	685c      	ldr	r4, [r3, #4]
	list->head = node;
    e6ce:	6018      	str	r0, [r3, #0]
Z_GENLIST_REMOVE(slist, snode)
    e6d0:	42a1      	cmp	r1, r4
    e6d2:	d100      	bne.n	e6d6 <gpio_nrfx_manage_callback+0x1c>
	list->tail = node;
    e6d4:	6058      	str	r0, [r3, #4]
	parent->next = child;
    e6d6:	2000      	movs	r0, #0
    e6d8:	6008      	str	r0, [r1, #0]
				return -EINVAL;
			}
		}
	}

	if (set) {
    e6da:	b972      	cbnz	r2, e6fa <gpio_nrfx_manage_callback+0x40>
		sys_slist_prepend(callbacks, &callback->node);
	}

	return 0;
    e6dc:	2000      	movs	r0, #0
}
    e6de:	bd30      	pop	{r4, r5, pc}
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
    e6e0:	4628      	mov	r0, r5
    e6e2:	e7ef      	b.n	e6c4 <gpio_nrfx_manage_callback+0xa>
	parent->next = child;
    e6e4:	6020      	str	r0, [r4, #0]
Z_GENLIST_REMOVE(slist, snode)
    e6e6:	6858      	ldr	r0, [r3, #4]
    e6e8:	4281      	cmp	r1, r0
	list->tail = node;
    e6ea:	bf08      	it	eq
    e6ec:	605c      	streq	r4, [r3, #4]
    e6ee:	e7f2      	b.n	e6d6 <gpio_nrfx_manage_callback+0x1c>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
    e6f0:	6805      	ldr	r5, [r0, #0]
	return node->next;
    e6f2:	4604      	mov	r4, r0
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
    e6f4:	2d00      	cmp	r5, #0
    e6f6:	d1f3      	bne.n	e6e0 <gpio_nrfx_manage_callback+0x26>
			if (!set) {
    e6f8:	b13a      	cbz	r2, e70a <gpio_nrfx_manage_callback+0x50>
Z_GENLIST_PREPEND(slist, snode)
    e6fa:	681a      	ldr	r2, [r3, #0]
	parent->next = child;
    e6fc:	600a      	str	r2, [r1, #0]
Z_GENLIST_PREPEND(slist, snode)
    e6fe:	6858      	ldr	r0, [r3, #4]
	list->head = node;
    e700:	6019      	str	r1, [r3, #0]
Z_GENLIST_PREPEND(slist, snode)
    e702:	2800      	cmp	r0, #0
    e704:	d1ea      	bne.n	e6dc <gpio_nrfx_manage_callback+0x22>
	list->tail = node;
    e706:	6059      	str	r1, [r3, #4]
    e708:	e7e9      	b.n	e6de <gpio_nrfx_manage_callback+0x24>
				return -EINVAL;
    e70a:	f06f 0015 	mvn.w	r0, #21
	return gpio_manage_callback(&get_port_data(port)->callbacks,
    e70e:	e7e6      	b.n	e6de <gpio_nrfx_manage_callback+0x24>

0000e710 <gpio_nrfx_pin_disable_callback>:
	if (access_op == GPIO_ACCESS_BY_PORT) {
    e710:	2901      	cmp	r1, #1
{
    e712:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
		from_pin = pin;
    e716:	bf18      	it	ne
    e718:	b2d4      	uxtbne	r4, r2
{
    e71a:	4606      	mov	r6, r0
		to_pin   = pin;
    e71c:	bf12      	itee	ne
    e71e:	4625      	movne	r5, r4
		to_pin   = 31U;
    e720:	251f      	moveq	r5, #31
		from_pin = 0U;
    e722:	2400      	moveq	r4, #0
		WRITE_BIT(data->int_en, curr_pin, enable);
    e724:	f04f 0801 	mov.w	r8, #1
	struct gpio_nrfx_data *data = get_port_data(port);
    e728:	6887      	ldr	r7, [r0, #8]
	for (u8_t curr_pin = from_pin; curr_pin <= to_pin; ++curr_pin) {
    e72a:	42ac      	cmp	r4, r5
    e72c:	d902      	bls.n	e734 <gpio_nrfx_pin_disable_callback+0x24>
	return res;
    e72e:	2000      	movs	r0, #0
}
    e730:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		WRITE_BIT(data->int_en, curr_pin, enable);
    e734:	68fb      	ldr	r3, [r7, #12]
    e736:	fa08 f204 	lsl.w	r2, r8, r4
    e73a:	ea23 0302 	bic.w	r3, r3, r2
    e73e:	60fb      	str	r3, [r7, #12]
		res = gpiote_pin_int_cfg(port, curr_pin);
    e740:	4621      	mov	r1, r4
    e742:	4630      	mov	r0, r6
    e744:	f7fe fd1c 	bl	d180 <gpiote_pin_int_cfg>
		if (res != 0) {
    e748:	2800      	cmp	r0, #0
    e74a:	d1f1      	bne.n	e730 <gpio_nrfx_pin_disable_callback+0x20>
	for (u8_t curr_pin = from_pin; curr_pin <= to_pin; ++curr_pin) {
    e74c:	3401      	adds	r4, #1
    e74e:	b2e4      	uxtb	r4, r4
    e750:	e7eb      	b.n	e72a <gpio_nrfx_pin_disable_callback+0x1a>

0000e752 <gpio_nrfx_pin_enable_callback>:
	if (access_op == GPIO_ACCESS_BY_PORT) {
    e752:	2901      	cmp	r1, #1
{
    e754:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
		from_pin = pin;
    e758:	bf18      	it	ne
    e75a:	b2d4      	uxtbne	r4, r2
{
    e75c:	4606      	mov	r6, r0
		to_pin   = pin;
    e75e:	bf12      	itee	ne
    e760:	4625      	movne	r5, r4
		to_pin   = 31U;
    e762:	251f      	moveq	r5, #31
		from_pin = 0U;
    e764:	2400      	moveq	r4, #0
		WRITE_BIT(data->int_en, curr_pin, enable);
    e766:	f04f 0801 	mov.w	r8, #1
	struct gpio_nrfx_data *data = get_port_data(port);
    e76a:	6887      	ldr	r7, [r0, #8]
	for (u8_t curr_pin = from_pin; curr_pin <= to_pin; ++curr_pin) {
    e76c:	42ac      	cmp	r4, r5
    e76e:	d902      	bls.n	e776 <gpio_nrfx_pin_enable_callback+0x24>
	return res;
    e770:	2000      	movs	r0, #0
}
    e772:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		WRITE_BIT(data->int_en, curr_pin, enable);
    e776:	68fb      	ldr	r3, [r7, #12]
    e778:	fa08 f204 	lsl.w	r2, r8, r4
    e77c:	4313      	orrs	r3, r2
    e77e:	60fb      	str	r3, [r7, #12]
		res = gpiote_pin_int_cfg(port, curr_pin);
    e780:	4621      	mov	r1, r4
    e782:	4630      	mov	r0, r6
    e784:	f7fe fcfc 	bl	d180 <gpiote_pin_int_cfg>
		if (res != 0) {
    e788:	2800      	cmp	r0, #0
    e78a:	d1f2      	bne.n	e772 <gpio_nrfx_pin_enable_callback+0x20>
	for (u8_t curr_pin = from_pin; curr_pin <= to_pin; ++curr_pin) {
    e78c:	3401      	adds	r4, #1
    e78e:	b2e4      	uxtb	r4, r4
    e790:	e7ec      	b.n	e76c <gpio_nrfx_pin_enable_callback+0x1a>

0000e792 <uarte_nrfx_config_get>:
{
    e792:	460b      	mov	r3, r1
	*cfg = get_dev_data(dev)->uart_config;
    e794:	6882      	ldr	r2, [r0, #8]
    e796:	e892 0003 	ldmia.w	r2, {r0, r1}
    e79a:	e883 0003 	stmia.w	r3, {r0, r1}
}
    e79e:	2000      	movs	r0, #0
    e7a0:	4770      	bx	lr

0000e7a2 <uarte_nrfx_err_check>:
	return dev->config->config_info;
    e7a2:	6803      	ldr	r3, [r0, #0]
	return config->uarte_regs;
    e7a4:	689b      	ldr	r3, [r3, #8]
    e7a6:	681b      	ldr	r3, [r3, #0]
    uint32_t errsrc_mask = p_reg->ERRORSRC;
    e7a8:	f8d3 0480 	ldr.w	r0, [r3, #1152]	; 0x480
    p_reg->ERRORSRC = errsrc_mask;
    e7ac:	f8c3 0480 	str.w	r0, [r3, #1152]	; 0x480
}
    e7b0:	4770      	bx	lr

0000e7b2 <uarte_nrfx_poll_in>:
	return dev->config->config_info;
    e7b2:	6803      	ldr	r3, [r0, #0]
	const struct uarte_nrfx_data *data = get_dev_data(dev);
    e7b4:	6882      	ldr	r2, [r0, #8]
	return config->uarte_regs;
    e7b6:	689b      	ldr	r3, [r3, #8]
    e7b8:	681b      	ldr	r3, [r3, #0]
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    e7ba:	f8d3 0110 	ldr.w	r0, [r3, #272]	; 0x110
	if (!nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_ENDRX)) {
    e7be:	b138      	cbz	r0, e7d0 <uarte_nrfx_poll_in+0x1e>
	*c = data->rx_data;
    e7c0:	7a12      	ldrb	r2, [r2, #8]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    e7c2:	2000      	movs	r0, #0
    e7c4:	700a      	strb	r2, [r1, #0]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    e7c6:	2201      	movs	r2, #1
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    e7c8:	f8c3 0110 	str.w	r0, [r3, #272]	; 0x110
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    e7cc:	601a      	str	r2, [r3, #0]
	return 0;
    e7ce:	4770      	bx	lr
		return -1;
    e7d0:	f04f 30ff 	mov.w	r0, #4294967295
}
    e7d4:	4770      	bx	lr

0000e7d6 <uarte_nrfx_poll_out>:
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    e7d6:	2200      	movs	r2, #0
	return dev->config->config_info;
    e7d8:	6803      	ldr	r3, [r0, #0]
{
    e7da:	b082      	sub	sp, #8
	return config->uarte_regs;
    e7dc:	689b      	ldr	r3, [r3, #8]
{
    e7de:	f88d 1007 	strb.w	r1, [sp, #7]
	return config->uarte_regs;
    e7e2:	681b      	ldr	r3, [r3, #0]
    e7e4:	f8c3 2120 	str.w	r2, [r3, #288]	; 0x120
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
    e7e8:	f10d 0207 	add.w	r2, sp, #7
    e7ec:	f8c3 2544 	str.w	r2, [r3, #1348]	; 0x544
    p_reg->TXD.MAXCNT = length;
    e7f0:	2201      	movs	r2, #1
    e7f2:	f8c3 2548 	str.w	r2, [r3, #1352]	; 0x548
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    e7f6:	609a      	str	r2, [r3, #8]
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    e7f8:	f8d3 1120 	ldr.w	r1, [r3, #288]	; 0x120
	while (!nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_ENDTX)) {
    e7fc:	2900      	cmp	r1, #0
    e7fe:	d0fb      	beq.n	e7f8 <uarte_nrfx_poll_out+0x22>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    e800:	60da      	str	r2, [r3, #12]
}
    e802:	b002      	add	sp, #8
    e804:	4770      	bx	lr

0000e806 <k_sys_fatal_error_handler>:

extern void sys_arch_reboot(int type);

void k_sys_fatal_error_handler(unsigned int reason,
			       const z_arch_esf_t *esf)
{
    e806:	b508      	push	{r3, lr}
	ARG_UNUSED(reason);

	LOG_PANIC();

	LOG_ERR("Resetting system");
	sys_arch_reboot(0);
    e808:	2000      	movs	r0, #0
    e80a:	f7fe fac5 	bl	cd98 <sys_arch_reboot>

0000e80e <z_fatal_error>:
	return 0;
#endif
}

void z_fatal_error(unsigned int reason, const z_arch_esf_t *esf)
{
    e80e:	b570      	push	{r4, r5, r6, lr}
    e810:	4605      	mov	r5, r0
    e812:	460e      	mov	r6, r1
	return z_impl_k_current_get();
    e814:	f7ff fa9a 	bl	dd4c <z_impl_k_current_get>
#endif

	LOG_ERR("Current thread: %p (%s)", thread,
		log_strdup(thread_name_get(thread)));

	k_sys_fatal_error_handler(reason, esf);
    e818:	4631      	mov	r1, r6
    e81a:	4604      	mov	r4, r0
    e81c:	4628      	mov	r0, r5
    e81e:	f7ff fff2 	bl	e806 <k_sys_fatal_error_handler>
	z_impl_k_thread_abort(thread);
    e822:	4620      	mov	r0, r4
			}
#endif /*CONFIG_ARCH_HAS_NESTED_EXCEPTION_DETECTION */
	}

	k_thread_abort(thread);
}
    e824:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    e828:	f7fe bad4 	b.w	cdd4 <z_impl_k_thread_abort>

0000e82c <z_sys_power_save_idle_exit>:
	z_clock_idle_exit();
    e82c:	f7ff be64 	b.w	e4f8 <z_clock_idle_exit>

0000e830 <z_is_thread_ready>:
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
    e830:	7b43      	ldrb	r3, [r0, #13]
    e832:	06db      	lsls	r3, r3, #27
    e834:	bf03      	ittte	eq
    e836:	6980      	ldreq	r0, [r0, #24]
    e838:	fab0 f080 	clzeq	r0, r0
    e83c:	0940      	lsreq	r0, r0, #5
    e83e:	2000      	movne	r0, #0
}
    e840:	4770      	bx	lr

0000e842 <z_reschedule>:
	return arch_irq_unlocked(key) && !arch_is_in_isr();
    e842:	b921      	cbnz	r1, e84e <z_reschedule+0xc>
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
    e844:	f3ef 8005 	mrs	r0, IPSR
    e848:	b908      	cbnz	r0, e84e <z_reschedule+0xc>
    e84a:	f7fe b925 	b.w	ca98 <arch_swap>
    e84e:	f381 8811 	msr	BASEPRI, r1
    e852:	f3bf 8f6f 	isb	sy
}
    e856:	4770      	bx	lr

0000e858 <z_reschedule_irqlock>:
	return arch_irq_unlocked(key) && !arch_is_in_isr();
    e858:	4603      	mov	r3, r0
    e85a:	b920      	cbnz	r0, e866 <z_reschedule_irqlock+0xe>
    e85c:	f3ef 8205 	mrs	r2, IPSR
    e860:	b90a      	cbnz	r2, e866 <z_reschedule_irqlock+0xe>
    e862:	f7fe b919 	b.w	ca98 <arch_swap>
    e866:	f383 8811 	msr	BASEPRI, r3
    e86a:	f3bf 8f6f 	isb	sy
}
    e86e:	4770      	bx	lr

0000e870 <z_reschedule_unlocked>:
	__asm__ volatile(
    e870:	f04f 0320 	mov.w	r3, #32
    e874:	f3ef 8011 	mrs	r0, BASEPRI
    e878:	f383 8811 	msr	BASEPRI, r3
    e87c:	f3bf 8f6f 	isb	sy
	(void) z_reschedule_irqlock(arch_irq_lock());
    e880:	f7ff bfea 	b.w	e858 <z_reschedule_irqlock>

0000e884 <z_priq_dumb_best>:
	return list->head == list;
    e884:	6803      	ldr	r3, [r0, #0]
}
    e886:	4298      	cmp	r0, r3
    e888:	bf14      	ite	ne
    e88a:	4618      	movne	r0, r3
    e88c:	2000      	moveq	r0, #0
    e88e:	4770      	bx	lr

0000e890 <z_thread_timeout>:
	if (thread->base.pended_on != NULL) {
    e890:	f850 3c10 	ldr.w	r3, [r0, #-16]
{
    e894:	b570      	push	{r4, r5, r6, lr}
    e896:	4604      	mov	r4, r0
	struct k_thread *thread = CONTAINER_OF(timeout,
    e898:	f1a0 0518 	sub.w	r5, r0, #24
	if (thread->base.pended_on != NULL) {
    e89c:	b1cb      	cbz	r3, e8d2 <z_thread_timeout+0x42>
    e89e:	f04f 0320 	mov.w	r3, #32
    e8a2:	f3ef 8611 	mrs	r6, BASEPRI
    e8a6:	f383 8811 	msr	BASEPRI, r3
    e8aa:	f3bf 8f6f 	isb	sy
		_priq_wait_remove(&pended_on(thread)->waitq, thread);
    e8ae:	4629      	mov	r1, r5
    e8b0:	f850 0c10 	ldr.w	r0, [r0, #-16]
    e8b4:	f7ff f8fa 	bl	daac <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
    e8b8:	f814 3c0b 	ldrb.w	r3, [r4, #-11]
    e8bc:	f023 0302 	bic.w	r3, r3, #2
    e8c0:	f804 3c0b 	strb.w	r3, [r4, #-11]
	__asm__ volatile(
    e8c4:	f386 8811 	msr	BASEPRI, r6
    e8c8:	f3bf 8f6f 	isb	sy
	thread->base.pended_on = NULL;
    e8cc:	2300      	movs	r3, #0
    e8ce:	f844 3c10 	str.w	r3, [r4, #-16]
	thread->base.thread_state &= ~_THREAD_SUSPENDED;
    e8d2:	f814 3c0b 	ldrb.w	r3, [r4, #-11]
	if (z_is_thread_ready(thread)) {
    e8d6:	4628      	mov	r0, r5
	thread->base.thread_state &= ~_THREAD_SUSPENDED;
    e8d8:	f023 0314 	bic.w	r3, r3, #20
    e8dc:	f804 3c0b 	strb.w	r3, [r4, #-11]
	if (z_is_thread_ready(thread)) {
    e8e0:	f7ff ffa6 	bl	e830 <z_is_thread_ready>
    e8e4:	b120      	cbz	r0, e8f0 <z_thread_timeout+0x60>
		z_add_thread_to_ready_q(thread);
    e8e6:	4628      	mov	r0, r5
}
    e8e8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    e8ec:	f7ff b92e 	b.w	db4c <z_add_thread_to_ready_q>
    e8f0:	bd70      	pop	{r4, r5, r6, pc}

0000e8f2 <z_new_thread_init>:
{
    e8f2:	b510      	push	{r4, lr}
void z_init_thread_base(struct _thread_base *thread_base, int priority,
		       u32_t initial_state, unsigned int options)
{
	/* k_q_node is initialized upon first insertion in a list */

	thread_base->user_options = (u8_t)options;
    e8f4:	9c02      	ldr	r4, [sp, #8]
	thread_base->thread_state = (u8_t)initial_state;

	thread_base->prio = priority;
    e8f6:	7383      	strb	r3, [r0, #14]
	thread_base->user_options = (u8_t)options;
    e8f8:	7304      	strb	r4, [r0, #12]

	thread_base->sched_locked = 0U;
    e8fa:	2300      	movs	r3, #0
	thread_base->thread_state = (u8_t)initial_state;
    e8fc:	2404      	movs	r4, #4
	thread_base->sched_locked = 0U;
    e8fe:	73c3      	strb	r3, [r0, #15]
	thread_base->thread_state = (u8_t)initial_state;
    e900:	7344      	strb	r4, [r0, #13]
	node->prev = NULL;
    e902:	e9c0 3306 	strd	r3, r3, [r0, #24]
	thread->fn_abort = NULL;
    e906:	e9c0 3313 	strd	r3, r3, [r0, #76]	; 0x4c
	thread->stack_info.size = (u32_t)stackSize;
    e90a:	e9c0 1216 	strd	r1, r2, [r0, #88]	; 0x58
}
    e90e:	bd10      	pop	{r4, pc}

0000e910 <z_abort_timeout>:
{
    e910:	b510      	push	{r4, lr}
	__asm__ volatile(
    e912:	f04f 0220 	mov.w	r2, #32
    e916:	f3ef 8411 	mrs	r4, BASEPRI
    e91a:	f382 8811 	msr	BASEPRI, r2
    e91e:	f3bf 8f6f 	isb	sy
		if (sys_dnode_is_linked(&to->node)) {
    e922:	6803      	ldr	r3, [r0, #0]
    e924:	b13b      	cbz	r3, e936 <z_abort_timeout+0x26>
			remove_timeout(to);
    e926:	f7ff fab7 	bl	de98 <remove_timeout>
			ret = 0;
    e92a:	2000      	movs	r0, #0
	__asm__ volatile(
    e92c:	f384 8811 	msr	BASEPRI, r4
    e930:	f3bf 8f6f 	isb	sy
}
    e934:	bd10      	pop	{r4, pc}
	int ret = -EINVAL;
    e936:	f06f 0015 	mvn.w	r0, #21
    e93a:	e7f7      	b.n	e92c <z_abort_timeout+0x1c>

0000e93c <z_get_next_timeout_expiry>:
{
    e93c:	b510      	push	{r4, lr}
	__asm__ volatile(
    e93e:	f04f 0320 	mov.w	r3, #32
    e942:	f3ef 8411 	mrs	r4, BASEPRI
    e946:	f383 8811 	msr	BASEPRI, r3
    e94a:	f3bf 8f6f 	isb	sy
		ret = next_timeout();
    e94e:	f7ff fab7 	bl	dec0 <next_timeout>
	__asm__ volatile(
    e952:	f384 8811 	msr	BASEPRI, r4
    e956:	f3bf 8f6f 	isb	sy
}
    e95a:	bd10      	pop	{r4, pc}

0000e95c <z_set_timeout_expiry>:
{
    e95c:	b570      	push	{r4, r5, r6, lr}
    e95e:	4604      	mov	r4, r0
    e960:	460e      	mov	r6, r1
	__asm__ volatile(
    e962:	f04f 0320 	mov.w	r3, #32
    e966:	f3ef 8511 	mrs	r5, BASEPRI
    e96a:	f383 8811 	msr	BASEPRI, r3
    e96e:	f3bf 8f6f 	isb	sy
		int next = next_timeout();
    e972:	f7ff faa5 	bl	dec0 <next_timeout>
		if (!imminent && (sooner || IS_ENABLED(CONFIG_SMP))) {
    e976:	2801      	cmp	r0, #1
    e978:	dd05      	ble.n	e986 <z_set_timeout_expiry+0x2a>
    e97a:	42a0      	cmp	r0, r4
    e97c:	dd03      	ble.n	e986 <z_set_timeout_expiry+0x2a>
			z_clock_set_timeout(ticks, idle);
    e97e:	4631      	mov	r1, r6
    e980:	4620      	mov	r0, r4
    e982:	f7fd ff97 	bl	c8b4 <z_clock_set_timeout>
	__asm__ volatile(
    e986:	f385 8811 	msr	BASEPRI, r5
    e98a:	f3bf 8f6f 	isb	sy
}
    e98e:	bd70      	pop	{r4, r5, r6, pc}

0000e990 <_OffsetAbsSyms>:
					    sizeof(struct _preempt_float));
#else
GEN_ABSOLUTE_SYM(_K_THREAD_NO_FLOAT_SIZEOF, sizeof(struct k_thread));
#endif

GEN_ABS_SYM_END
    e990:	4770      	bx	lr
